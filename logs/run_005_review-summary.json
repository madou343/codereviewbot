{
  "timestamp" : "2025-11-03T12:53:43.9646621",
  "index" : 5,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseUpdateRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.model.Territory;\r\nimport com.hom.ebmw.jpa.dao.FilterBaseDAO;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.FilterUtils;\r\nimport com.hom.ebmw.utilities.TranslationProvider;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.util.*;\r\n\r\nimport static com.hom.ebmw.utilities.constans.ASTConst.DB_DELIMITER;\r\n\r\n/**\r\n * The Class FilterBaseUpdateRepository.\r\n */\r\n@Slf4j\r\n@Repository\r\npublic class FilterBaseUpdateRepository {\r\n\r\n    /**\r\n     * The Constant ADD.\r\n     */\r\n    // NOT IN: Remove all Article NOT = ADD\r\n    public static final String ADD = \"NOT IN\";\r\n    /**\r\n     * The Constant REMOVE.\r\n     */\r\n    // IN: Remove all Article = REMOVE\r\n    public static final String REMOVE = \"IN\";\r\n    /**\r\n     * The Constant SMALLER_THAN.\r\n     */\r\n    // NOT IN: Remove all Article NOT = ADD\r\n    public static final String SMALLER_THAN = \"<\";\r\n    /**\r\n     * The Constant BIGGER_THAN.\r\n     */\r\n    // IN: Remove all Article = REMOVE\r\n    public static final String BIGGER_THAN = \">\";\r\n    /**\r\n     * The db services.\r\n     */\r\n    private final JdbcTemplate dbServices;\r\n    /**\r\n     * The filterbase default services.\r\n     */\r\n    private final FilterBaseDAO filterBaseServices;\r\n\r\n    /**\r\n     * The FilterBaseUpdateRepository function updates the FilterBase table in the database.\r\n     *\r\n     * @param JdbcTemplate  dbServices Access the database\r\n     * @param FilterBaseDAO filterBaseServices Access the filterbasedao interface\r\n     * @return A filterbaseupdaterepository object\r\n     * @docauthor Trelent\r\n     */\r\n    public FilterBaseUpdateRepository(JdbcTemplate dbServices, FilterBaseDAO filterBaseServices) {\r\n        this.dbServices = dbServices;\r\n        this.filterBaseServices = filterBaseServices;\r\n    }\r\n\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the table that contains\r\n     * articles.  The function takes a Context object as an argument, and uses it to\r\n     * get a reference to the database.  It then calls getTableName on this database,\r\n     * passing in Table.MAIN as an argument (this is just one way of getting at this value).\r\n     *\r\n     * @param Context ctx Get the application context\r\n     * @return The name of the table to use for storing articles\r\n     * @docauthor Trelent\r\n     */\r\n    private String articleTableName(Context ctx) {\r\n        return articleTableName(ctx, Table.MAIN);\r\n    }\r\n\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the table that is currently active in a given context.\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @param String  name Retrieve the table name from the user session\r\n     * @return The name of the article table\r\n     * @docauthor Trelent\r\n     */\r\n    private String articleTableName(Context ctx, String name) {\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        return tabSession.get(name);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleInPIM function is used to update the article table with information from the AST_PIM_FILTER_ARTICLE_IN_PIM table.\r\n     * The function first updates the ARTICLE REVISION ID in the article table by joining it with AST PIM FILTER ARTICLE IN PIM on\r\n     * ARTICLE NR. Then, it sets FOUND ARTICLES STATUS to NOTPIM and COMMENT to CONCAT(COMMENT,'NOTINPIM') where ARTICLE REVISION ID = 0.\r\n     *\r\n     * @param Context ctx Get the article table name\r\n     * @param String  name Specify the table name\r\n     * @return The number of rows affected by the update\r\n     * @docauthor Trelent\r\n     */\r\n    public void setArticleInPIM(Context ctx, String name) {\r\n\r\n        /*\r\n         * UPDATE AST_ARTICLE_BASE_01 SET ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID\r\n         * FROM AST_ARTICLE_BASE_01 a INNER JOIN AST_PIM_FILTER_ARTICLE_IN_PIM b ON\r\n         * a.ARTICLE_NR = b.ARTICLE_NR\r\n         */\r\n\r\n        String sqlParent = \"UPDATE \" + articleTableName(ctx, name) + \" SET ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"FROM \" + articleTableName(ctx, name) + \" a \" + \"INNER JOIN AST_PIM_FILTER_ARTICLE_IN_PIM b \"\r\n                + \"ON a.ARTICLE_NR = b.ARTICLE_NR\";\r\n\r\n        execute(sqlParent);\r\n\r\n        sqlParent = \"UPDATE \" + articleTableName(ctx, name) + \" SET FOUND_ARTICLE_STATUS = \"\r\n                + FilterStatus.NOTPIM.getId() + \", \" + \"COMMENT = CONCAT(COMMENT,'\" + DB_DELIMITER + FilterType.NOTINPIM\r\n                + \"') \" + \"WHERE ARTICLE_REVISION_ID = 0 \";\r\n\r\n        execute(sqlParent);\r\n    }\r\n\r\n\r\n    /**\r\n     * The importArticleBasicAssortment function imports the basic assortment of articles into the article table.\r\n     *\r\n     * @param Context ctx Determine the table name\r\n     * @param String  pimAssortment Select the assortment name from the ast_pim_filter_article_assortment table\r\n     * @return The number of articles that have been added to the basic assortment\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void importArticleBasicAssortment(Context ctx, String pimAssortment) {\r\n        String sqlParent = \"INSERT INTO \" + articleTableName(ctx) + \" (ID, ARTICLE_NR, ARTICLE_REVISION_ID, BASICASSORTMENT) \" +\r\n                \"SELECT a.ARTICLE_NR, a.ARTICLE_NR, a.ARTICLE_REVISION_ID, 1 \" +\r\n                \"FROM AST_PIM_FILTER_ARTICLE_IN_PIM a INNER JOIN ( \" +\r\n                \"SELECT ARTICLE_REVISION_ID FROM AST_PIM_FILTER_ARTICLE_ASSORTMENT \" +\r\n                \"WHERE ASSORTMENT_NAME = '\" + pimAssortment + \"' \" +\r\n                \"EXCEPT SELECT ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \") b \" +\r\n                \"ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \";\r\n\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n    /**\r\n     * The setArticleloadToAssignMaterial function is used to set the articleload to assign material.\r\n     *\r\n     * @param Context ctx Get the table name\r\n     * @return The following:\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleloadToAssignMaterial(Context ctx) {\r\n        String sqlParent = \"UPDATE \" + articleTableName(ctx) + \" SET CUSTOMER_NR = 'FILE'\";\r\n\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n    /**\r\n     * The importArticleS3Catalog function imports the articles from a given assortment into the article table.\r\n     * The function first inserts all of the articles that are in S3 but not in the article table, and then updates\r\n     * all of those that are already present to have special = 1. This is done by using an EXCEPT clause to find which\r\n     * articles need to be inserted, and an INTERSECT clause for those that need updating.\r\n     *\r\n     * @param Context ctx Get the user session and to get the active assortment\r\n     * @return The number of articles that were added to the database\r\n     * @docauthor Trelent\r\n     */\r\n    public void importArticleS3Catalog(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        String s3Assortment = ctx.getUserSession().get(Params.ACTIVE_S3_CATALOG);\r\n\r\n        String sqlInsert = \"INSERT INTO \" + articleTableName(ctx) + \" (ID, ARTICLE_NR, ARTICLE_REVISION_ID, SPECIAL) \" +\r\n                \"SELECT DISTINCT a.ARTICLE_NR, a.ARTICLE_NR, a.ARTICLE_REVISION_ID, 1 \" +\r\n                \"FROM AST_PIM_FILTER_ARTICLE_IN_PIM a \" +\r\n                \"INNER JOIN (SELECT ARTICLE_REVISION_ID FROM AST_PIM_FILTER_ARTICLE_ASSORTMENT \" +\r\n                \"WHERE ASSORTMENT_NAME = '\" + s3Assortment + \"' EXCEPT SELECT ARTICLE_REVISION_ID \" +\r\n                \"FROM \" + articleTableName(ctx) + \") c ON c.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \";\r\n        dbServices.execute(sqlInsert);\r\n\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx) + \" SET SPECIAL = 1 FROM  \" + articleTableName(ctx) +\r\n                \" a INNER JOIN (SELECT ARTICLE_REVISION_ID \" +\r\n                \"FROM AST_PIM_FILTER_ARTICLE_ASSORTMENT \" +\r\n                \"WHERE ASSORTMENT_NAME = '\" + s3Assortment + \"' \" +\r\n                \"INTERSECT SELECT ARTICLE_REVISION_ID \" +\r\n                \"FROM \" + articleTableName(ctx) + \") b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID WHERE SPECIAL = 0 \";\r\n        dbServices.execute(sqlUpdate);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleBasicAssortment function sets the BASICASSORTMENT column in the article table to 1 for all articles that are part of a given assortment.\r\n     *\r\n     * @param Context ctx Determine the database to use\r\n     * @param String  pimAssortment Select the assortment name from the ast_pim_filter_article_assortment table\r\n     * @return The following:\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleBasicAssortment(Context ctx, String pimAssortment) {\r\n        String sqlParent = \"UPDATE \" + articleTableName(ctx) + \" SET BASICASSORTMENT = 1 \" + \"FROM \"\r\n                + articleTableName(ctx) + \" a \" + \"INNER JOIN AST_PIM_FILTER_ARTICLE_ASSORTMENT b \"\r\n                + \"ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \" + \" WHERE b.ASSORTMENT_NAME = '\" + pimAssortment\r\n                + \"' \";\r\n\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleCountryLock function is used to set the FOUND_ARTICLE_STATUS of an article to -2 (COUNTRYLOCK) if it has been blocked in a certain country.\r\n     *\r\n     * @param Context ctx Get the article table name\r\n     * @param String  territory Set the country lock\r\n     * @param String  name Determine the table name\r\n     * @return The article_revision_id and the country code in which it is blocked\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleCountryLock(Context ctx, String territory, String name) {\r\n        /*\r\n         * UPDATE AST_ARTICLE_BASE_01 SET FOUND_ARTICLE_STATUS = -1 FROM\r\n         * AST_ARTICLE_BASE_01 a INNER JOIN AST_PIM_FILTER_ARTICLE_COUNTRY_LOCK b ON\r\n         * a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID WHERE b.BLOCKED_AT = 'DE'\r\n         */\r\n\r\n        String sqlParent = \"UPDATE \" + articleTableName(ctx, name) + \" SET FOUND_ARTICLE_STATUS = \"\r\n                + FilterStatus.COUNTRYLOCK.getId() + \", \" + \"COMMENT = CONCAT(COMMENT,'\" + DB_DELIMITER\r\n                + FilterType.COUNTRY_LOCK + \"-\" + territory + \"') \" + \"FROM \" + articleTableName(ctx, name) + \" a \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_COUNTRY_LOCK b \"\r\n                + \"ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \" + \"WHERE b.BLOCKED_AT = '\" + territory + \"' \";\r\n\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleNotApproval function sets the FOUND_ARTICLE_STATUS to -2 for all articles that are not approved.\r\n     *\r\n     * @param Context ctx Get the table name\r\n     * @param String  name Determine which table to use\r\n     * @return The following:\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleNotApproval(Context ctx, String name) {\r\n        /*\r\n         * UPDATE AST_ARTICLE_BASE_01 SET FOUND_ARTICLE_STATUS = -1 FROM\r\n         * AST_ARTICLE_BASE_01 a INNER JOIN AST_PIM_FILTER_ARTICLE_NOT_APPROVAL b ON\r\n         * a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID WHERE b.IS_APPROVAL = 0\r\n         */\r\n\r\n        String sqlParent = \"UPDATE \" + articleTableName(ctx, name) + \" SET FOUND_ARTICLE_STATUS = \"\r\n                + FilterStatus.NOTAPPROVAL.getId() + \", \" + \"COMMENT = CONCAT(COMMENT,'\" + DB_DELIMITER\r\n                + FilterType.NOTAPPROVAL + \"') \" + \"FROM \" + articleTableName(ctx, name) + \" a \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_NOT_APPROVAL b \"\r\n                + \"ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \" + \"WHERE b.LABEL = 0 \";\r\n\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleNotActivVTL function is used to set the status of an article to &quot;VTL Status&quot; if it has a VTL status that is not 5.\r\n     *\r\n     * @param Context ctx Get the user session and the current locale\r\n     * @param String  name Get the table name\r\n     * @return The article that is not active in vtl\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleNotActivVTL(Context ctx, String name) {\r\n        /*\r\n         * UPDATE AST_ARTICLE_BASE_01 SET FOUND_ARTICLE_STATUS = -1 FROM\r\n         * AST_ARTICLE_BASE_01 a INNER JOIN AST_PIM_FILTER_ARTICLE_NOT_APPROVAL b ON\r\n         * a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID WHERE b.IS_APPROVAL = 0\r\n         */\r\n\r\n        FilterType filterType = FilterType.VTL_STATUS;\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        Locale locale = ctx.getSession().getCurrentLocale(ctx);\r\n        String tableName = FilterType.VTL_STATUS.name();\r\n        String startDate = CompUtils.getStartDate(ctx).toString();\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, assortment);\r\n        TranslationProvider tmsService = ctx.getServices().getTranslationService();\r\n\r\n        String sqlValue = \"(Select CASE WHEN e.VALID_FROM >= '\" + startDate + \"' THEN NEXT_\" + tableName + \" \"\r\n                + \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" + \"e.ARTICLE_REVISION_ID \"\r\n                + \"from AST_PIM_FILTER_ARTICLE_\" + tableName + \" e \" + \"INNER JOIN \" + articleTableName(ctx, name)\r\n                + \" f ON f.ARTICLE_REVISION_ID = e.ARTICLE_REVISION_ID AND e.TERRITORY = '\" + territory.getKey() + \"' \"\r\n                + \") \";\r\n\r\n        String sqlFormat = \"(Select CASE \" + \"WHEN LABEL = 1 THEN '\"\r\n                + tmsService.getTranslation(\"comment-vtl-status-1\", locale, ctx) + \"' \" + \"WHEN LABEL = 90 THEN '\"\r\n                + tmsService.getTranslation(\"comment-vtl-status-90\", locale, ctx) + \"' \" + \"WHEN LABEL = 99 THEN '\"\r\n                + tmsService.getTranslation(\"comment-vtl-status-99\", locale, ctx) + \"' \"\r\n                + \"ELSE cast(LABEL as varchar(255)) END AS LABEL , ARTICLE_REVISION_ID FROM \" + sqlValue + \" temp  )\";\r\n\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx, name) + \" SET FOUND_ARTICLE_STATUS  = \"\r\n                + FilterStatus.VTL_STATUS.getId() + \" , COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + filterType.name()\r\n                + \"-',b.LABEL  ) FROM \" + articleTableName(ctx, name) + \" a INNER JOIN \" + sqlFormat\r\n                + \" b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID WHERE b.LABEL NOT IN ('5') \"; // 5 = Aktiv\r\n        dbServices.execute(sqlUpdate);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleNoPrice function sets the FOUND_ARTICLE_STATUS to REMOVEBYFILTER and adds a comment\r\n     * to the COMMENT field of all articles in the article table that have a price less than 0.01.\r\n     *\r\n     * @param Context ctx Determine the table name\r\n     * @return Nothing, but changes the database\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleNoPrice(Context ctx) {\r\n        String sqlParent = \"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS = \"\r\n                + FilterStatus.REMOVEBYFILTER.getId() + \", \" + \"COMMENT = CONCAT(COMMENT,'\" + DB_DELIMITER\r\n                + FilterType.NOPRICE + \"') \" + \"FROM \" + articleTableName(ctx) + \" \"\r\n                + \"WHERE CAST (REPLACE(PRICE_FIRST,',','.') as FLOAT) < 0.01 \";\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n\r\n    /**\r\n     * The setArticleRemoveByPositiv function is used to set the FOUND_ARTICLE_STATUS of all articles in the main table\r\n     * that are not found in the identifier table to 4. This means that these articles will be removed from the main\r\n     * article list, as they were not found by any of our identifiers. The function also adds a comment to each article\r\n     * stating that it was removed by postiv (meaning it was not found). The function takes two parameters: ctx and main,\r\n     * which are both strings representing different tables within our database. It does this using an SQL query which is\r\n     * executed through\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param String  identifier Identify the table that is used to compare with\r\n     * @param String  main Determine the table name\r\n     * @return The number of rows affected\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void setArticleRemoveByPositiv(Context ctx, String identifier, String main) {\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx, main) + \" SET FOUND_ARTICLE_STATUS = 4, \" +\r\n                \"COMMENT = CONCAT(COMMENT,'#REMOVEBYPOSTIV') FROM \" + articleTableName(ctx, main) + \" a \" +\r\n                \"INNER JOIN ( Select ARTICLE_NR FROM \" + articleTableName(ctx, main) + \" \" +\r\n                \"EXCEPT Select ARTICLE_NR FROM \" + articleTableName(ctx, identifier) + \") b ON a.ARTICLE_NR = b.ARTICLE_NR \";\r\n\r\n        dbServices.execute(sqlUpdate);\r\n    }\r\n\r\n    /**\r\n     * The addArticleByFilter function adds an article to the database.\r\n     *\r\n     * @param Context      ctx Get the current user\r\n     * @param FilterType   type Determine the type of filter that is being used\r\n     * @param FilterStatus fromStatus Specify the status of the filter to be removed\r\n     * @param FilterStatus toStatus Determine the status of the article\r\n     * @return A list of articles that are added to the database\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void addArticleByFilter(Context ctx, FilterType type, FilterStatus fromStatus, FilterStatus toStatus) {\r\n        articleByFilter(ctx, type, ADD, fromStatus, toStatus);\r\n    }\r\n\r\n\r\n    /**\r\n     * The removeArticleByFilter function removes articles from the database based on a filter.\r\n     *\r\n     * @param Context      ctx Get the current user's id\r\n     * @param FilterType   type Specify the type of filter to be used\r\n     * @param FilterStatus fromStatus Specify the status of the article to be removed\r\n     * @param FilterStatus toStatus Determine the status of the article to be removed\r\n     * @return The number of articles that were removed\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void removeArticleByFilter(Context ctx, FilterType type, FilterStatus fromStatus, FilterStatus toStatus) {\r\n        articleByFilter(ctx, type, REMOVE, fromStatus, toStatus);\r\n    }\r\n\r\n    /**\r\n     * The articleByFilter function is used to filter articles by a given type.\r\n     *\r\n     * @param Context      ctx Get the assortment and the user session\r\n     * @param FilterType   type Determine which filter is being used\r\n     * @param String       direction Determine if the filter is an add or remove filter\r\n     * @param FilterStatus fromStatus Determine the status of the article before filtering\r\n     * @param FilterStatus toStatus Determine the status of the article after filtering\r\n     * @return The sqlupdate string\r\n     * @docauthor Trelent\r\n     */\r\n    public void articleByFilter(Context ctx, FilterType type, String direction, FilterStatus fromStatus,\r\n                                FilterStatus toStatus) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n\r\n        // Check if Type Filter is Set\r\n        boolean valid = true;\r\n        List<Filterbase> filters = new ArrayList<>();\r\n        if (direction.equals(ADD)) {\r\n            filters = filterBaseServices.findAllByAssortmentAndDirectionAndDeleteAndType(assortment,\r\n                    Filterbase.ADD, false, type.name());\r\n        } else if (direction.equals(REMOVE)) {\r\n            filters = filterBaseServices.findAllByAssortmentAndDirectionAndDeleteAndType(assortment,\r\n                    Filterbase.REMOVE, false, type.name());\r\n        }\r\n\r\n        List<Filterbase> typeFilters = filters;\r\n        List<Filterbase> filterBases = new ArrayList<>();\r\n\r\n        if (typeFilters.isEmpty()) {\r\n            valid = false;\r\n        }\r\n\r\n        if (valid) {\r\n            String sqlUpdate = \"\";\r\n            switch (type) {\r\n                case ARTIKELKLASSE:\r\n                    // AST_PIM_FILTER_ARTICLE_CLASS\r\n                    sqlUpdate = getArticleFilterWithStartDate(ctx, \"CLASS\", type,\r\n                            CompUtils.getStartDate(ctx).toString(), direction, fromStatus, toStatus);\r\n                    break;\r\n                case BRANDS:\r\n                    // AST_PIM_FILTER_ARTICLE_BRANDS\r\n                    sqlUpdate = getArticleFilter(ctx, \"BRANDS\", type, direction, fromStatus, toStatus, false);\r\n                    break;\r\n                case GHS_CODES:\r\n                    // AST_PIM_FILTER_ARTICLE_GHS_CODE\r\n                    sqlUpdate = getArticleFilter(ctx, \"GHS_CODE\", type, direction, fromStatus, toStatus, false);\r\n                    break;\r\n                case CONFIG:\r\n                    // AST_PIM_FILTER_ARTICLE_CONFIG\r\n                    sqlUpdate = getArticleFilter(ctx, \"CONFIG\", type, direction, fromStatus, toStatus, false);\r\n                    break;\r\n                case INFOTYPE:\r\n                    // AST_PIM_FILTER_ARTICLE_INFO_TYPE\r\n                    sqlUpdate = getArticleFilterWithStartDate(ctx, \"INFO_TYPE\", type, CompUtils.getStartDate(ctx).toString(), direction, fromStatus,\r\n                            toStatus);\r\n                    break;\r\n                case INTRASTAT:\r\n                    // AST_PIM_FILTER_ARTICLE_INTRA_STAT\r\n                    sqlUpdate = getArticleFilter(ctx, \"INTRA_STAT\", type, direction, fromStatus, toStatus, \"DE\");\r\n                    break;\r\n                case STRUCTURE:\r\n                    // AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUPE\r\n                    sqlUpdate = articleStructureFilter(ctx, fromStatus, toStatus, direction);\r\n                    break;\r\n                case NOTFREE:\r\n                    // AST_PIM_FILTER_ARTICLE_NOT_FREE\r\n                    sqlUpdate = getArticleFilter(ctx, \"NOT_FREE\", type, direction, fromStatus, toStatus, true);\r\n                    break;\r\n                case ZUORDNUNG_MATERIAL:\r\n                    // AST_PIM_FILTER_ARTICLE_ASSIGNED_MATERIAL\r\n                    filterBases = filterBaseServices.findAllByAssortmentAndDirectionAndDelete(assortment, Filterbase.ADD, false);\r\n                    String startDate = CompUtils.getStartDate(ctx).toString();\r\n                    sqlUpdate = articleFilterAssignedMaterial(ctx, startDate, direction, fromStatus, toStatus);\r\n                    if (!filterBases.stream().anyMatch(item -> item.getType().equals(FilterType.S3_CATALOGS.name()))) {\r\n                        setArticleFilterS3CatalogToIgnore(ctx);\r\n                    }\r\n                    break;\r\n                case S3_CATALOGS: // ONLY POSITIV FILTER\r\n                    // AST_PIM_FILTER_ARTICLE_ASSORTMENT | AST_PIM_FILTER_ARTICLE_BRAND\r\n                    filterBases = filterBaseServices.findAllByAssortmentAndDirectionAndDelete(assortment, Filterbase.ADD, false);\r\n                    sqlUpdate = getArticleS3CatalogFilter(ctx, type, direction, fromStatus, toStatus);\r\n                    if (!filterBases.stream().anyMatch(item -> item.getType().equals(FilterType.ZUORDNUNG_MATERIAL.name()))) {\r\n                        setArticleFilterAssignedMaterialToIgnore(ctx);\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            execute(sqlUpdate);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * The execute function executes a statement on the database.\r\n     *\r\n     * @param String statement Pass in the sql statement to be executed\r\n     * @return A boolean\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void execute(String statement) {\r\n        dbServices.execute(statement);\r\n    }\r\n\r\n\r\n    /**\r\n     * The getArticleFilter function is used to create a SQL statement that will update the FOUND_ARTICLE_STATUS column of the AST_PIM_FOUNDARTICLES table.\r\n     * The function takes in 6 parameters:\r\n     * ctx - A Context object, which contains information about the user's session and environment.\r\n     * tableName - A String representing a table name (e.g., &quot;COLOR&quot;). This parameter is used to determine which filter type should be applied (e.g., COLOR or SIZE).\r\n     * filterType - An enum value representing one of several possible filter\r\n     *\r\n     * @param Context      ctx Get the active assortment\r\n     *                     private string articletablename(context ctx) {\r\n     *                     assortment assortment = ctx\r\n     * @param String       tableName Determine the name of the table to be used in the query\r\n     * @param FilterType   filterType Determine which filter is used\r\n     * @param String       direction Determine if the filter is an &quot;in&quot; or &quot;not in&quot; filter\r\n     * @param FilterStatus fromStatus Determine if the article should be updated or not\r\n     * @param FilterStatus toStatus Set the status of the article\r\n     * @param Object       withTerritory Determine if the territory should be included in the filter\r\n     * @return The sql statement for the article filter\r\n     * @docauthor Trelent\r\n     */\r\n    private String getArticleFilter(Context ctx, String tableName, FilterType filterType, String direction,\r\n                                    FilterStatus fromStatus, FilterStatus toStatus, Object withTerritory) {\r\n        String stmtTerritory = \"\";\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, assortment);\r\n        if (withTerritory instanceof Boolean) {\r\n            boolean value = (Boolean) withTerritory;\r\n            stmtTerritory = (value ? \" AND TERRITORY = '\" + territory.getKey() + \"' \" : \"\");\r\n        } else if (withTerritory instanceof String) {\r\n            stmtTerritory = \" AND TERRITORY = '\" + withTerritory + \"'\";\r\n        }\r\n        String sqlValue = \"(SELECT ARTICLE_REVISION_ID, LABEL FROM \" + \" AST_PIM_FILTER_ARTICLE_\" + tableName + \" \" +\r\n                \"WHERE LABEL \" + direction + \" (Select IDENTIFIER from AST_FILTERBASE WHERE [DELETE] = 0 \" +\r\n                \"AND TYPE = '\" + filterType.name() + \"' \" +\r\n                \"AND ASSORTMENT_ID = \" + assortment.getId() +\r\n                \")\" + stmtTerritory + \")\";\r\n\r\n\r\n        StringBuilder sqlUpdate = new StringBuilder();\r\n        sqlUpdate.append(\"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS  = \" + toStatus.getId() + \" \");\r\n        sqlUpdate.append(\", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + filterType.name() + \"-', b.LABEL ) \" + \"FROM \");\r\n        sqlUpdate.append(articleTableName(ctx) + \" \" + \" a INNER JOIN \" + sqlValue);\r\n        sqlUpdate.append(\" b  ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID\");\r\n\r\n        if (!fromStatus.equals(FilterStatus.ALL))\r\n            sqlUpdate.append(\"AND FOUND_ARTICLE_STATUS  = \" + fromStatus.getId());\r\n        return sqlUpdate.toString();\r\n    }\r\n\r\n    /**\r\n     * The getArticleS3CatalogFilter function is used to create a SQL statement that will update the FOUND_ARTICLE_STATUS column of the article table.\r\n     * The function takes in 5 parameters: ctx, tableName, filterType, direction and fromStatus.\r\n     * The first parameter is a Context object which contains information about the current user session. This includes things like what assortment they are currently working with and what territory they are currently working with (if any).\r\n     * The second parameter is a String representing the name of an S3 catalog table (e.g., &quot;S3CATALOG&quot;). This value will be used to construct part\r\n     *\r\n     * @param Context      ctx Get the user session, which is used to get the active assortment\r\n     * @param String       tableName Create the table name for the sql statement\r\n     * @param FilterType   filterType Determine the type of filter to be used\r\n     * @param String       direction Determine whether the filter is an include or exclude filter\r\n     * @param FilterStatus fromStatus Determine the status of the article\r\n     * @param FilterStatus toStatus Determine the status of the article after it has been filtered\r\n     * @return The following string:\r\n     * @docauthor Trelent\r\n     */\r\n    private String getArticleS3CatalogFilter(Context ctx, FilterType filterType, String direction, FilterStatus fromStatus, FilterStatus toStatus) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        String s3Assortment = ctx.getUserSession().get(Params.ACTIVE_S3_CATALOG);\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS  = \" + toStatus.getId() + \" \")\r\n                .append(\", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + filterType.name() + \"-', b.LABEL ) \")\r\n                .append(\" FROM  \" + articleTableName(ctx) + \" a INNER JOIN \")\r\n                .append(\"AST_PIM_FILTER_ARTICLE_BRANDS b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \")\r\n                .append(\"INNER JOIN (SELECT ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \" EXCEPT \")\r\n                .append(\"(SELECT ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \" WHERE SPECIAL = 1 \")\r\n                .append(\"INTERSECT ( Select a.ARTICLE_REVISION_ID from \" + articleTableName(ctx) + \" a \")\r\n                .append(\"INNER JOIN AST_PIM_FILTER_ARTICLE_BRANDS b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \")\r\n                .append(\"INNER JOIN AST_PIM_FILTER_ARTICLE_ASSORTMENT c ON a.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID \")\r\n                .append(\"INNER JOIN AST_FILTERBASE f ON f.IDENTIFIER = b.LABEL  \")\r\n                .append(\"WHERE f.TYPE = 'S3_CATALOGS' AND c.ASSORTMENT_NAME = '\" + s3Assortment + \"' AND  f.[DELETE] = 0 AND f.ASSORTMENT_ID = \" + assortment.getId())\r\n                .append(\"))) c ON a.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID WHERE SPECIAL = 1\");\r\n\r\n\r\n        if (!fromStatus.equals(FilterStatus.ALL))\r\n            sb.append(\"AND FOUND_ARTICLE_STATUS  = \" + fromStatus.getId());\r\n\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * The importArticleS3CatalogFilter function is used to import articles from the S3 catalog into the PIM.\r\n     * The function takes in a context, table name, filter type, direction (up or down), and two FilterStatus objects.\r\n     * It then creates an assortment object using the active assortment from the user session and a string containing\r\n     * information about which S3 catalog is being used.  Next it creates an SQL insert statement that inserts article numbers\r\n     * into our article table for all of those articles that are in both our AST_PIM_FILTER_ARTICLE_ASSORTMENT table and our AST_PIM_FILTER_\r\n     *\r\n     * @param Context      ctx Get the current assortment and s3 catalog from the session\r\n     * @param String       tableName Determine which table to use\r\n     * @param FilterType   filterType Determine if the filter is a brand or category\r\n     * @param String       direction Determine the direction of the filter\r\n     * @param FilterStatus fromStatus Determine if the article is already in the filter\r\n     * @param FilterStatus toStatus Determine if the article is special or not\r\n     * @return A string\r\n     */\r\n    private String importArticleS3CatalogFilter(Context ctx, String tableName, FilterType filterType, String direction, FilterStatus fromStatus, FilterStatus toStatus) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        String s3Assortment = ctx.getUserSession().get(Params.ACTIVE_S3_CATALOG);\r\n\r\n\r\n        String sqlInsert = \"INSERT INTO \" + articleTableName(ctx) + \" (ID, ARTICLE_NR, ARTICLE_REVISION_ID, SPECIAL) \" +\r\n                \"SELECT a.ARTICLE_NR, a.ARTICLE_NR, a.ARTICLE_REVISION_ID, 1 \" +\r\n                \"FROM (Select a.ARTICLE_REVISION_ID from AST_PIM_FILTER_ARTICLE_ASSORTMENT a \" +\r\n                \"INNER JOIN AST_PIM_FILTER_ARTICLE_BRANDS c ON a.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID \" +\r\n                \"WHERE ASSORTMENT_NAME = '\" + s3Assortment + \"' AND c.LABEL IN ( SELECT IDENTIFIER FROM AST_FILTERBASE WHERE [DELETE] = 0 \" +\r\n                \"AND TYPE = '\" + filterType.name() + \"' AND ASSORTMENT_ID = \" + assortment.getId() + \") \" +\r\n                \"EXCEPT SELECT ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \") a INNER JOIN \" +\r\n                \"AST_PIM_FILTER_ARTICLE_IN_PIM b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \";\r\n        dbServices.execute(sqlInsert);\r\n\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx) + \" SET SPECIAL = 1) FROM  \" + articleTableName(ctx) +\r\n                \" a (SELECT ARTICLE_REVISION_ID \" +\r\n                \"FROM AST_PIM_FILTER_ARTICLE_ASSORTMENT \" +\r\n                \"WHERE ASSORTMENT_NAME = '\" + s3Assortment + \"' \" +\r\n                \"INTERSECT SELECT ARTICLE_REVISION_ID \" +\r\n                \"FROM \" + articleTableName(ctx) + \") b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID AND SPECIAL = 0 \";\r\n        return sqlUpdate;\r\n    }\r\n\r\n    /**\r\n     * The getArticleFilterWithStartDate function is used to update the FOUND_ARTICLE_STATUS column in the article table.\r\n     * The function takes a Context, a String representing the name of an article table,\r\n     * a FilterType enum value (which represents one of three possible filter types),\r\n     * and two Strings representing startDate and direction. It also takes two FilterStatus enums which represent fromStatus and toStatus.\r\n     * The function returns a String containing SQL code that will be executed by JDBC later on in order to update the FOUND_ARTICLE_STATUS column in the article table.\r\n     *\r\n     * @param Context      ctx Get the active assortment\r\n     *                     private string getarticlefilterwithenddate(context ctx, string tablename, filtertype filtertype, string enddate) {\r\n     *                     assortment assortment = ctx\r\n     * @param String       tableName Determine which table to use for the filter\r\n     *                     private string getarticlefilter(context ctx, string tablename, filtertype filtertype, filterstatus fromstatus, filterstatus tostatus) {\r\n     *                     assortment assortment = ctx\r\n     * @param FilterType   filterType Determine the type of filter\r\n     * @param String       startDate Set the date of the filter\r\n     * @param String       direction Determine if the filter is an in or out filter\r\n     * @param FilterStatus fromStatus Determine the status of the article before it is updated\r\n     * @param FilterStatus toStatus Set the found_article_status column in the ast_pim_foundarticle table\r\n     * @return A query that is used to update the status of articles\r\n     * @docauthor Trelent\r\n     */\r\n    private String getArticleFilterWithStartDate(Context ctx, String tableName, FilterType filterType, String startDate, String direction,\r\n                                                 FilterStatus fromStatus, FilterStatus toStatus) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n\r\n        String sqlValue = \"(Select CASE \" +\r\n                \"WHEN e.VALID_FROM = '\" + startDate + \"' \" +\r\n                \"THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \" +\r\n                \"WHEN e.VALID_FROM < '\" + startDate + \"' \" +\r\n                \"THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \" +\r\n                \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" +\r\n                \"e.ARTICLE_REVISION_ID \" +\r\n                \"from AST_PIM_FILTER_ARTICLE_\" + tableName + \" e \" +\r\n                \"INNER JOIN \" + articleTableName(ctx) + \" f ON f.ARTICLE_REVISION_ID = e.ARTICLE_REVISION_ID \" +\r\n                \"AND f.BASICASSORTMENT = 0) \";\r\n\r\n        StringBuilder exclude = new StringBuilder();\r\n        exclude.append(\"(((Select CASE \")\r\n                .append(\"WHEN e.VALID_FROM = '\" + startDate + \"' \")\r\n                .append(\"THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \")\r\n                .append(\"WHEN e.VALID_FROM < '\" + startDate + \"' \")\r\n                .append(\"THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \")\r\n                .append(\"ELSE CURRENT_\" + tableName + \" END AS LABEL \")\r\n                .append(\"from AST_PIM_FILTER_ARTICLE_\" + tableName + \" e \")\r\n                .append(\"INNER JOIN \" + articleTableName(ctx) + \" f ON f.ARTICLE_REVISION_ID = e.ARTICLE_REVISION_ID \")\r\n                .append(\"AND f.BASICASSORTMENT = 0) \");\r\n\r\n        exclude.append(\")\");\r\n        if (direction.equals(\"IN\"))\r\n            exclude.append(\"INTERSECT \");\r\n        else\r\n            exclude.append(\"EXCEPT \");\r\n        exclude.append(\"SELECT IDENTIFIER from AST_FILTERBASE WHERE [DELETE] = 0 AND TYPE = '\" + filterType.name() + \"' \");\r\n        exclude.append(\"AND ASSORTMENT_ID = \" + assortment.getId() + \" AND DIRECTION > 0) \");\r\n\r\n\r\n        StringBuilder sqlUpdate = new StringBuilder();\r\n        sqlUpdate.append(\"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS  = \" + toStatus.getId() + \" \")\r\n                .append(\", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + filterType.name() + \"-', b.LABEL ) FROM \")\r\n                .append(articleTableName(ctx) + \" \" + \"a INNER JOIN \" + sqlValue)\r\n                .append(\" b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \")\r\n                .append(\"INNER JOIN \" + exclude + \" temp ON temp.LABEL = b.LABEL \")\r\n        ;\r\n\r\n        if (!fromStatus.equals(FilterStatus.ALL))\r\n            sqlUpdate.append(\"AND FOUND_ARTICLE_STATUS  = \" + fromStatus.getId());\r\n        return sqlUpdate.toString();\r\n    }\r\n\r\n\r\n    /**\r\n     * The articleFilterAssignedMaterial function is used to filter articles based on their assigned material.\r\n     * The function takes in a context, start date, direction (IN or OUT), from status and to status as parameters.\r\n     * It then creates an assortment object using the active assortment from the user session.\r\n     * Next it creates a FilterType object with type ZUORDNUNG_MATERIAL and tableName string with value ASSIGNED_MATERIAL.\r\n     * Then it creates an sqlValue string which contains SQL code that selects either CURRENT_ASSIGNED_MATERIAL or NEXT_ASSIGNED MATERIAL depending on whether\r\n     *\r\n     * @param Context      ctx Get the user session\r\n     * @param String       startDate Determine the date from which to start filtering\r\n     * @param String       direction Determine if the filter is an in or out filter\r\n     * @param FilterStatus fromStatus Determine if the article is already filtered\r\n     * @param FilterStatus toStatus Set the status of the article\r\n     * @return The following string:\r\n     * @docauthor Trelent\r\n     */\r\n    private String\r\n    articleFilterAssignedMaterial(Context ctx, String startDate, String direction,\r\n                                  FilterStatus fromStatus, FilterStatus toStatus) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        ObjectType oType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n\r\n        FilterType filterType = FilterType.ZUORDNUNG_MATERIAL;\r\n        String tableName = \"ASSIGNED_MATERIAL\";\r\n\r\n        String sqlValue = \"(Select CASE \" +\r\n                \"WHEN e.VALID_FROM >= '\" + startDate + \"' \" +\r\n                \"THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \" +\r\n                \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" +\r\n                \"e.ARTICLE_REVISION_ID \" +\r\n                \"from AST_PIM_FILTER_ARTICLE_\" + tableName + \" e \" +\r\n                \"INNER JOIN \" + articleTableName(ctx) + \" f ON f.ARTICLE_REVISION_ID = e.ARTICLE_REVISION_ID \" +\r\n                \"AND f.BASICASSORTMENT = 0 \" + (oType.name().startsWith(ObjectType.IMPEX.name()) ? \"AND f.CUSTOMER_NR = 'FILE' \" : \"\") +\r\n                \"UNION SELECT 'BASIC_ASSORTMENT', ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \" WHERE BASICASSORTMENT = 1 ) \";\r\n\r\n        StringBuilder exclude = new StringBuilder();\r\n        exclude.append(\"((Select LABEL FROM  \")\r\n                .append(sqlValue + \" sub \");\r\n        if (FilterUtils.removeDIS(ctx))\r\n            exclude.append(\"EXCEPT SELECT 'DIS' \");\r\n\r\n        exclude.append(\")\");\r\n        if (direction.equals(\"IN\"))\r\n            exclude.append(\"INTERSECT \");\r\n        else\r\n            exclude.append(\"EXCEPT \");\r\n        exclude.append(\"Select IDENTIFIER from AST_FILTERBASE WHERE [DELETE] = 0 AND TYPE = 'ZUORDNUNG_MATERIAL' AND ASSORTMENT_ID = \" + assortment.getId() + \" AND DIRECTION > 0) \");\r\n\r\n\r\n        StringBuilder sqlUpdate = new StringBuilder();\r\n        sqlUpdate.append(\"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS  = \" + toStatus.getId() + \" \")\r\n                .append(\", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + filterType.name() + \"-', b.LABEL ) FROM \")\r\n                .append(articleTableName(ctx) + \" \" + \"a INNER JOIN \" + sqlValue)\r\n                .append(\" b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \")\r\n                .append(\"INNER JOIN \" + exclude + \" temp ON temp.LABEL = b.LABEL \")\r\n        ;\r\n\r\n        if (!fromStatus.equals(FilterStatus.ALL))\r\n            sqlUpdate.append(\"AND FOUND_ARTICLE_STATUS  = \" + fromStatus.getId());\r\n        return sqlUpdate.toString();\r\n    }\r\n\r\n    /**\r\n     * The setArticleFilterAssignedMaterialToIgnore function sets the FOUND_ARTICLE_STATUS of all articles with a CUSTOMER_NR of 'FILE' to REMOVEBYFILTER.\r\n     * It also appends &quot; ZUORDNUNG_MATERIAL-ALL&quot; to the COMMENT field for each article.\r\n     *\r\n     * @param Context ctx Get the table name\r\n     */\r\n    private void setArticleFilterAssignedMaterialToIgnore(Context ctx) {\r\n\r\n        String sqlValue = \"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS = \" + FilterStatus.REMOVEBYFILTER.getId() + \", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + \" ZUORDNUNG_MATERIAL-ALL') \" +\r\n                \"WHERE CUSTOMER_NR = 'FILE' AND FOUND_ARTICLE_STATUS = \" + FilterStatus.DEFAULT.getId();\r\n\r\n        dbServices.execute(sqlValue);\r\n    }\r\n\r\n    /**\r\n     * The setArticleFilterS3CatalogToIgnore function sets the FOUND_ARTICLE_STATUS of all articles in the database to REMOVEBYFILTER,\r\n     * and appends &quot;S3Catalog-ALL&quot; to their COMMENT field. This is done by executing a SQL query on the article table.\r\n     *\r\n     * @param Context ctx Get the article table name\r\n     */\r\n    private void setArticleFilterS3CatalogToIgnore(Context ctx) {\r\n\r\n        String sqlValue = \"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS = \" + FilterStatus.REMOVEBYFILTER.getId() + \", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + \"S3Catalog-ALL') \" +\r\n                \"WHERE SPECIAL = 1 AND FOUND_ARTICLE_STATUS = \" + FilterStatus.DEFAULT.getId();\r\n\r\n        dbServices.execute(sqlValue);\r\n    }\r\n\r\n    /**\r\n     * The articleFilterAssignedMaterialDis function filters out articles that are assigned to the DIS material group.\r\n     *\r\n     * @param Context ctx Get the article table name\r\n     * @param String  name Get the article table name\r\n     * @return The articlefilterassignedmaterialdis function\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void articleFilterAssignedMaterialDis(Context ctx, String name) {\r\n\r\n        FilterType filterType = FilterType.ZUORDNUNG_MATERIAL;\r\n        String tableName = \"ASSIGNED_MATERIAL\";\r\n        String startDate = CompUtils.getStartDate(ctx).toString();\r\n\r\n        String sqlValue = \"(Select CASE \" + \"WHEN e.VALID_FROM >= '\" + startDate + \"' THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \"\r\n                + \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" + \"e.ARTICLE_REVISION_ID \"\r\n                + \"from AST_PIM_FILTER_ARTICLE_\" + tableName + \" e \" + \"INNER JOIN \" + articleTableName(ctx, name)\r\n                + \" f ON f.ARTICLE_REVISION_ID = e.ARTICLE_REVISION_ID AND f.BASICASSORTMENT = 0 \" + \") \";\r\n\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx, name) + \" SET FOUND_ARTICLE_STATUS  = \"\r\n                + FilterStatus.REMOVEBYFILTER.getId() + \" \" + \", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER\r\n                + filterType.name() + \"-DIS' ) \" + \"FROM \" + articleTableName(ctx, name) + \" \" + \"a INNER JOIN \"\r\n                + sqlValue + \" b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \" + \"WHERE b.LABEL = 'DIS' \";\r\n        dbServices.execute(sqlUpdate);\r\n    }\r\n\r\n    /**\r\n     * The articleStructureFilter function is used to filter articles based on their structure.\r\n     * The function takes in a context, fromStatus, toStatus and direction as parameters.\r\n     * It then creates an assortment object using the active assortment from the user session.\r\n     * It also creates a language object using the user's language preference (from CompUtils).\r\n     * A buffer string is created with either &quot;&gt;&quot; or &quot;&lt;&quot; depending on whether we are adding or removing articles respectively.\r\n     * An sqlSelect string is created which selects all distinct article revisions that have been assigned to any structure group that has been assigned to this assortment (or its parent\r\n     *\r\n     * @param Context      ctx Get the table name of the article\r\n     *                     private string articletablename(context ctx) {\r\n     *                     return computils\r\n     * @param FilterStatus fromStatus Determine the status of the article before it is changed\r\n     * @param FilterStatus toStatus Set the status of the article\r\n     * @param String       direction Determine if the filter is to be applied or removed\r\n     * @return A string\r\n     * @docauthor Trelent\r\n     */\r\n    private String articleStructureFilter(Context ctx, FilterStatus fromStatus, FilterStatus toStatus,\r\n                                          String direction) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String buffer = BIGGER_THAN;\r\n        if (direction.equals(REMOVE)) {\r\n            buffer = SMALLER_THAN;\r\n        }\r\n\r\n        String sqlSelect = \"SELECT DISTINCT c.ARTICLE_REVISION_ID, CONCAT('(',e.STRUCTURE_NAME,')-', fl.LABEL) AS LABEL \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP c INNER JOIN \"\r\n                + \"(SELECT a.STRUCTURE_GROUP_ID, a.LABEL FROM AST_FILTERBASE a INNER JOIN AST_FILTERBASE b \"\r\n                + \"ON a.IDENTIFIER LIKE CONCAT('%', b.STRUCTURE_GROUP_ID,'%') \"\r\n                + \"WHERE a.[DELETE] = 0 AND b.[DELETE] = 0 AND b.ASSORTMENT_ID = \" + assortment.getId() + \" \"\r\n                + \"AND a.ASSORTMENT_ID IS NULL \" + \"AND b.TYPE = 'STRUCTURE' \" + \"UNION \"\r\n                + \"SELECT STRUCTURE_GROUP_ID, LABEL FROM AST_FILTERBASE \" + \"WHERE [DELETE] = 0 AND ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" AND DIRECTION \" + buffer + \" 0 \"\r\n                + \"AND TYPE = 'STRUCTURE') d ON c.STRUCTURE_GROUP_ID = d.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_CLASSIFICATION e ON e.STRUCTURE_GROUP_ID = d.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG fl ON fl.STRUCTURE_GROUP_ID = d.STRUCTURE_GROUP_ID \"\r\n                + \"AND fl.LANGUAGE_ID = \" + Objects.requireNonNull(lang).getKey();\r\n\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS  = \" + toStatus.getId() + \" \"\r\n                + \", COMMENT = CONCAT(COMMENT ,'\" + DB_DELIMITER + \"STRUCTURE-', b.LABEL ) \" + \"FROM \"\r\n                + articleTableName(ctx) + \" \" + \"a INNER JOIN (\" + sqlSelect\r\n                + \") b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \";\r\n\r\n        if (!fromStatus.equals(FilterStatus.ALL))\r\n            sqlUpdate += \"AND a.FOUND_ARTICLE_STATUS  = \" + fromStatus.getId();\r\n\r\n        return sqlUpdate;\r\n    }\r\n\r\n    /**\r\n     * The articleIndividuals function is used to update the status of articles in a given assortment.\r\n     * The function takes as input parameters:\r\n     * - ctx: A Context object that contains information about the user session and other contextual data.\r\n     * - fromStatus: An integer representing the current status of an article (0 = Not Filtered, 1 = Filtered, 2 = Excluded)\r\n     * - toStatus: An integer representing the new status of an article (0 = Not Filtered, 1 = Filtered, 2 = Excluded)\r\n     * - type: A FilterType enum value indicating whether we are filtering\r\n     *\r\n     * @param Context      ctx Get the active assortment from the user session\r\n     * @param FilterStatus fromStatus Determine the status of the article before it is filtered\r\n     * @param FilterStatus toStatus Determine the status of the article after it has been filtered\r\n     * @param FilterType   type Determine the type of filter that is being used\r\n     * @param int          direction Determine the direction of the filter\r\n     * @return A sql query string\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public void articleIndividuals(Context ctx, FilterStatus fromStatus, FilterStatus toStatus, FilterType type,\r\n                                   int direction) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        // Check if Individual Filter is Set\r\n        boolean valid = true;\r\n        List<Filterbase> filters = filterBaseServices.findAllByAssortmentAndDirectionAndDelete(assortment,\r\n                direction, false);\r\n        if (Objects.isNull(filters) || filters.isEmpty()) {\r\n            valid = false;\r\n        } else {\r\n            filters.removeIf(filter -> !filter.getType().equals(type.name()));\r\n            if (filters.isEmpty()) {\r\n                valid = false;\r\n            }\r\n        }\r\n\r\n        if (valid) {\r\n            String sqlUpdate = articleIndividual(ctx, fromStatus, toStatus, direction);\r\n            if (!sqlUpdate.isEmpty()) {\r\n                dbServices.execute(sqlUpdate);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The articleIndividual function is used to update the FOUND_ARTICLE_STATUS column in the article table.\r\n     * It does this by first creating a StringBuilder object called sbSqlSelect, which will be used to create a SQL query that selects all of the rows from AST_FILTERBASE where:\r\n     * - [DELETE] = 0 (the row has not been deleted)\r\n     * - ASSORTMENT_ID = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT).getId() (the row belongs to the active assortment)\r\n     *\r\n     * @param Context      ctx Get the user language\r\n     * @param FilterStatus fromStatus Determine the status of the articles that are to be updated\r\n     * @param FilterStatus toStatus Set the status of the article\r\n     * @param int          direction Determine if the article should be removed or added to the filter\r\n     * @return A sql statement that is executed by the executesql function\r\n     * @docauthor Trelent\r\n     */\r\n    private String articleIndividual(Context ctx, FilterStatus fromStatus, FilterStatus toStatus, int direction) {\r\n        StringBuilder sbSqlSelect = new StringBuilder();\r\n        StringBuilder sbSqlUpdate = new StringBuilder();\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        sbSqlSelect.append(\"SELECT concat(IDENTIFIER,'',LABEL,'',ID,'',TYPE ) FROM AST_FILTERBASE WHERE [DELETE] = 0 AND ASSORTMENT_ID = \");\r\n        sbSqlSelect.append(assortment.getId() + \" AND TYPE LIKE '\" + FilterType.INDIVIDUAL.name());\r\n        sbSqlSelect.append(\"%' AND PARENT_ID IS NULL AND DIRECTION = \" + direction);\r\n\r\n        List<String> identifiers = dbServices.queryForList(sbSqlSelect.toString(), String.class);\r\n        sbSqlSelect = new StringBuilder();\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n        if (!identifiers.isEmpty()) {\r\n            for (String string : identifiers) {\r\n                List<String> tokens = Arrays.asList(string.split(\"\"));\r\n                String identifier = tokens.get(0);\r\n                String label = tokens.get(1);\r\n                String type = tokens.get(3);\r\n\r\n                if (identifier.contains(\"PRODUCT_NAME\")) {\r\n                    sbSqlSelect.append(sbSqlSelect.length() != 0 ? \" UNION \" : \"\");\r\n                    sbSqlSelect.append(\"SELECT a.ARTICLE_REVISION_ID, '\" + label);\r\n                    sbSqlSelect.append(\"' AS LABEL, '\" + type + \"' AS TYPE FROM \" + articleTableName(ctx) + \" a \");\r\n                    sbSqlSelect.append(\"INNER JOIN AST_PIM_ARTICLE_PRODUCT_NAME b ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \");\r\n                    sbSqlSelect.append(\"WHERE b.LANGUAGE_ID = \" + Objects.requireNonNull(lang).getKey() + \" AND \");\r\n                    sbSqlSelect.append(identifier.replace(\"PRODUCT_NAME\", \"UPPER(PRODUCT_NAME)\") + \" \");\r\n                } else if (!identifier.equals(type) && direction == Filterbase.REMOVE_INDIVIDUAL) {\r\n                    sbSqlSelect.append(sbSqlSelect.length() != 0 ? \" UNION \" : \"\");\r\n                    sbSqlSelect.append(\"SELECT ARTICLE_REVISION_ID, '\" + label);\r\n                    sbSqlSelect.append(\"' AS LABEL, '\" + type + \"' AS TYPE FROM \" + articleTableName(ctx) + \" \" + \"WHERE \");\r\n                    sbSqlSelect.append(identifier + \" \");\r\n                } else {\r\n                    String id = tokens.get(2);\r\n                    sbSqlSelect.append(sbSqlSelect.length() != 0 ? \" UNION \" : \"\");\r\n                    sbSqlSelect.append(\"SELECT ARTICLE_REVISION_ID, '\" + label);\r\n                    sbSqlSelect.append(\"' AS LABEL, '\" + type + \"' AS TYPE FROM \" + articleTableName(ctx) + \" a \");\r\n                    sbSqlSelect.append(\"INNER JOIN AST_FILTERBASE b ON a.ARTICLE_NR = b.IDENTIFIER AND b.PARENT_ID = '\" + id);\r\n                    sbSqlSelect.append(\"' AND b.[DELETE] = 0 \");\r\n                }\r\n            }\r\n            sbSqlUpdate.append(\"UPDATE \" + articleTableName(ctx) + \" SET FOUND_ARTICLE_STATUS  = \" + toStatus.getId() + \" \");\r\n            sbSqlUpdate.append(\", COMMENT = CASE WHEN b.LABEL != b.TYPE THEN CONCAT(COMMENT ,'\" + DB_DELIMITER);\r\n            sbSqlUpdate.append(\"',b.TYPE,'-', b.LABEL ) ELSE CONCAT(COMMENT ,'\" + DB_DELIMITER + \"',b.LABEL) END \" + \"FROM \");\r\n            sbSqlUpdate.append(articleTableName(ctx) + \" a INNER JOIN (\" + sbSqlSelect);\r\n            sbSqlUpdate.append(\") b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \");\r\n            if (!fromStatus.equals(FilterStatus.ALL))\r\n                sbSqlUpdate.append(\"AND a.FOUND_ARTICLE_STATUS  = \" + fromStatus.getId());\r\n        }\r\n        return sbSqlUpdate.toString();\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseUpdateRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\LocalCustomerCustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.model.LocalCustomer;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic class LocalCustomerCustomRepository {\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    /**\r\n     * The LocalCustomerCustomRepository function is a custom repository that allows for the creation of\r\n     * new LocalCustomer objects in the database. It also allows for the retrieval of all LocalCustomer\r\n     * objects from the database, and it can be used to delete all LocalCustomers from the database.\r\n     *\r\n     * @param JdbcTemplate dbServices Inject the jdbctemplate bean into this class\r\n     * @return A localcustomercustomrepository object\r\n     */\r\n    public LocalCustomerCustomRepository(JdbcTemplate dbServices) {\r\n        this.dbServices = dbServices;\r\n    }\r\n\r\n    /**\r\n     * The findAll function returns a list of all the LocalCustomer objects in the database.\r\n     *\r\n     * @return A list of localcustomer objects\r\n     */\r\n    @Transactional\r\n    public List<LocalCustomer> findAll() {\r\n        List<LocalCustomer> result = new ArrayList<>();\r\n\r\n        result = dbServices.query(\"Select PARTYID, NAME, CUSTOMERID, COMPANY_BRANCH, STREET, POSTAL, CITY, KAM, E_BUSINESS, COUNTRY, LANGUAGE, PRICELIST, CURRENCY, IS_BUYER, IS_SUPPLIER, IS_PROVIDER from AST_PIM_CUSTOMER\", new LocalCustomerRowMapper());\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findByCustomerNr function is used to find a customer by their customer number.\r\n     *\r\n     * @param String customerNr Query the database for a customer with that specific customer number\r\n     * @return An optional&lt;localcustomer&gt;\r\n     */\r\n    public Optional<LocalCustomer> findByCustomerNr(String customerNr) {\r\n        Optional<LocalCustomer> optCustomer = Optional.empty();\r\n\r\n        List<LocalCustomer> result = new ArrayList<>();\r\n        String sqlQuery = String.format(\"Select PARTYID, NAME, CUSTOMERID, COMPANY_BRANCH, STREET, POSTAL, CITY, KAM, E_BUSINESS, COUNTRY, LANGUAGE, PRICELIST, CURRENCY, IS_BUYER, IS_SUPPLIER, IS_PROVIDER from AST_PIM_CUSTOMER WHERE CUSTOMERID = '%s'\", customerNr);\r\n        result = dbServices.query(sqlQuery, new LocalCustomerRowMapper());\r\n\r\n        if (!result.isEmpty()) {\r\n            optCustomer = Optional.ofNullable(result.get(0));\r\n        }\r\n\r\n        return optCustomer;\r\n    }\r\n\r\n    private class LocalCustomerRowMapper implements RowMapper<LocalCustomer> {\r\n\r\n        @Override\r\n        public LocalCustomer mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            LocalCustomer customer = new LocalCustomer();\r\n            customer.setId(rs.getInt(\"PARTYID\"));\r\n            customer.setCustomerId(rs.getString(\"CUSTOMERID\"));\r\n            customer.setCurrency(rs.getString(\"CURRENCY\"));\r\n            customer.setEBusiness(rs.getString(\"E_BUSINESS\"));\r\n            customer.setBuyer(rs.getBoolean(\"IS_BUYER\"));\r\n            customer.setProvider(rs.getBoolean(\"IS_PROVIDER\"));\r\n            customer.setSupplier(rs.getBoolean(\"IS_SUPPLIER\"));\r\n\r\n            Object language = rs.getObject(\"LANGUAGE\");\r\n            if (Objects.nonNull(language)) {\r\n                if (language instanceof String) {\r\n                    customer.setLanguage(Parse.toString(language));\r\n                }\r\n                if (language instanceof Integer) {\r\n                    customer.setLanguage(String.valueOf(language));\r\n                }\r\n                if (language instanceof Long) {\r\n                    customer.setLanguage(String.valueOf(language));\r\n                }\r\n            }\r\n\r\n            customer.setKam(rs.getString(\"KAM\"));\r\n            customer.setName(rs.getString(\"NAME\"));\r\n            customer.setPostal(rs.getString(\"POSTAL\"));\r\n            customer.setPricelist(rs.getString(\"PRICELIST\"));\r\n            customer.setStreet(rs.getString(\"STREET\"));\r\n            customer.setCountry(rs.getString(\"COUNTRY\"));\r\n            customer.setCompanyBranch(rs.getString(\"COMPANY_BRANCH\"));\r\n            customer.setCity(rs.getString(\"CITY\"));\r\n            return customer;\r\n        }\r\n\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\LocalCustomerCustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\SettingCustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.dao.RoleDAO;\r\nimport com.hom.ebmw.jpa.dao.SettingDAO;\r\nimport com.hom.ebmw.jpa.dao.SettingParameterDAO;\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.jpa.model.SettingParameter;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.enums.SettingDataType;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic class SettingCustomRepository {\r\n\r\n    private final SettingDAO settingServices;\r\n\r\n    private final SettingParameterDAO settingParamServices;\r\n\r\n    private final RoleDAO roleServices;\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    /**\r\n     * The SettingCustomRepository function is a custom repository that allows for the creation of new settings,\r\n     * and the updating of existing settings. It also allows for the deletion of setting parameters from a given\r\n     * setting. The function takes in four arguments: SettingDAO, SettingParameterDAO, RoleDAO and JdbcTemplate.\r\n     *\r\n     * @param SettingDAO          settingServices Access the settingdao class\r\n     * @param SettingParameterDAO settingParamServices Access the settingparameterdao class\r\n     * @param RoleDAO             roleServices Get the role name and id\r\n     * @param JdbcTemplate        dbServices Execute sql queries\r\n     * @return A settingcustomrepository object\r\n     */\r\n    public SettingCustomRepository(SettingDAO settingServices, SettingParameterDAO settingParamServices, RoleDAO roleServices, JdbcTemplate dbServices) {\r\n        this.settingServices = settingServices;\r\n        this.settingParamServices = settingParamServices;\r\n        this.roleServices = roleServices;\r\n        this.dbServices = dbServices;\r\n    }\r\n\r\n    /**\r\n     * The findBySettingType function is used to find a setting by its type.\r\n     *\r\n     * @param Context     ctx Get the current user\r\n     * @param SettingType settingType Create a new setting object\r\n     * @return An optional&lt;setting&gt;\r\n     */\r\n    public Optional<Setting> findBySettingType(Context ctx, SettingType settingType) {\r\n        Optional<Setting> result = Optional.empty();\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        List<Setting> settings = settingServices.findAllByIdentifier(settingType.create());\r\n        if (!settings.isEmpty()) {\r\n            if (settings.size() > 1) {\r\n                String roleId = String.valueOf(user.getRole().getId());\r\n                for (Setting setting : settings) {\r\n                    if (setting.getAllRoles().contains(roleId)) {\r\n                        result = Optional.of(setting);\r\n                    }\r\n                }\r\n            } else {\r\n                result = Optional.of(settings.get(0));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findBySettingTypeAndRoleId function is used to find a setting by its type and role.\r\n     *\r\n     * @param SettingType type Create a settingidentifier object\r\n     * @param String      roleId Find the setting for a specific role\r\n     * @return An optional&lt;setting&gt;\r\n     */\r\n    public Optional<Setting> findBySettingTypeAndRoleId(SettingType type, String roleId) {\r\n        Optional<Setting> result = Optional.empty();\r\n\r\n        List<Setting> settings = settingServices.findAllByIdentifier(type.create());\r\n        if (!settings.isEmpty()) {\r\n\r\n            if (settings.size() > 1) {\r\n                for (Setting setting : settings) {\r\n                    if (setting.getAllRoles().contains(roleId)) {\r\n                        result = Optional.of(setting);\r\n                    }\r\n                }\r\n            } else {\r\n                result = Optional.of(settings.get(0));\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findById function is used to find a SettingParameter by its id.\r\n     *\r\n     * @param Integer id Find a specific setting parameter\r\n     * @return A settingparameter object, but the type is unknown\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Transactional\r\n    public <E> Optional<SettingParameter<E>> findById(Integer id) {\r\n        Optional<SettingParameter<E>> result = Optional.empty();\r\n        @SuppressWarnings(\"rawtypes\")\r\n        Optional<SettingParameter> optParam = settingParamServices.findById(id);\r\n        if (optParam.isPresent()) {\r\n            result = Optional.of((SettingParameter<E>) optParam.get());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The remove function removes a setting from the database.\r\n     *\r\n     * @param Setting setting Get the id of the setting to be deleted\r\n     */\r\n    public void remove(Setting setting) {\r\n        dbServices.execute(\"DELETE FROM AST_SETTING_PARAMETER WHERE SETTING_ID = \" + setting.getId());\r\n        dbServices.execute(\"DELETE FROM AST_SETTING WHERE ID = \" + setting.getId());\r\n    }\r\n\r\n    /**\r\n     * The save function saves a new setting to the database.\r\n     *\r\n     * @param SettingType type Create the identifier of the setting\r\n     * @param String      value Set the value of the setting\r\n     * @return A setting object, which is the same as what you pass in\r\n     */\r\n    public Setting save(SettingType type, String value) {\r\n        Setting setting = new Setting();\r\n        setting.setDatatype(SettingDataType.TEXT.name());\r\n        setting.setIdentifier(type.create());\r\n        setting.setValue(value);\r\n        List<Role> roles = roleServices.findAll();\r\n        List<String> roleIds = new ArrayList<String>();\r\n        roles.forEach(role -> roleIds.add(String.valueOf(role.getId())));\r\n        setting.setRoles(roleIds);\r\n        return settingServices.save(setting);\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\SettingCustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ZinfoCustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\n\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.service.EnumerationService;\r\nimport com.hom.ebmw.jpa.dao.AssortmentDataFileDAO;\r\nimport com.hom.ebmw.jpa.dao.ZinfoFileDAO;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.UserSession;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.ExportFileUtils;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.FileParam;\r\nimport com.hom.ebmw.utilities.enums.ObjectType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\n\r\nimport static com.hom.ebmw.utilities.constans.ASTConst.DB_DELIMITER;\r\n\r\n@Repository\r\npublic class ZinfoCustomRepository {\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    private final AssortmentDataFileDAO assortmentDataFileServices;\r\n\r\n    private final ZinfoFileDAO zinfoFileServices;\r\n\r\n    private final EnumerationService enumServices;\r\n\r\n    /**\r\n     * The ZinfoCustomRepository function is a custom repository that allows for the creation of new Zinfo objects.\r\n     *\r\n     * @param JdbcTemplate          dbServices Access the database\r\n     * @param AssortmentDataFileDAO assortmentDataFileServices Call the getassortmentdatafilebyname function\r\n     * @param ZinfoFileDAO          zinfoFileServices Call the save method in the zinfofiledao class\r\n     * @param EnumerationService    enumServices Call the getenumeration method in enumerationservice\r\n     * @return The zinfocustomrepository class\r\n     */\r\n    public ZinfoCustomRepository(JdbcTemplate dbServices, AssortmentDataFileDAO assortmentDataFileServices, ZinfoFileDAO zinfoFileServices, EnumerationService enumServices) {\r\n        this.dbServices = dbServices;\r\n        this.assortmentDataFileServices = assortmentDataFileServices;\r\n        this.zinfoFileServices = zinfoFileServices;\r\n        this.enumServices = enumServices;\r\n    }\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the table that is currently active in\r\n     * a user's session.  The function takes one parameter, which is a UserSession object.\r\n     * It then uses this object to access the ACTIVE_ARTICLE_BASE_TABLE map, which contains\r\n     * information about what table is currently active for each article base (e.g., &quot;main&quot;, &quot;archive&quot;).\r\n     *\r\n     * @param UserSession uSession Get the name of the table that is currently active\r\n     * @return The name of the table that is currently active in the user session\r\n     */\r\n    private String articleTableName(UserSession uSession) {\r\n        Map<String, String> tabSession = uSession.get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        return tabSession.get(Table.MAIN);\r\n    }\r\n\r\n    /**\r\n     * The loadCurrentArticles function is used to load the current articles from the database into a temporary table.\r\n     * The function first deletes all rows in the temporary table, then inserts all rows from AST_ARTICLE_BASE that have\r\n     * FOUND_ARTICLE_STATUS = 0 and ASSORTMENT_ID = assortment.getId(). This means that only articles with status &quot;0&quot; (not found)\r\n     * are loaded into the temporary table, and only for one specific assortment at a time. The reason for this is because we want to be able to search through these articles later on when we need them, but not\r\n     *\r\n     * @param UserSession uSession Get the name of the table that is used to store articles\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public void loadCurrentArticles(UserSession uSession) {\r\n        Assortment assortment = uSession.get(Params.ACTIVE_ASSORTMENT);\r\n        String sqlDelete = \"TRUNCATE TABLE \" + articleTableName(uSession);\r\n        dbServices.execute(sqlDelete);\r\n\r\n        String sqlSelect = \"INSERT INTO \" + articleTableName(uSession) + \" SELECT \"\r\n                + \"CONCAT(ASSORTMENT_ID,'\" + DB_DELIMITER + \"',[ID]) AS [ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],\"\r\n                + \"[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID] FROM [dbo].[AST_ARTICLE_BASE] \"\r\n                + \"WHERE FOUND_ARTICLE_STATUS = 0 AND ASSORTMENT_ID = \" + assortment.getId();\r\n        dbServices.execute(sqlSelect);\r\n    }\r\n\r\n    /**\r\n     * The getZinfos function is used to retrieve the Zinfo data from the database.\r\n     * The function takes in a Context object, a String type, and a Locale locale as parameters.\r\n     * It returns an ArrayList of Zinfo objects that contain all of the relevant information for each article.\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @param String  type Determine the type of zinfo file to be generated\r\n     * @param Locale  locale Get the language of the description\r\n     *                public list&lt;zinfo&gt; getzinfos(context ctx, string type, locale locale) {\r\n     *                usersession usession = ctx\r\n     * @return A list of zinfo objects\r\n     */\r\n    @Transactional\r\n    public List<Zinfo> getZinfos(Context ctx, String type, Locale locale) {\r\n        UserSession uSession = ctx.getUserSession();\r\n\r\n        List<Zinfo> zinfos = new ArrayList<>();\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        LocalCustomer customer = uSession.get(Params.ACTIVE_CUSTOMER);\r\n        List<ZinfoFile> zinfoFiles = new ArrayList<>();\r\n        List<AssortmentDatafile> xFiles = assortmentDataFileServices.findAllByAssortment(assortment);\r\n        xFiles.forEach(item -> {\r\n            if ((item.getAstFile() instanceof ZinfoFile) && Objects.isNull(item.getAstFile().getDeleteBy())) {\r\n                zinfoFiles.add((ZinfoFile) item.getAstFile());\r\n            }\r\n        });\r\n\r\n        List<Language> languages = enumServices.getAllLanguages();\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(locale.toLanguageTag()))\r\n                .findFirst();\r\n        optLang.ifPresent(lang -> {\r\n\r\n            ZinfoFile currentDatafile = null;\r\n            for (ZinfoFile item : zinfoFiles) {\r\n                String zinfoType = CompUtils.getParameter(ctx, FileParam.ZINFO_TYPE, item);\r\n                if (Objects.nonNull(zinfoType) && zinfoType.equals(type)) {\r\n                    currentDatafile = item;\r\n                } else {\r\n                    CompUtils.setParameter(ctx, FileParam.ZINFO_TYPE, type, currentDatafile);\r\n                }\r\n            }\r\n\r\n            if (Objects.isNull(currentDatafile)) {\r\n                currentDatafile = new ZinfoFile();\r\n                currentDatafile.setName(ExportFileUtils.buildZinfoFileName(ctx, type, assortment));\r\n                currentDatafile = zinfoFileServices.save(currentDatafile);\r\n                CompUtils.setParameter(ctx, FileParam.ZINFO_TYPE, type, currentDatafile);\r\n                CompUtils.setParameter(ctx, FileParam.FILE_TYPE, ObjectType.ZINFO, currentDatafile);\r\n            }\r\n\r\n            String sqlSelect = \"\";\r\n\r\n//\t\tSELECT [IDENTIFIER],[DESCRIPTION],[COMMENT],[ZINFO_TYPE],[CUSTOMERID] FROM [dbo].[AST_PIM_FILTER_ZINFO]\r\n\r\n            if (Objects.nonNull(currentDatafile)) {\r\n                sqlSelect = \"SELECT TEMP.ID, TEMP.ARTICLE_NR , TEMP.[DESCRIPTION], TEMP.PREVIEW_COMMENT, z.COMMENT, TEMP.TYPE FROM (\"\r\n                        + \"SELECT a.ID, a.ARTICLE_NR , ad.[DESCRIPTION],fz.[COMMENT] AS PREVIEW_COMMENT,'\" + type\r\n                        + \"' AS TYPE FROM \" + articleTableName(uSession) + \" a \"\r\n                        + \"LEFT JOIN [dbo].AST_PIM_ARTICLE_DESCRIPTION ad ON ad.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                        + \"AND ad.LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                        + \"LEFT JOIN [dbo].[AST_PIM_FILTER_ZINFO] fz \"\r\n                        + \"ON a.ARTICLE_REVISION_ID = fz.ARTICLE_REVISION_ID \" + \"AND fz.CUSTOMERID = '\"\r\n                        + customer.getCustomerId() + \"' \" + \"AND fz.ZINFO_TYPE = '\" + type + \"') TEMP \"\r\n                        + \"LEFT JOIN [dbo].[AST_ZINFO] z ON z.ARTICLE_NR = TEMP.ARTICLE_NR AND z.TYPE = '\" + type\r\n                        + \"' AND z.FILE_ID = \" + currentDatafile.getId();\r\n            } else {\r\n                sqlSelect = \"SELECT a.ID, a.ARTICLE_NR , ad.[DESCRIPTION],fz.[COMMENT] AS PREVIEW_COMMENT, '' AS COMMENT,'\"\r\n                        + type + \"' AS TYPE FROM \" + articleTableName(uSession) + \" a \"\r\n                        + \"LEFT JOIN [dbo].AST_PIM_ARTICLE_DESCRIPTION ad ON ad.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                        + \"AND ad.LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                        + \"LEFT JOIN [dbo].[AST_PIM_FILTER_ZINFO] fz \"\r\n                        + \"ON a.ARTICLE_REVISION_ID = fz.ARTICLE_REVISION_ID \" + \"AND fz.CUSTOMERID = '\"\r\n                        + customer.getCustomerId() + \"' \" + \"AND fz.ZINFO_TYPE = '\" + type + \"' \";\r\n            }\r\n\r\n            zinfos.addAll(dbServices.query(sqlSelect, new ZinfoRowMapper(currentDatafile, type)));\r\n        });\r\n\r\n        return zinfos;\r\n    }\r\n\r\n    /**\r\n     * The setZinfosFromArticleTemp function is used to set the ZINFO table in the database.\r\n     * The function takes two parameters: a UserSession object and a String type.\r\n     * The UserSession object contains information about the user's session, such as their username, password, etc.\r\n     * The String type parameter is used to determine what kind of ZINFO table should be created (e.g., &quot;ZINFOS&quot;, &quot;ZINFOS_TEMP&quot;).\r\n     *\r\n     * @param UserSession uSession Get the assortment\r\n     * @param String      type Determine which table to use\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public void setZinfosFromArticleTemp(UserSession uSession, String type) {\r\n\r\n        Assortment assortment = uSession.get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        String sqlClear = \"DELETE FROM AST_ZINFO WHERE FILE_ID = \" + assortment.getId() + \" AND TYPE ='\" + type\r\n                + \"'\";\r\n\r\n        dbServices.execute(sqlClear);\r\n\r\n        String sqlInsert = \"INSERT INTO dbo.AST_ZINFO ([ID],[ARTICLE_NR],[DESCRIPTION],[TYPE],[COMMENT],[FILE_ID]) \"\r\n                + \"SELECT CONCAT('\" + assortment.getId() + DB_DELIMITER + type + DB_DELIMITER + \"',ARTICLE_NR), ARTICLE_NR, '', '\" + type\r\n                + \"', COMMENT, \" + assortment.getId() + \" \" + \"FROM \" + articleTableName(uSession);\r\n\r\n        dbServices.execute(sqlInsert);\r\n    }\r\n\r\n    /**\r\n     * The clearBy function is used to clear the AST_ZINFO table of all records\r\n     * associated with a particular datafile.  This function is called by the\r\n     * DataFileServiceBean when a user deletes an uploaded datafile from their\r\n     * workspace.  The function takes in one parameter, which is an AstFile object,\r\n     * and uses that object's id field to delete all records from AST_ZINFO where the FILE_ID matches.\r\n     *\r\n     * @param AstFile datafile Get the file id\r\n     * @return A boolean value\r\n     */\r\n    @Transactional\r\n    public void clearBy(AstFile datafile) {\r\n        String sqlClear = \"\";\r\n        sqlClear = \"DELETE FROM AST_ZINFO WHERE FILE_ID = \" + datafile.getId();\r\n        dbServices.execute(sqlClear);\r\n    }\r\n\r\n    /**\r\n     * The removeBy function is used to remove a ZinfoFile from the database.\r\n     *\r\n     * @param Context   ctx Get the current user\r\n     *                  public void removeby(context ctx, zinfofile zinfofile) {\r\n     *                  <p>\r\n     *                  string sqlclear = &quot;&quot;;\r\n     *                  <p>\r\n     *                  sqlclear = &quot;delete from ast_zinfo where file_id = &quot; + zinfofile\r\n     * @param ZinfoFile zinfofile Get the id of the file to be deleted\r\n     * @return The number of rows deleted\r\n     */\r\n    @Transactional\r\n    public void removeBy(Context ctx, ZinfoFile zinfofile) {\r\n        String sqlClear = \"\";\r\n\r\n        sqlClear = \"DELETE FROM AST_ZINFO WHERE FILE_ID = \" + zinfofile.getId();\r\n        dbServices.execute(sqlClear);\r\n\r\n        zinfofile.setDeleteBy(ctx.getSession().getCurrentUser(ctx));\r\n        zinfofile.setDeleteOn(LocalDateTime.now());\r\n        ctx.getServices().getZinfoFileService().save(zinfofile);\r\n\r\n    }\r\n\r\n    /**\r\n     * The insertIntoTable function takes a UserSession and a List of Zinfo objects as parameters.\r\n     * It then creates an empty StringBuilder object called body, which will be used to store the SQL query that is created in the for loop below.\r\n     * The insertHeader variable stores the first part of our SQL query, which will not change throughout this function's execution.\r\n     * The for loop iterates through each Zinfo object in zinfos and calls insertZinfo on it, appending its return value to body with appropriate punctuation (a comma if there are already values stored in body).\r\n     * Finally, dbServices' execute method is\r\n     *\r\n     * @param UserSession       uSession Get the userid, which is used to set the created_by and updated_by fields in the database\r\n     * @param List&lt;Zinfo&gt; zinfos Insert multiple rows at once\r\n     * @return A string like this:\r\n     */\r\n    @Transactional\r\n    public void insertIntoTable(UserSession uSession, List<Zinfo> zinfos) {\r\n        StringBuilder body = new StringBuilder();\r\n        String insertHeader = \"INSERT INTO [dbo].[AST_ZINFO] ([ID],[ARTICLE_NR],[DESCRIPTION],[TYPE],[COMMENT],[FILE_ID]) VALUES\";\r\n        for (Zinfo zinfo : zinfos) {\r\n            body.append((body.length() == 0 ? \"\" : \",\") + insertZinfo(zinfo));\r\n        }\r\n        dbServices.execute(insertHeader + \" \" + body);\r\n    }\r\n\r\n    /**\r\n     * The insertZinfo function takes a Zinfo object as an argument and returns a string that can be used to insert the\r\n     * information from the Zinfo object into the database. The function is called by insertZinfos, which uses it to create\r\n     * strings for each of its arguments (each of which is a Zinfo object). These strings are then concatenated together in\r\n     * order to form one large SQL query. This query is executed by executeInsertQuery, and all of this happens within the\r\n     * context of inserting multiple zinfos at once (hence why we call this function from within insertZinfos). The reason\r\n     *\r\n     * @param Zinfo zinfo Get the values of the zinfo object\r\n     * @return A string that is used in the insertzinfofile function\r\n     */\r\n    private String insertZinfo(Zinfo zinfo) {\r\n        /*\r\n         * INSERT INTO [dbo].[AST_ZINFO]\r\n         * ([ID],[ARTICLE_NR],[DESCRIPTION],[TYPE],[COMMENT],[FILE_ID]) VALUES (<ID,\r\n         * varchar(255),>,<ARTICLE_NR, varchar(255),>,<DESCRIPTION,\r\n         * varchar(255),>,<TYPE, varchar(255),>,<COMMENT, varchar(255),>,<FILE_ID,\r\n         * int,>)\r\n         */\r\n\r\n        return \"(\" + \"'\" + zinfo.getZinfoFile().getId() + DB_DELIMITER + zinfo.getType() + DB_DELIMITER + zinfo.getArticleNr()\r\n                + \"', \" + \"'\" + zinfo.getArticleNr().replace(\"'\", \"''\") + \"', \" + \"'\"\r\n                + (Objects.nonNull(zinfo.getArticleDescription()) ? zinfo.getArticleDescription() : \"\").replace(\"'\",\r\n                \"''\")\r\n                + \"', \" + \"'\" + zinfo.getType() + \"', \" + \"'\"\r\n                + (Objects.nonNull(zinfo.getComment()) ? zinfo.getComment() : \"\").replace(\"'\", \"''\") + \"', \"\r\n                + zinfo.getZinfoFile().getId() + \")\";\r\n    }\r\n\r\n    /**\r\n     * The findTypeByDatafile function takes a DataFile object as an argument and returns a list of strings.\r\n     * The function queries the database for all unique types in the AST_ZINFO table where FILE_ID is equal to\r\n     * the id of the datafile passed into this function. It then creates a new list, iterates through each row in\r\n     * table, and adds each type to result before returning it.\r\n     *\r\n     * @param DataFile datafile Get the file_id from the datafile object\r\n     * @return A list of strings\r\n     */\r\n    @Transactional\r\n    public List<String> findTypeByDatafile(DataFile datafile) {\r\n\r\n        String sqlSelect = \"SELECT DISTINCT TYPE FROM AST_ZINFO WHERE FILE_ID = \" + datafile.getId();\r\n\r\n        List<Map<String, Object>> table = dbServices.queryForList(sqlSelect);\r\n        List<String> result = new ArrayList<>();\r\n        table.forEach(row -> result.add((String) row.get(\"TYPE\")));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The countAllByDatafile function returns the number of rows in the AST_ZINFO table that have a FILE_ID value equal to\r\n     * the id value of an AstFile object.  This function is used by other functions to determine how many rows are in a file,\r\n     * and thus how many times they need to iterate through it.\r\n     *\r\n     * @param AstFile dataFile Specify the file to be counted\r\n     * @return The number of records in the table ast_zinfo for a given data file\r\n     */\r\n    @Transactional\r\n    public int countAllByDatafile(AstFile dataFile) {\r\n        int result = 0;\r\n        String sqlSelect = \"SELECT COUNT(*) AS COUNTER FROM AST_ZINFO WHERE FILE_ID = \" + dataFile.getId();\r\n        result = dbServices.queryForObject(sqlSelect, Integer.class);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The countAllwithCommentByDatafile function returns the number of records in the AST_ZINFO table that have a non-empty comment field and are associated with a particular data file.\r\n     *\r\n     * @param AstFile dataFile Get the id of the datafile\r\n     * @return The number of records in the ast_zinfo table\r\n     */\r\n    @Transactional\r\n    public int countAllwithCommentByDatafile(AstFile dataFile) {\r\n        int result = 0;\r\n        String sqlSelect = \"SELECT COUNT(*) AS COUNTER FROM AST_ZINFO WHERE COMMENT != '' AND FILE_ID = \"\r\n                + dataFile.getId();\r\n        result = dbServices.queryForObject(sqlSelect, Integer.class);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findAllByAssortmentAndType function is used to find all Zinfo objects in the database that are associated with a given assortment and type.\r\n     *\r\n     * @param Assortment assortment Get the assortment id from\r\n     * @param String     type Determine the type of zinfo object to create\r\n     * @return A list of zinfo objects\r\n     */\r\n    @Transactional\r\n    public List<Zinfo> findAllByAssortmentAndType(Assortment assortment, String type) {\r\n        List<Zinfo> result = new ArrayList<>();\r\n        String sqlSelect = \"SELECT az.ID ,az.ARTICLE_NR ,az.DESCRIPTION ,az.TYPE ,az.COMMENT ,az.FILE_ID ,az.PREVIEW_COMMENT \"\r\n                + \"FROM AST_ZINFO az INNER JOIN AST_ASSORTMENT_DATAFILE aad ON az.FILE_ID = aad.FILE_ID \"\r\n                + \"WHERE aad.ASSORTMENT_ID = \" + assortment.getId() + \" AND TYPE = '\" + type\r\n                + \"' AND az.COMMENT != '' \";\r\n\r\n        result.addAll(dbServices.query(sqlSelect, new ZinfoRowMapper(type)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findAllByAssortment function is used to find all the data files associated with a given assortment.\r\n     *\r\n     * @param Assortment assortment Get the assortment id\r\n     * @return A map with the following structure:\r\n     */\r\n    @Transactional\r\n    public Map<String, Integer> findAllByAssortment(Assortment assortment) {\r\n        Map<String, Integer> result = new HashMap<>();\r\n        String sqlSelect = \"SELECT az.TYPE ,az.FILE_ID \"\r\n                + \"FROM AST_ZINFO az INNER JOIN AST_ASSORTMENT_DATAFILE aad ON az.FILE_ID = aad.FILE_ID \"\r\n                + \"WHERE aad.ASSORTMENT_ID = \" + assortment.getId() + \" \" + \"GROUP BY az.TYPE ,az.FILE_ID \";\r\n\r\n        List<Map<String, Object>> resultSet = dbServices.queryForList(sqlSelect);\r\n        resultSet.forEach(item ->\r\n                result.put(Parse.toString(item.get(\"TYPE\")), Parse.toInt(item.get(\"FILE_ID\")))\r\n        );\r\n\r\n        return result;\r\n    }\r\n\r\n    private class ZinfoRowMapper implements RowMapper<Zinfo> {\r\n\r\n        private ZinfoFile zinfoFile = null;\r\n        private String type = \"\";\r\n\r\n        public ZinfoRowMapper(ZinfoFile zinfoFile, String type) {\r\n            this.zinfoFile = zinfoFile;\r\n            this.type = type;\r\n        }\r\n\r\n        public ZinfoRowMapper(String type) {\r\n            zinfoFile = new ZinfoFile();\r\n            this.type = type;\r\n        }\r\n\r\n        @Override\r\n        public Zinfo mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            Zinfo zInfo = new Zinfo();\r\n            zInfo.setId(rs.getString(\"ID\"));\r\n            zInfo.setArticleNr(rs.getString(\"ARTICLE_NR\"));\r\n            zInfo.setArticleDescription(rs.getString(\"DESCRIPTION\"));\r\n            zInfo.setComment(rs.getString(\"COMMENT\"));\r\n            zInfo.setPreview_comment(rs.getString(\"PREVIEW_COMMENT\"));\r\n            zInfo.setType(type);\r\n            zInfo.setZinfoFile(zinfoFile);\r\n            return zInfo;\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ZinfoCustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\LocalCustomerDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.LocalCustomer;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.Optional;\r\n\r\npublic interface LocalCustomerDAO extends JpaRepository<LocalCustomer, Integer> {\r\n\r\n    Optional<LocalCustomer> findByCustomerId(String customerId);\r\n\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\LocalCustomerDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ParameterDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.AstFile;\r\nimport com.hom.ebmw.jpa.model.Parameter;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\npublic interface ParameterDAO extends JpaRepository<Parameter, Integer> {\r\n    Optional<Parameter> findByParamAndFile(String Param, AstFile file);\r\n\r\n    List<Parameter> findAllByParam(String Param);\r\n\r\n    List<Parameter> findAllByFile(AstFile file);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ParameterDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\PermissionDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Permission;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.Optional;\r\n\r\n\r\n@Repository\r\npublic interface PermissionDAO extends JpaRepository<Permission, Integer> {\r\n\r\n    Optional<Permission> findByName(String Name);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\PermissionDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ProjectDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Project;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.Optional;\r\n\r\npublic interface ProjectDAO extends JpaRepository<Project, Long> {\r\n\r\n    Optional<Project> findByCustomerNr(String customerNr);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ProjectDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ProjectRoleDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Project;\r\nimport com.hom.ebmw.jpa.model.ProjectRole;\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\npublic interface ProjectRoleDAO extends JpaRepository<ProjectRole, Integer> {\r\n\r\n    Optional<ProjectRole> findByProjectAndRole(Project project, Role role);\r\n\r\n    List<ProjectRole> findAllByRole(Role role);\r\n\r\n    List<ProjectRole> findAllByProject(Project project);\r\n\r\n    List<ProjectRole> findAllByProjectAndRole(Project project, Role role);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ProjectRoleDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\PromotionDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.ProjectRole;\r\nimport com.hom.ebmw.jpa.model.Promotion;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\n\r\npublic interface PromotionDAO extends JpaRepository<Promotion, Integer> {\r\n    List<Promotion> findAllByProjectRoleAndDeleteBy(ProjectRole projectRole, User delete);\r\n\r\n    List<Promotion> findAllByProjectRole(ProjectRole projectRole);\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\PromotionDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\RoleDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic interface RoleDAO extends JpaRepository<Role, Integer> {\r\n\r\n    Optional<Role> findByName(String name);\r\n\r\n    @Query(\"Select r from Role r Inner Join RoleUser ru ON ru.role = r AND ru.user = :user\")\r\n    List<Role> findAllInUser(@Param(\"user\") User user);\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\RoleDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\RolePermissionDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Permission;\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.RolePermission;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.List;\r\n\r\n@Repository\r\npublic interface RolePermissionDAO extends JpaRepository<RolePermission, Long> {\r\n\r\n    List<RolePermission> findByPermission(Permission permission);\r\n\r\n    List<RolePermission> findByRole(Role role);\r\n\r\n    List<RolePermission> findByRoleAndPermission(Role role, Permission permission);\r\n\r\n    int removeByRole(Role role);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\RolePermissionDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\RoleUserDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.RoleUser;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\npublic interface RoleUserDAO extends JpaRepository<com.hom.ebmw.jpa.model.RoleUser, Integer> {\r\n    List<RoleUser> findAllByUser(User user);\r\n\r\n    List<RoleUser> findAllByRole(Role role);\r\n\r\n    Optional<RoleUser> findByRoleAndUser(Role role, User user);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\RoleUserDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\SettingDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\npublic interface SettingDAO extends JpaRepository<Setting, Long> {\r\n\r\n    Optional<Setting> findByIdentifier(String Identifer);\r\n\r\n    List<Setting> findAllByIdentifier(String Identifer);\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\SettingDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\SettingParameterDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.jpa.model.SettingParameter;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@SuppressWarnings(\"rawtypes\")\r\npublic interface SettingParameterDAO extends JpaRepository<SettingParameter, Integer> {\r\n\r\n    <E> Optional<SettingParameter<E>> findByParam(String param);\r\n\r\n\r\n    <E> Optional<SettingParameter<E>> findByParamAndSetting(String param, Setting setting);\r\n\r\n    <E> List<SettingParameter<E>> findAllBySettingOrderByDisplayOrder(Setting setting);\r\n\r\n    int deleteBySetting(Setting setting);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\SettingParameterDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\StorageDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.AstFile;\r\nimport com.hom.ebmw.jpa.model.Storage;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.Optional;\r\n\r\npublic interface StorageDAO extends JpaRepository<Storage, Integer> {\r\n    Optional<Storage> findByAstFile(AstFile file);\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\StorageDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\TemplateDataDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.TemplateData;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\n\r\npublic interface TemplateDataDAO extends JpaRepository<TemplateData, Long> {\r\n\r\n    List<TemplateData> findAllByDeleted(boolean deleted);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\TemplateDataDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\UserDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\npublic interface UserDAO extends JpaRepository<User, Integer> {\r\n\r\n    Optional<User> findByUserId(String userId);\r\n\r\n    List<User> findAllByActive(boolean active);\r\n\r\n    @Query(\"Select u from User u Inner Join RoleUser ru ON ru.user = u AND ru.role = :role\")\r\n    List<User> findAllInRole(@Param(\"role\") Role role);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\UserDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\UserParameterDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.jpa.model.UserParameter;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\npublic interface UserParameterDAO extends JpaRepository<UserParameter, Long> {\r\n    List<UserParameter> findAllByUser(User user);\r\n\r\n    Optional<UserParameter> findByUserAndParam(User user, String Param);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\UserParameterDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ZinfoDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.Zinfo;\r\nimport com.hom.ebmw.jpa.model.ZinfoFile;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.List;\r\n\r\npublic interface ZinfoDAO\r\n        extends\r\n        JpaRepository<Zinfo, String> {\r\n\r\n    List<Zinfo> findAllByZinfoFileAndType(ZinfoFile zinfoFile, String type);\r\n\r\n    List<Zinfo> findAllByZinfoFile(ZinfoFile zinfoFile);\r\n\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ZinfoDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ZinfoFileDAO.java =====\n```\npackage com.hom.ebmw.jpa.dao;\r\n\r\nimport com.hom.ebmw.jpa.model.ZinfoFile;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\nimport java.util.Optional;\r\n\r\npublic interface ZinfoFileDAO extends JpaRepository<ZinfoFile, Integer> {\r\n    Optional<ZinfoFile> findByName(String name);\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\ZinfoFileDAO.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\ArticleBase.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.enums.AstDateFormat;\r\nimport com.hom.ebmw.utilities.enums.FilterStatus;\r\n\r\nimport javax.persistence.*;\r\nimport java.io.Serializable;\r\nimport java.text.DecimalFormat;\r\nimport java.text.NumberFormat;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n/**\r\n * The persistent class for the AST_ARTICLE_BASE_01 database table.\r\n */\r\n@Entity\r\n@Table(name = \"AST_ARTICLE_BASE\")\r\n@NamedQuery(name = \"ArticleBase.findAll\", query = \"SELECT a FROM ArticleBase a\")\r\npublic class ArticleBase\r\n        implements\r\n        Serializable {\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @Id\r\n    @Column(name = \"ID\")\r\n    private String id;\r\n\r\n    @Column(name = \"ARTICLE_NR\")\r\n    private String articleNr = \"\";\r\n\r\n    @Column(name = \"ARTICLE_REVISION_ID\")\r\n    private int articleRevisionId = 0;\r\n\r\n    @Column(name = \"BASICASSORTMENT\")\r\n    private int basicassortment = 0;\r\n\r\n    @Column(name = \"[COMMENT]\")\r\n    private String comment = \"\";\r\n\r\n    @Column(name = \"CURRENCY\")\r\n    private String currency = \"\";\r\n\r\n    @Column(name = \"CUSTOMER_ARTICLE_NR\")\r\n    private String customerArticleNr = \"\";\r\n\r\n    @Column(name = \"CUSTOMER_NR\")\r\n    private String customerNr = \"\";\r\n\r\n    @Column(name = \"FOUND_ARTICLE_STATUS\")\r\n    private int foundArticleStatus = -1;\r\n\r\n    @Column(name = \"PRICE_FIRST\")\r\n    private String priceFirst = \"\";\r\n\r\n    @Column(name = \"PRICE_TYPE\")\r\n    private String priceType = \"\";\r\n\r\n    @Column(name = \"PRICE_X\")\r\n    private String priceX = \"\";\r\n\r\n    @Column(name = \"SCALELIMIT\")\r\n    private String scalelimit = \"\";\r\n\r\n    @Column(name = \"SPECIAL\")\r\n    private int special = 0;\r\n\r\n    @Column(name = \"TERRITORY\")\r\n    private String territory = \"\";\r\n\r\n    @Column(name = \"VALID_FROM\")\r\n    private String validFrom = \"\";\r\n\r\n    @Column(name = \"VALID_TO\")\r\n    private String validTo = \"\";\r\n\r\n    @Transient\r\n    private String productName = \"\";\r\n\r\n    // bi-directional many-to-one association to Assortment\r\n    @ManyToOne\r\n    @JoinColumn(name = \"ASSORTMENT_ID\")\r\n    private AstFile assortment = null;\r\n\r\n    public ArticleBase() {\r\n    }\r\n\r\n    public ArticleBase(\r\n            AstFile assortment) {\r\n        this.assortment = assortment;\r\n    }\r\n\r\n    public String getId() {\r\n        return this.id;\r\n    }\r\n\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getArticleNr() {\r\n        return this.articleNr;\r\n    }\r\n\r\n    public void setArticleNr(String articleNr) {\r\n        this.articleNr = articleNr.trim();\r\n    }\r\n\r\n    public int getArticleRevisionId() {\r\n        return this.articleRevisionId;\r\n    }\r\n\r\n    public void setArticleRevisionId(int articleRevisionId) {\r\n        this.articleRevisionId = articleRevisionId;\r\n    }\r\n\r\n    public int getBasicassortment() {\r\n        return this.basicassortment;\r\n    }\r\n\r\n    public boolean isBasicassortment() {\r\n        return this.basicassortment == 1;\r\n    }\r\n\r\n    public boolean isS3Catalog() {\r\n        return this.basicassortment == 2;\r\n    }\r\n\r\n    public void setBasicassortment(int basicassortment) {\r\n        this.basicassortment = basicassortment;\r\n    }\r\n\r\n    public void setBasicassortment(boolean basicassortment) {\r\n        this.basicassortment = basicassortment ? 1 : 0;\r\n    }\r\n\r\n    public String getComment() {\r\n        if (Objects.nonNull(comment)) {\r\n            List<String> comments = Arrays.asList(comment.split(\"#\"));\r\n            Set<String> commentSet = new HashSet<String>();\r\n            comments.forEach(item -> {\r\n                if (!item.isEmpty())\r\n                    commentSet.add(item);\r\n            });\r\n\r\n            comment = \"\";\r\n            for (String item : commentSet) {\r\n                comment += (comment.isEmpty() ? \"\" : \"#\") + item;\r\n            }\r\n        } else {\r\n            comment = \"\";\r\n        }\r\n        return comment;\r\n    }\r\n\r\n    public void setComment(String comment) {\r\n        this.comment = comment;\r\n    }\r\n\r\n    public String getCurrency() {\r\n        return this.currency;\r\n    }\r\n\r\n    public void setCurrency(String currency) {\r\n        this.currency = currency;\r\n    }\r\n\r\n    public String getCustomerArticleNr() {\r\n        return this.customerArticleNr;\r\n    }\r\n\r\n    public void setCustomerArticleNr(String customerArticleNr) {\r\n        this.customerArticleNr = customerArticleNr;\r\n    }\r\n\r\n    public String getCustomerNr() {\r\n        return this.customerNr;\r\n    }\r\n\r\n    public void setCustomerNr(String customerNr) {\r\n        this.customerNr = customerNr;\r\n    }\r\n\r\n    public int getFoundArticleStatus() {\r\n        return this.foundArticleStatus;\r\n    }\r\n\r\n    public FilterStatus getFoundArticleFilterStatus() {\r\n        return FilterStatus.getById(foundArticleStatus);\r\n    }\r\n\r\n    public void setFoundArticleStatus(FilterStatus status) {\r\n        this.foundArticleStatus = status.getId();\r\n    }\r\n\r\n    public void setFoundArticleStatus(int foundArticleStatus) {\r\n        this.foundArticleStatus = foundArticleStatus;\r\n    }\r\n\r\n    public String getPriceFirst() {\r\n        double dValue = Parse.toDouble(priceFirst);\r\n        return String.valueOf(dValue);\r\n    }\r\n\r\n    public String getPriceFirstWithThousend() {\r\n        double dValue = Parse.toDouble(priceFirst);\r\n        String pattern = \"#,##0.00\";\r\n        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.GERMAN);\r\n        df.applyPattern(pattern);\r\n        return df.format(dValue);\r\n    }\r\n\r\n    public void setPriceFirst(String priceFirst) {\r\n        double dValue = Parse.toDouble(priceFirst);\r\n        this.priceFirst = String.valueOf(dValue);\r\n    }\r\n\r\n    public String getPriceType() {\r\n        return this.priceType;\r\n    }\r\n\r\n    public void setPriceType(String priceType) {\r\n        this.priceType = priceType;\r\n    }\r\n\r\n    public String getPriceX() {\r\n        double dValue = Parse.toDouble(priceX);\r\n        return String.valueOf(dValue);\r\n    }\r\n\r\n    public String getPriceXWithThousend() {\r\n        double dValue = Parse.toDouble(priceX);\r\n        String pattern = \"#,##0.00\";\r\n        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.GERMAN);\r\n        df.applyPattern(pattern);\r\n        return df.format(dValue);\r\n    }\r\n\r\n    public void setPriceX(String priceX) {\r\n        double dValue = Parse.toDouble(priceX);\r\n        this.priceX = String.valueOf(dValue);\r\n    }\r\n\r\n    public String getScalelimit() {\r\n        return this.scalelimit;\r\n    }\r\n\r\n    public void setScalelimit(String scalelimit) {\r\n        this.scalelimit = scalelimit;\r\n    }\r\n\r\n    public boolean isSpecial() {\r\n        return this.special == 1;\r\n    }\r\n\r\n    public int getSpecial() {\r\n        return this.special;\r\n    }\r\n\r\n    public void setSpecial(int special) {\r\n        this.special = special;\r\n    }\r\n\r\n    public void setSpecial(boolean special) {\r\n        this.special = special ? 1 : 0;\r\n    }\r\n\r\n    public String getTerritory() {\r\n        return this.territory;\r\n    }\r\n\r\n    public void setTerritory(String territory) {\r\n        this.territory = territory;\r\n    }\r\n\r\n    public String getValidFrom() {\r\n        return this.validFrom;\r\n    }\r\n\r\n    public void setValidFrom(String validFrom) {\r\n        this.validFrom = validFrom;\r\n    }\r\n\r\n    public LocalDate getValidFromAsLocalDate() {\r\n        LocalDate result = null;\r\n        if (validFrom.contains(\".\")) {\r\n            result = Parse.getLocalDate(validFrom, AstDateFormat.GERMAN);\r\n        } else if (validFrom.contains(\"-\")) {\r\n            result = Parse.getLocalDate(validFrom, AstDateFormat.ENGLISH);\r\n        } else {\r\n            result = Parse.getLocalDate(validFrom, AstDateFormat.FLAT);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public void setValidFromAsLocalDate(LocalDate validFrom) {\r\n        this.validFrom = Parse.formatDate(validFrom, AstDateFormat.ENGLISH);\r\n    }\r\n\r\n    public String getValidTo() {\r\n        return this.validTo;\r\n    }\r\n\r\n    public void setValidTo(String validTo) {\r\n        this.validTo = validTo;\r\n    }\r\n\r\n    public LocalDate getValidToAsLocalDate() {\r\n        LocalDate result = null;\r\n        if (validFrom.contains(\".\")) {\r\n            result = Parse.getLocalDate(validTo, AstDateFormat.GERMAN);\r\n        } else if (validFrom.contains(\"-\")) {\r\n            result = Parse.getLocalDate(validTo, AstDateFormat.ENGLISH);\r\n        } else {\r\n            result = Parse.getLocalDate(validTo, AstDateFormat.FLAT);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public void setValidToAsLocalDate(LocalDate validTo) {\r\n        this.validTo = Parse.formatDate(validTo, AstDateFormat.FLAT);\r\n    }\r\n\r\n    public AstFile getAssortment() {\r\n        return this.assortment;\r\n    }\r\n\r\n    public void setAssortment(AstFile assortment) {\r\n        this.assortment = assortment;\r\n    }\r\n\r\n    public String getProductName() {\r\n        return productName;\r\n    }\r\n\r\n    public void setProductName(String productName) {\r\n        this.productName = productName;\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\ArticleBase.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\ArticleBaseQueue.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport lombok.Data;\r\n\r\nimport javax.persistence.*;\r\nimport java.io.Serializable;\r\nimport java.time.LocalDateTime;\r\n\r\n\r\n/**\r\n * The persistent class for the AST_ARTICLE_BASE_QUEUE database table.\r\n */\r\n@Entity\r\n@Table(name = \"AST_ARTICLE_BASE_QUEUE\")\r\n@NamedQuery(name = \"ArticleBaseQueue.findAll\", query = \"SELECT a FROM ArticleBaseQueue a\")\r\npublic @Data class ArticleBaseQueue implements Serializable {\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name = \"ID\")\r\n    private int id;\r\n\r\n    @Column(name = \"TEMP_ID\")\r\n    private int tempId = 0;\r\n\r\n    @Column(name = \"[SESSION]\")\r\n    private String session = \"\";\r\n\r\n    @Column(name = \"TABLE_NAME\")\r\n    private String tableName = \"\";\r\n\r\n    @Column(name = \"VALID\")\r\n    private int valid = 0;\r\n\r\n    @Column(name = \"LOADON\")\r\n    private LocalDateTime loadOn;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"USER_ID\")\r\n    private User user = null;\r\n\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\ArticleBaseQueue.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\ArticleStatistic.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport lombok.Data;\r\n\r\nimport javax.persistence.*;\r\n\r\n@Entity\r\n@Table(name = \"AST_ARTICLE_STATISTIC\")\r\n@NamedQuery(name = \"ArticleStatistic.findAll\", query = \"SELECT a FROM ArticleStatistic a\")\r\n@Data\r\npublic class ArticleStatistic {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name = \"ID\")\r\n    private long id;\r\n\r\n    @Column(name = \"IDENTIFIER\")\r\n    private String identifier;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"TEMPLATE_ID\")\r\n    private TemplateData template;\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\ArticleStatistic.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\Assortment.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport javax.persistence.Entity;\r\n\r\n/**\r\n * The persistent class for the AST_ASSORTMENT database table.\r\n */\r\n@Entity\r\npublic class Assortment extends AstFile {\r\n    private static final long serialVersionUID = 1L;\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\Assortment.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\AssortmentDatafile.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport javax.persistence.*;\r\nimport java.io.Serializable;\r\n\r\n\r\n/**\r\n * The persistent class for the AST_ASSORTMENT_DATAFILE database table.\r\n */\r\n@Entity\r\n@Table(name = \"AST_ASSORTMENT_DATAFILE\")\r\n@NamedQuery(name = \"AssortmentDatafile.findAll\", query = \"SELECT a FROM AssortmentDatafile a\")\r\npublic class AssortmentDatafile implements Serializable {\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name = \"ID\")\r\n    private int id;\r\n\r\n    //bi-directional many-to-one association to Assortment\r\n    @ManyToOne\r\n    @JoinColumn(name = \"ASSORTMENT_ID\")\r\n    private Assortment assortment;\r\n\r\n    //bi-directional many-to-one association to Datafile\r\n    @ManyToOne\r\n    @JoinColumn(name = \"FILE_ID\")\r\n    private AstFile astFile;\r\n\r\n    public int getId() {\r\n        return this.id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public Assortment getAssortment() {\r\n        return this.assortment;\r\n    }\r\n\r\n    public void setAssortment(Assortment assortment) {\r\n        this.assortment = assortment;\r\n    }\r\n\r\n    public AstFile getAstFile() {\r\n        return this.astFile;\r\n    }\r\n\r\n    public void setAstFile(AstFile astFile) {\r\n        this.astFile = astFile;\r\n    }\r\n\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\AssortmentDatafile.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\AssortmentFilter.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport javax.persistence.*;\r\nimport java.io.Serializable;\r\nimport java.time.LocalDateTime;\r\n\r\n@Entity\r\n@Table(name = \"AST_ASSORTMENT_FILTER\")\r\n@NamedQuery(name = \"AssortmentFilter.findAll\", query = \"SELECT a FROM AssortmentFilter a\")\r\npublic class AssortmentFilter\r\n        implements\r\n        Serializable {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name = \"ID\")\r\n    private int id;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"ASSORTMENT_ID\")\r\n    private Assortment assortment;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"FILTER_ID\")\r\n    private Filter filter;\r\n\r\n    @Column(name = \"CREATEON\")\r\n    private LocalDateTime createOn = null;\r\n\r\n    @Column(name = \"DELETEON\")\r\n    private LocalDateTime deleteOn = null;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"CREATEBY\")\r\n    private User createBy = null;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"DELETEBY\")\r\n    private User deleteBy = null;\r\n\r\n    public Assortment getAssortment() {\r\n        return assortment;\r\n    }\r\n\r\n    public void setAssortment(Assortment assortment) {\r\n        this.assortment = assortment;\r\n    }\r\n\r\n    public Filter getFilter() {\r\n        return filter;\r\n    }\r\n\r\n    public void setFilter(Filter filter) {\r\n        this.filter = filter;\r\n    }\r\n\r\n    public User getCreateBy() {\r\n        return createBy;\r\n    }\r\n\r\n    public LocalDateTime getCreateOn() {\r\n        return createOn;\r\n    }\r\n\r\n    public void setCreateBy(User createBy) {\r\n        this.createBy = createBy;\r\n        this.createOn = LocalDateTime.now();\r\n    }\r\n\r\n    public User getDeleteBy() {\r\n        return deleteBy;\r\n    }\r\n\r\n    public LocalDateTime getDeleteOn() {\r\n        return deleteOn;\r\n    }\r\n\r\n    public void setDeleteBy(User deleteBy) {\r\n        this.deleteBy = deleteBy;\r\n        this.deleteOn = LocalDateTime.now();\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\AssortmentFilter.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\AstFile.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport lombok.Data;\r\n\r\nimport javax.persistence.*;\r\nimport java.io.Serializable;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Objects;\r\n\r\n\r\n@Entity\r\n@Table(name = \"AST_FILE\")\r\n@NamedQuery(name = \"AstFile.findAll\", query = \"SELECT a FROM AstFile a\")\r\npublic @Data class AstFile implements\r\n        Serializable {\r\n\r\n    private static final long serialVersionUID = -8435294189850657231L;\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name = \"ID\")\r\n    private int id;\r\n\r\n    @Column(name = \"NAME\")\r\n    private String name = \"\";\r\n\r\n    @Column(name = \"UPDATEON\")\r\n    private LocalDateTime updateOn = null;\r\n\r\n    @Column(name = \"CREATEON\")\r\n    private LocalDateTime createOn = null;\r\n\r\n    @Column(name = \"DELETEON\")\r\n    private LocalDateTime deleteOn = null;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"CREATEBY\")\r\n    private User createBy = null;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"UPDATEBY\")\r\n    private User updateBy = null;\r\n\r\n    @OneToOne\r\n    @JoinColumn(name = \"DELETEBY\")\r\n    private User deleteBy = null;\r\n\r\n    // bi-directional many-to-one association to Project_Role\r\n    @ManyToOne\r\n    @JoinColumn(name = \"PROJECT_ROLE_ID\")\r\n    private ProjectRole projectRole;\r\n\r\n    /* Other Funktions */\r\n\r\n    public void setDate(User user) {\r\n        if (Objects.isNull(createBy)) {\r\n            createBy = user;\r\n            createOn = LocalDateTime.now();\r\n        }\r\n        updateBy = user;\r\n        updateOn = LocalDateTime.now();\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\AstFile.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\CustomerFile.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport javax.persistence.Entity;\r\n\r\n@Entity\r\npublic class CustomerFile extends AstFile {\r\n    private static final long serialVersionUID = 8696377200386317248L;\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\CustomerFile.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\CustomerFilter.java =====\n```\npackage com.hom.ebmw.jpa.model;\r\n\r\nimport com.hom.ebmw.utilities.enums.ObjectType;\r\nimport lombok.Data;\r\n\r\nimport javax.persistence.*;\r\nimport java.io.Serializable;\r\nimport java.time.LocalDateTime;\r\n\r\n@Entity\r\n@Table(name = \"AST_CUSTOMER_FILTER\")\r\n@NamedQuery(name = \"CustomerFilter.findAll\", query = \"SELECT a FROM CustomerFilter a\")\r\npublic @Data class CustomerFilter implements Serializable {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    @Column(name = \"ID\")\r\n    private long id;\r\n\r\n    @Column(name = \"CUSTOMER_NR\")\r\n    private String customerNr;\r\n\r\n    @Column(name = \"TYPE\")\r\n    private String type;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"FILTER_ID\")\r\n    private Filter filter;\r\n\r\n    @Column(name = \"ACTIVE\")\r\n    private boolean active;\r\n\r\n    @Column(name = \"DELETE_ON\")\r\n    private LocalDateTime deleteOn;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"ROLE_ID\")\r\n    private Role role;\r\n\r\n    @ManyToOne\r\n    @JoinColumn(name = \"DELETE_BY\")\r\n    private User deleteBy;\r\n\r\n    public void setType(ObjectType type) {\r\n        this.type = type.name();\r\n    }\r\n\r\n    public ObjectType getObjectType() {\r\n        return ObjectType.valueOf(type);\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\model\\CustomerFilter.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-AJ69FnANnP2WcjhSAA1IdPO2Eq7Nu10J",
    "created" : 1762170823,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"multiple (FilterBaseUpdateRepository, LocalCustomerCustomRepository, SettingCustomRepository, ZinfoCustomRepository, ArticleBase)\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"SQL Injection risk due to string concatenation of user-controlled parameters\",\n      \"justification\": \"Methods like importArticleBasicAssortment, setArticleCountryLock, findByCustomerNr, getZinfos, and many others embed raw parameters (e.g., pimAssortment, customerNr, territory, type) directly into SQL strings, allowing crafted input to alter queries.\",\n      \"action\": \"Replace concatenated SQL with prepared statements or JdbcTemplate query methods using placeholders; add unit tests verifying that malicious input is escaped and does not modify query structure.\",\n      \"source\": \"FilterBaseUpdateRepository.importArticleBasicAssortment, FilterBaseUpdateRepository.setArticleCountryLock, LocalCustomerCustomRepository.findByCustomerNr, ZinfoCustomRepository.getZinfos\",\n      \"component\": \"database-access\",\n      \"impact_scope\": \"security-critical, production-relevant\",\n      \"relations\": null,\n      \"evidence\": \"String sql = \\\"... WHERE ASSORTMENT_NAME = '\\\" + pimAssortment + \\\"'\\\"\"\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Unescaped values in SQL strings can break queries and cause data corruption\",\n      \"justification\": \"Values like comments, customer IDs, or file names may contain quotes or special characters, leading to syntax errors or unexpected behavior when concatenated without escaping.\",\n      \"action\": \"Sanitize inputs using parameter binding; use JdbcTemplate.update with ? placeholders; add integration tests with edge-case characters (e.g., apostrophes).\",\n      \"source\": \"FilterBaseUpdateRepository.setArticleInPIM, SettingCustomRepository.remove, ZinfoCustomRepository.insertZinfo\",\n      \"component\": \"database-access\",\n      \"impact_scope\": \"production-relevant\",\n      \"relations\": \"Duplicate of issue 1\",\n      \"evidence\": \"COMMENT = CONCAT(COMMENT,'\" + DB_DELIMITER + FilterType.NOTINPIM + \"')\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Potential NullPointerException when table name lookup fails\",\n      \"justification\": \"articleTableName(Context ctx, String name) returns tabSession.get(name) which may be null; subsequent string concatenation causes NPE at runtime for unknown tables.\",\n      \"action\": \"Validate that the returned table name is not null; throw a clear IllegalArgumentException with context; add unit tests for missing session entries.\",\n      \"source\": \"FilterBaseUpdateRepository.articleTableName(Context ctx, String name)\",\n      \"component\": \"routing\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE); return tabSession.get(name);\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Sideeffects in getter method getComment() of ArticleBase\",\n      \"justification\": \"Method modifies the comment field (deduplication and ordering) each time it's called, breaking immutability expectations and causing threadsafety issues.\",\n      \"action\": \"Refactor to keep getter pure; perform comment normalization in a dedicated setter or service method; add tests confirming getter does not alter object state.\",\n      \"source\": \"ArticleBase.getComment()\",\n      \"component\": \"model\",\n      \"impact_scope\": \"low\",\n      \"relations\": null,\n      \"evidence\": \"comment = \\\"\\\"; for (String item : commentSet) { comment += ... }\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Missing null checks for date strings in ArticleBase date parsing methods\",\n      \"justification\": \"Methods getValidFromAsLocalDate() and getValidToAsLocalDate() call contains() on potentially null strings, leading to NPE if fields are unset.\",\n      \"action\": \"Add null checks before parsing; return Optional<LocalDate> or null; include unit tests for null/empty date fields.\",\n      \"source\": \"ArticleBase.getValidFromAsLocalDate(), ArticleBase.getValidToAsLocalDate()\",\n      \"component\": \"model\",\n      \"impact_scope\": \"low\",\n      \"relations\": null,\n      \"evidence\": \"if (validFrom.contains(\\\".\\\")) { ... }\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Transactional annotation on readonly methods increases overhead\",\n      \"justification\": \"Methods like findAll() in LocalCustomerCustomRepository are marked @Transactional but only perform reads, causing unnecessary transaction management.\",\n      \"action\": \"Remove @Transactional from pure read methods or set readOnly=true; verify with performance benchmarks.\",\n      \"source\": \"LocalCustomerCustomRepository.findAll()\",\n      \"component\": \"performance\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": \"@Transactional public List<LocalCustomer> findAll()\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Hardcoded SQL fragments reduce maintainability and increase risk of syntax errors\",\n      \"justification\": \"Repeated string concatenations spread across many methods make future schema changes errorprone.\",\n      \"action\": \"Extract SQL statements to constants or external resource files; use a query builder library; add integration tests for each query.\",\n      \"source\": \"Various methods in FilterBaseUpdateRepository and ZinfoCustomRepository\",\n      \"component\": \"architecture\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": \"String sqlParent = \\\"UPDATE \\\" + articleTableName(ctx) + \\\" SET ...\\\"\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Lack of input validation for enumeration parameters (e.g., FilterType, FilterStatus)\",\n      \"justification\": \"Methods accept enums but also raw strings (direction) which can be invalid, leading to malformed queries.\",\n      \"action\": \"Validate direction against allowed values (ADD, REMOVE) before building SQL; reject or default otherwise; add unit tests for invalid values.\",\n      \"source\": \"FilterBaseUpdateRepository.articleByFilter\",\n      \"component\": \"validation\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": \"if (direction.equals(ADD)) { ... } else if (direction.equals(REMOVE)) { ... }\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Potential resource leak: ResultSet not closed explicitly in custom RowMappers\",\n      \"justification\": \"While Spring's JdbcTemplate handles closing, custom RowMapper implementations should ensure resources are released in case of misuse.\",\n      \"action\": \"Document that JdbcTemplate manages resources; optionally wrap mapping logic in tryfinally for clarity; add tests confirming no leaks under high load.\",\n      \"source\": \"LocalCustomerCustomRepository.LocalCustomerRowMapper, ZinfoCustomRepository.ZinfoRowMapper\",\n      \"component\": \"resource-management\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": \"public LocalCustomer mapRow(ResultSet rs, int rowNum) throws SQLException { ... }\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Magic strings for SQL delimiters and identifiers scattered in code\",\n      \"justification\": \"Using literals like \\\"'\\\" or \\\"#\\\" directly makes it hard to change conventions and can introduce bugs.\",\n      \"action\": \"Define constants for delimiters and reuse; centralize in a utility class; add tests to ensure consistency.\",\n      \"source\": \"ArticleBase.getComment(), FilterBaseUpdateRepository.setArticleInPIM, ZinfoCustomRepository.insertZinfo\",\n      \"component\": \"maintainability\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": \"COMMENT = CONCAT(COMMENT,'\" + DB_DELIMITER + FilterType.NOTINPIM + \"')\"\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Replace all raw SQL string concatenations with prepared statements / parameter binding to eliminate SQL injection.\",\n      \"Add nullchecks and proper validation for sessionderived table names and date fields.\",\n      \"Refactor ArticleBase.getComment() to be sideeffect free and ensure thread safety.\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to output JSON for each file/chunk? The instruction: \"Du analysierst jeweils einen Code-Chunk.\" Provide JSON with file path and issues. Likely one JSON per file. Could combine all? Probably produce separate JSON objects? But spec expects single JSON object. Might need to output for each file sequentially? Could create array? Not allowed. Must be single JSON object. Probably they expect one output per file, but we have many files. However instruction: \"Du analysierst jeweils einen Code-Chunk.\" Might mean each chunk input separate. Here multiple files given; perhaps we need to output one JSON per file? But rule 1: \"Antworte immer als ein einziges JSON-Objekt\". So we need combine into one JSON with file field maybe an identifier? Might need to output separate objects? Not allowed. Could create array of objects under \"files\"? Not in schema. Schema only has \"file\". So likely they expect separate calls per file. But they've given many files together; maybe we should output combined issues for all? Could set file to \"multiple\" but not ideal. Could produce one JSON per file but they'd violate rule.\n\nBetter to treat each file as separate chunk and produce separate JSONs, but they ask only one JSON. Hmm.\n\nMaybe we choose the most critical file? But they provided many files; maybe they want analysis of each file, but we can only output one JSON; maybe we can embed multiple file analyses in \"issues\" with source indicating file? Not ideal.\n\nGiven constraints, perhaps we output summary for the main repository class (FilterBaseUpdateRepository) only, as it's the most complex. But they included other repository classes. Could we output multiple issues across files, each issue's source includes file name, but file field can be generic like \"multiple\". That might satisfy.\n\nLet's produce JSON with file: \"multiple\" and list issues (max 10). Need to prioritize biggest issues across all files. Identify:\n\n1. SQL injection risk: many methods concatenate parameters directly into SQL (e.g., importArticleBasicAssortment, setArticleCountryLock, findByCustomerNr in LocalCustomerCustomRepository, etc.) => High.\n\n2. Use of string concatenation for comments could lead to malformed SQL if values contain quotes. Need proper escaping or prepared statements. => High.\n\n3. Potential NPE: articleTableName(ctx, name) returns map.get(name) which may be null, then used in SQL -> NullPointer. => Med.\n\n4. Transactional annotations on methods that only read (findAll) may cause unnecessary transaction overhead. Not critical.\n\n5. No input validation for parameters like customerNr, pimAssortment, territory -> security.\n\n6. In getArticleFilter, using direction string constants that could be misused; but okay.\n\n7. In ArticleBase.getComment, modifies field on getter leading to side effects, not thread-safe. => Med.\n\n8. In ArticleBase.getValidFromAsLocalDate uses validFrom.contains but not null check. => Low.\n\n9. In SettingCustomRepository.remove uses string concatenation for id (int) fine but no permission check.\n\n10. In ZinfoCustomRepository.getZinfos, building SQL with type and locale without escaping; also potential injection.\n\nLet's craft issues list of 10 with severity.\n\nProvide action suggestions.\n\nProvide summary.\n\nLet's craft JSON."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 2460,
      "prompt_tokens" : 28894,
      "total_tokens" : 31354
    },
    "timings" : {
      "cache_n" : 62,
      "prompt_n" : 28832,
      "prompt_ms" : 21615.861,
      "prompt_per_token_ms" : 0.7497177094894562,
      "prompt_per_second" : 1333.835372090892,
      "predicted_n" : 2460,
      "predicted_ms" : 30130.6,
      "predicted_per_token_ms" : 12.248211382113821,
      "predicted_per_second" : 81.64457395471713
    }
  }
}