{
  "timestamp" : "2025-11-03T12:51:52.4466676",
  "index" : 3,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ArticleBaseGetRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.KatalogVersion;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.FileParam;\r\nimport com.hom.ebmw.utilities.enums.FilterStatus;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n@Repository\r\npublic class ArticleBaseGetRepository {\r\n\r\n    private final JdbcTemplate dbService;\r\n\r\n    /**\r\n     * The ArticleBaseGetRepository function is a function that returns the article base of an article.\r\n     *\r\n     * @param JdbcTemplate dbService Connect to the database\r\n     * @return A list of articles\r\n     */\r\n    public ArticleBaseGetRepository(JdbcTemplate dbService) {\r\n        this.dbService = dbService;\r\n    }\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the article table that is currently active in\r\n     * the user session. The function first gets a map from the user session, which contains all of\r\n     * our active tables. Then it gets a map from that map, which contains only one entry: our main\r\n     * table (the one we're interested in). Finally, it returns this main table's name as a string.\r\n     *\r\n     * @param Context ctx Get the current session\r\n     * @return The name of the main table for the active article\r\n     */\r\n    private String articleTableName(Context ctx) {\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        return tabSession.get(Table.MAIN);\r\n    }\r\n\r\n    /**\r\n     * The getStartDate function returns the start date of the current assortment.\r\n     *\r\n     * @param Context ctx Get the current assortment and version\r\n     * @return The start date of a specific assortment\r\n     */\r\n    private LocalDate getStartDate(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        KatalogVersion version = CompUtils.getParameter(ctx, FileParam.KATALOG_VERSION, assortment);\r\n        return version.getValidFrom();\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterialInBasicAssortment function returns a list of articles that are assigned to the basic assortment.\r\n     *\r\n     * @param Context ctx Get the user language\r\n     * @param Locale  locale Get the language of the user\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleAssignedMaterialInBasicAssortment(Context ctx, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \"Select ARTICLE_NR, DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"where BASICASSORTMENT = 1 AND b.LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                + \"AND a.FOUND_ARTICLE_STATUS = 0 \" + \" order by 1\";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterialNotInBasicAssortment function returns a list of articles that are not in the basic assortment,\r\n     * but have an assigned material. The function takes two parameters: a Context object and a String label. The Context object is used to\r\n     * get the user's language from the context, which is then used to query for article descriptions in that language. The String label\r\n     * parameter specifies what type of assigned material we want to search for (e.g., &quot;COT&quot; or &quot;VIS&quot;). This function uses SQL queries\r\n     * with inner joins on multiple tables (AST_PIM_FILTER_ARTICLE_ASSIGNED_\r\n     *\r\n     * @param Context ctx Get the user language\r\n     * @param String  label Filter the results\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articles that are not in the basic assortment\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleAssignedMaterialNotInBasicAssortment(Context ctx, String label, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \"Select DISTINCT a.ARTICLE_NR, c.DESCRIPTION FROM \" + \"(Select CASE WHEN a.VALID_FROM = '\"\r\n                + getStartDate(ctx).toString() + \"' THEN SUBSTRING(NEXT_ASSIGNED_MATERIAL, 1,3) \"\r\n                + \"WHEN a.VALID_FROM < '\" + getStartDate(ctx).toString()\r\n                + \"' THEN SUBSTRING(NEXT_ASSIGNED_MATERIAL, 1,3) \"\r\n                + \"ELSE CURRENT_ASSIGNED_MATERIAL END AS LABEL, a.ARTICLE_REVISION_ID, b.ARTICLE_NR \"\r\n                + \"from AST_PIM_FILTER_ARTICLE_ASSIGNED_MATERIAL a INNER JOIN \" + articleTableName(ctx) + \" b \"\r\n                + \"ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID AND b.FOUND_ARTICLE_STATUS = 0 AND BASICASSORTMENT = 0) a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION c ON c.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID AND LABEL = '\"\r\n                + label + \"' AND LANGUAGE_ID = \" + lang.getKey();\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterial function returns a list of ArticleBase objects that have the specified label.\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param String  label Get the article label\r\n     * @param Locale  locale Determine the language of the article\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleAssignedMaterial(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomColumn(ctx, label, \"ASSIGNED_MATERIAL\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleInfoType function returns a list of ArticleBase objects that have the same INFO_TYPE value as the label parameter.\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param String  label Identify the article type\r\n     * @param Locale  locale Determine the language of the article\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleInfoType(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomColumn(ctx, label, \"INFO_TYPE\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleClass function returns a list of ArticleBase objects that have the same class as the label parameter.\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param String  label Identify the article type\r\n     * @param Locale  locale Get the language of the article\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleClass(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomColumn(ctx, label, \"CLASS\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleCustomColumn function is used to retrieve a list of articles that have the same value for a given custom column.\r\n     *\r\n     * @param Context ctx Get the user's language\r\n     * @param String  label Filter the articles\r\n     * @param String  column Determine which column to query from the database\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    public List<ArticleBase> getArticleCustomColumn(Context ctx, String label, String column, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \"Select ARTICLE_NR, DESCRIPTION \" + \"FROM (Select CASE WHEN NEXT_\" + column + \" IS NOT NULL \"\r\n                + \"THEN SUBSTRING(NEXT_\" + column + \", 1,3) \" + \"ELSE CURRENT_\" + column + \" END AS LABEL, \"\r\n                + \"ARTICLE_NR, DESCRIPTION \" + \"from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_\" + column + \" c ON c.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID WHERE b.LANGUAGE_ID = \" + lang.getKey() + \" AND a.FOUND_ARTICLE_STATUS = 0 \"\r\n                + \"AND (c.VALID_FROM < '\" + getStartDate(ctx).toString() + \"' OR c.VALID_FROM IS NULL) ) temp \"\r\n                + \"WHERE LABEL = '\" + label + \"' \" + \"order by 1 \";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleCustomFilter function is used to retrieve a list of articles that are associated with the specified filter.\r\n     *\r\n     * @param Context ctx Get the user's language\r\n     * @param String  label Filter the results\r\n     * @param String  filter Build the sql query\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    public List<ArticleBase> getArticleCustomFilter(Context ctx, String label, String filter, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \"Select ARTICLE_NR, DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID AND a.FOUND_ARTICLE_STATUS = 0 \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_\" + filter + \" c ON c.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID WHERE c.LABEL = '\" + label + \"' AND b.LANGUAGE_ID = \" + lang.getKey() + \" order by 1\";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleS3CatalogFilter function is used to retrieve the articles that are associated with a specific assortment.\r\n     * The function takes in two parameters: a Context object and an assortment name. It then queries the database for all of\r\n     * articles that have been assigned to this particular assortment, and returns them as a list of ArticleBase objects.\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @param String  label Filter the articles by label\r\n     * @param Locale  locale Get the language of the user\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleS3CatalogFilter(Context ctx, String label, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String assortmentName = ctx.getUserSession().get(Params.ACTIVE_S3_CATALOG);\r\n\r\n        String sqlParent = \"Select a.ARTICLE_NR, c.DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_BRANDS b \"\r\n                + \"ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION c \"\r\n                + \"ON a.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID \"\r\n                + \"WHERE SPECIAL = 1 AND LABEL = '\" + label + \"' AND c.LANGUAGE_ID = \" + lang.getKey()\r\n                + \" ORDER BY 1 \";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleCustomFilterWithTerritory function is used to retrieve a list of articles that are associated with the specified filter and label.\r\n     *\r\n     * @param Context ctx Get the current user's language\r\n     * @param String  label Filter the results from the database\r\n     * @param String  filter Create a table name\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    public List<ArticleBase> getArticleCustomFilterWithTerritory(Context ctx, String label, String filter,\r\n                                                                 Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \"Select ARTICLE_NR, DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID AND a.FOUND_ARTICLE_STATUS = 0 \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_\" + filter + \" c ON c.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID WHERE c.LABEL = '\" + label + \"' AND c.TERRITORY = 'DE'  AND b.LANGUAGE_ID = \" + lang.getKey()\r\n                + \" order by 1\";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleBrands function returns a list of articles that are associated with the label &quot;BRANDS&quot;.\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param String  label Filter the articles based on their label\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articles\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleBrands(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomFilter(ctx, label, \"BRANDS\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleGHSCode function returns a list of ArticleBase objects that have the same GHS_CODE as the label parameter.\r\n     *\r\n     * @param Context ctx Get the user's locale\r\n     * @param String  label Filter the articles\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articles that have the same ghs code\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleGHSCode(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomFilter(ctx, label, \"GHS_CODE\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleConfig function returns a list of articles that are tagged with the label &quot;CONFIG&quot;\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param String  label Filter the articles by label\r\n     * @param Locale  locale Get the locale of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleConfig(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomFilter(ctx, label, \"CONFIG\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleIntraStat function returns a list of ArticleBase objects that have the label &quot;INTRA_STAT&quot;\r\n     *\r\n     * @param Context ctx Get the current context of the application\r\n     * @param String  label Filter the articles by label\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleIntraStat(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomFilterWithTerritory(ctx, label, \"INTRA_STAT\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleNotFree function returns a list of articles that are not free.\r\n     *\r\n     * @param Context ctx Get the current user's context\r\n     * @param String  label Filter the articles by label\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articles that are not free\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleNotFree(Context ctx, String label, Locale locale) {\r\n        return getArticleCustomFilterWithTerritory(ctx, label, \"NOT_FREE\", locale);\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureClassification function is used to get the article structure classification.\r\n     *\r\n     * @param Context ctx Get the user's language\r\n     * @param String  structureGroupID Get the article structure group id\r\n     * @param String  structureName Get the article structure classification\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleStructureClassification(Context ctx, String structureGroupID,\r\n                                                               String structureName, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \" Select d.ARTICLE_NR, e.DESCRIPTION \" + \" FROM AST_PIM_FILTER_STRUCTURE_CLASSIFICATION a \"\r\n                + \" INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP c ON c.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID AND c.STRUCTURE_ID = a.STRUCTURE_ID\"\r\n                + \" INNER JOIN \" + articleTableName(ctx)\r\n                + \" d ON d.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID AND d.FOUND_ARTICLE_STATUS = 0 \"\r\n                + \" INNER JOIN AST_PIM_ARTICLE_DESCRIPTION e ON e.ARTICLE_REVISION_ID = d.ARTICLE_REVISION_ID \"\r\n                + \" WHERE a.STRUCTURE_GROUP_ID = \" + structureGroupID + \" AND a.STRUCTURE_NAME = '\" + structureName\r\n                + \"' AND e.LANGUAGE_ID = \" + lang.getKey() + \" \" + \" order by 1\";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructure function is used to retrieve the article structure of a given filter.\r\n     * The function takes in two parameters: a context and an identifier.\r\n     * The context parameter is used to determine which database table should be queried for the data, as there are multiple databases that can be accessed by this application.\r\n     * The identifier parameter is used to determine which filter's article structure should be retrieved from the database table specified by the context parameter.\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param String  identifier Get the structure group id\r\n     * @param Locale  locale Get the language of the user\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleStructure(Context ctx, String identifier, Locale locale) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n\r\n        int structureGroupID = Parse.toInt(identifier.split(\":\")[0]);\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \" Select Distinct d.ARTICLE_NR, e.DESCRIPTION \" + \" FROM AST_PIM_FILTER_STRUCTURE_CLASSIFICATION a \"\r\n                + \" INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP c ON c.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID AND c.STRUCTURE_ID = a.STRUCTURE_ID\"\r\n                + \" INNER JOIN \" + articleTableName(ctx)\r\n                + \" d ON d.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID AND d.FOUND_ARTICLE_STATUS = 0 \"\r\n                + \" INNER JOIN AST_PIM_ARTICLE_DESCRIPTION e ON e.ARTICLE_REVISION_ID = d.ARTICLE_REVISION_ID \"\r\n                + \" INNER JOIN AST_FILTERBASE f ON f.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID AND f.[DELETE] = 0 \"\r\n                + \" INNER JOIN AST_PIM_FILTER_STRUCTURE_ROOT s ON s.Name = a.STRUCTURE_NAME \"\r\n                + \" WHERE f.IDENTIFIER LIKE '\" + identifier + \"%' AND s.StructureGroupID = \" + structureGroupID\r\n                + \" AND e.LANGUAGE_ID = \" + lang.getKey() + \" \" + \" order by 1\";\r\n\r\n        result.addAll(dbService.query(sqlParent, new ArticleBaseRowMapper()));\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * The getArticleIndividual function is used to retrieve a list of articles that are associated with the filterbase.\r\n     * The function first checks if the filterbase exists, and if it does not exist, then it returns an empty list.\r\n     * If the filterbase does exist, then we get all of its attributes and store them in variables. We also get\r\n     * a language object from CompUtils using our context object ctx as input for this function call. Then we create\r\n     * an SQL query string called sqlSelect which will be used to select data from our database tables based on certain conditions:\r\n     * 1) Selecting article\r\n     *\r\n     * @param Context    ctx Get the database connection\r\n     * @param Filterbase filterbase Get the filterbase id\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> getArticleIndividual(Context ctx, Filterbase filterbase) {\r\n        List<ArticleBase> result = new ArrayList<>();\r\n        String sqlSelect = \"\";\r\n\r\n        Optional<Filterbase> optFilter = ctx.getServices().getFilterBaseService().findById(filterbase.getId());\r\n        if (optFilter.isPresent()) {\r\n            filterbase = optFilter.get();\r\n        }\r\n\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        sqlSelect = \"Select a.ARTICLE_NR, b.DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"INNER JOIN AST_FILTERBASE c ON a.ARTICLE_NR = c.IDENTIFIER AND c.[DELETE] = 0 \" + \"WHERE c.PARENT_ID = \"\r\n                + filterbase.getId() + \" AND b.LANGUAGE_ID = \" + lang.getKey();\r\n\r\n        result.addAll(ctx.getServices().getTemplate().query(sqlSelect, new ArticleBaseRowMapper()));\r\n\r\n        if (result.isEmpty()) {\r\n            if (filterbase.getIdentifier().contains(\"PRODUCT_NAME\")) {\r\n                sqlSelect = \"Select a.ARTICLE_NR, d.DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                        + \"INNER JOIN AST_PIM_ARTICLE_PRODUCT_NAME b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                        + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION d ON a.ARTICLE_REVISION_ID = d.ARTICLE_REVISION_ID \"\r\n                        + \"WHERE b.LANGUAGE_ID = \" + lang.getKey() + \" AND \"\r\n                        + filterbase.getIdentifier().replace(\"PRODUCT_NAME\", \"UPPER(PRODUCT_NAME)\")\r\n                        + \" AND a.FOUND_ARTICLE_STATUS IN (\" + FilterStatus.DEFAULT.getId() + \",\"\r\n                        + FilterStatus.REMOVEBYFILTER.getId() + \") \" + \" AND d.LANGUAGE_ID = \" + lang.getKey();\r\n            } else if (!filterbase.getIdentifier().equals(filterbase.getLabel())) {\r\n                sqlSelect = \"Select a.ARTICLE_NR, b.DESCRIPTION from \" + articleTableName(ctx) + \" a \"\r\n                        + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                        + \"WHERE \" + (filterbase.getIdentifier().equals(\"INDIVIDUAL\") ? \"a.COMMENT LIKE '%INDIVIDUAL%'\" : filterbase.getIdentifier()) + \" AND FOUND_ARTICLE_STATUS IN (\"\r\n                        + FilterStatus.DEFAULT.getId() + \",\" + FilterStatus.REMOVEBYFILTER.getId() + \")  AND b.LANGUAGE_ID = \" + lang.getKey();\r\n            }\r\n            result.addAll(ctx.getServices().getTemplate().query(sqlSelect, new ArticleBaseRowMapper()));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private class ArticleBaseRowMapper implements RowMapper<ArticleBase> {\r\n\r\n        @Override\r\n        public ArticleBase mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            ArticleBase base = new ArticleBase();\r\n\r\n            base.setArticleNr(rs.getString(\"ARTICLE_NR\"));\r\n            base.setComment(rs.getString(\"DESCRIPTION\"));\r\n\r\n            return base;\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ArticleBaseGetRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ArticleBaseRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.configuration.security.SessionUtils;\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.service.EnumerationService;\r\nimport com.hom.ebmw.jpa.dao.AstFileDAO;\r\nimport com.hom.ebmw.jpa.dao.UserDAO;\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.AstFile;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.InternalUtils;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.FilterStatus;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.*;\r\n\r\nimport static com.hom.ebmw.utilities.constans.ASTConst.DB_DELIMITER;\r\n\r\n@Repository\r\n@Slf4j\r\npublic class ArticleBaseRepository {\r\n\r\n    private final String UPDATE = DB_DELIMITER;\r\n\r\n    private final AstFileDAO astFileService;\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    private final EnumerationService enumServices;\r\n\r\n    private final UserDAO userSession;\r\n\r\n    /**\r\n     * The ArticleBaseRepository function is a constructor that initializes the ArticleBaseRepository class.\r\n     *\r\n     * @param AstFileDAO         astFileService Call the getastfilebyname method in astfiledao\r\n     * @param JdbcTemplate       dbServices Access the database\r\n     * @param EnumerationService enumServices Call the getenumvalue function in enumerationservice\r\n     * @param UserDAO            userSession Get the user's session information\r\n     * @return This\r\n     */\r\n    public ArticleBaseRepository(AstFileDAO astFileService, JdbcTemplate dbServices, EnumerationService enumServices, UserDAO userSession) {\r\n        this.astFileService = astFileService;\r\n        this.dbServices = dbServices;\r\n        this.enumServices = enumServices;\r\n        this.userSession = userSession;\r\n    }\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the table that contains\r\n     * article data for a given feed.  The function takes two arguments:\r\n     *\r\n     * @param Context ctx Get the application context\r\n     * @return The name of the table that contains articles\r\n     */\r\n    private String articleTableName(Context ctx) {\r\n        return articleTableName(ctx, Table.MAIN);\r\n    }\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the table that contains\r\n     * articles for a given article type.  The function first checks to see if there is an entry in\r\n     * the user session for this table name.  If so, it returns that value; otherwise, it looks up\r\n     * and stores in the user session a new value from either (a) a default setting or (b) an override\r\n     * setting stored in another database table.  This allows us to change which tables are used by each article type without having to recompile any code.   It also allows us to have different settings for different users or groups of users,\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @param String  type Determine which table to return\r\n     * @return The name of the table that contains the articles\r\n     */\r\n    private String articleTableName(Context ctx, String type) {\r\n        String result = \"\";\r\n        try {\r\n            Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n            result = tabSession.get(type);\r\n        } catch (Exception e) {\r\n            result = \"\";\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * The truncateArticleTable function is used to truncate the article table for a given site.\r\n     *\r\n     * @param int id Specify which database to truncate\r\n     */\r\n    @Transactional\r\n    public void truncateArticleTable(int id) {\r\n        dbServices.execute(\"TRUNCATE TABLE AST_ARTICLE_BASE_\" + (id < 10 ? \"0\" + id : id));\r\n    }\r\n\r\n    /**\r\n     * The truncateArticleTable function is used to truncate the article table.\r\n     *\r\n     * @param Context ctx Get the active article base table from the user session\r\n     */\r\n    @Transactional\r\n    public void truncateArticleTable(Context ctx) {\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        if (Objects.nonNull(tabSession))\r\n            tabSession.forEach((type, table) -> {\r\n                if (Objects.nonNull(table) && !table.isEmpty()) {\r\n                    truncateArticleTable(table);\r\n                }\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     * The getTempTableAssortment function is used to retrieve the assortment associated with a temporary table.\r\n     *\r\n     * @param String table Get the assortmentid from a table\r\n     * @return The assortment of the table\r\n     */\r\n    @Transactional\r\n    public AstFile getTempTableAssortment(String table) {\r\n        AstFile result = null;\r\n        Integer assortmentId = dbServices.queryForObject(\"Select DISTINCT ASSORTMENT_ID FROM \" + table, Integer.class);\r\n\r\n        if (Objects.nonNull(assortmentId) && assortmentId != 0) {\r\n            Optional<AstFile> optAssortment = astFileService.findById(assortmentId);\r\n            if (optAssortment.isPresent()) {\r\n                result = optAssortment.get();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The truncateArticleTable function is used to truncate the article table.\r\n     *\r\n     * @param String table Specify which table to truncate\r\n     */\r\n    @Transactional\r\n    public void truncateArticleTable(String table) {\r\n        dbServices.execute(\"TRUNCATE TABLE \" + table);\r\n    }\r\n\r\n    /**\r\n     * The findFirst function is used to find the first article in a given assortment.\r\n     *\r\n     * @param Context ctx Get the active assortment from the user session\r\n     * @return An optional\r\n     */\r\n    @Transactional\r\n    public Optional<ArticleBase> findFirst(Context ctx) {\r\n        Optional<ArticleBase> result = Optional.empty();\r\n\r\n        String sqlSelect = \"SELECT TOP 1 \" + \"[ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],\"\r\n                + \"[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID] FROM [dbo].[\" + (ctx) + \"]\";\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        List<ArticleBase> articles = dbServices.query(sqlSelect, new ArticleBaseRowMapper(assortment));\r\n        if (!articles.isEmpty()) {\r\n            result = Optional.of(articles.get(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The insertAll function takes a list of ArticleBase objects and inserts them into the database.\r\n     * It does this by splitting the list into smaller lists, each with 1000 elements. This is done to avoid\r\n     * memory issues that can occur when inserting large amounts of data at once. The function then calls insertIntoTable on each sublist, which actually performs the insertion operation using JDBCTemplate's batchUpdate method.\r\n     *\r\n     * @param Context                 ctx Get the current session\r\n     * @param List&lt;ArticleBase&gt; articles Pass the list of articles to be inserted into the database\r\n     */\r\n    @Transactional\r\n    public void insertAll(Context ctx, List<ArticleBase> articles) {\r\n        int partSize = 1000;\r\n        List<List<ArticleBase>> splitList = InternalUtils.listSplitter(articles, partSize);\r\n        splitList.forEach(split -> {\r\n            insertIntoTable(ctx, split);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The updateAll function takes a list of ArticleBase objects and updates the database with them.\r\n     * It does this by splitting the list into parts of size 1000, then updating each part in turn.\r\n     *\r\n     * @param Context                 ctx Get the current user's id\r\n     * @param List&lt;ArticleBase&gt; articles Pass in the list of articles to be updated\r\n     */\r\n    @Transactional\r\n    public void updateAll(Context ctx, List<ArticleBase> articles) {\r\n        int partSize = 1000;\r\n        List<List<ArticleBase>> splitList = InternalUtils.listSplitter(articles, partSize);\r\n        splitList.forEach(split -> {\r\n            updateList(ctx, split);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The save function will either insert or update an article in the database.\r\n     * If the article is new, it will be inserted into the database.\r\n     * If it already exists, then its information will be updated in the database.\r\n     *\r\n     * @param Context     ctx Determine the table name to use\r\n     * @param ArticleBase article Pass the article to be saved\r\n     */\r\n    @Transactional\r\n    public void save(Context ctx, ArticleBase article) {\r\n        String sqlSelect = \"Select COUNT(ID) FROM \" + articleTableName(ctx) + \"WHERE ID = \" + article.getId();\r\n\r\n        Integer iCount = dbServices.queryForObject(sqlSelect, Integer.class);\r\n        if (Objects.isNull(iCount) || iCount < 0) {\r\n            insert(ctx, article);\r\n        } else {\r\n            update(ctx, article);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The insert function is used to insert a new article into the database.\r\n     *\r\n     * @param Context     ctx Determine which table to insert into\r\n     * @param ArticleBase article Get the values from the object to be inserted into the database\r\n     */\r\n    @Transactional\r\n    private void insert(Context ctx, ArticleBase article) {\r\n        String sqlInsert = \"INSERT INTO [dbo].\" + articleTableName(ctx)\r\n                + \" ([ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],[ARTICLE_REVISION_ID],[ASSORTMENT_ID])\"\r\n                + \" VALUES(\" + \" '\" + convertTOSQL(article.getId()) + \"',\" + \" '\" + convertTOSQL(article.getTerritory())\r\n                + \"',\" + \" '\" + convertTOSQL(article.getCustomerNr()) + \"',\" + \" '\"\r\n                + convertTOSQL(article.getCustomerArticleNr()) + \"',\" + \" '\" + convertTOSQL(article.getArticleNr())\r\n                + \"',\" + \" '\" + convertTOSQL(article.getCurrency()) + \"',\" + \" '\"\r\n                + convertTOSQL(article.getPriceFirst()) + \"',\" + \" '\" + convertTOSQL(article.getPriceX()) + \"',\" + \" '\"\r\n                + convertTOSQL(article.getPriceType()) + \"',\" + \" '\" + convertTOSQL(article.getValidFrom()) + \"',\"\r\n                + \" '\" + convertTOSQL(article.getValidTo()) + \"',\" + \" '\" + convertTOSQL(article.getScalelimit()) + \"',\"\r\n                + \" \" + article.getFoundArticleStatus() + \",\" + \" \" + article.getSpecial() + \",\" + \" '\"\r\n                + convertTOSQL(article.getComment()) + \"',\" + \" \" + article.getBasicassortment() + \",\" + \" \"\r\n                + article.getArticleRevisionId() + \",\" + \" \" + article.getAssortment().getId() + \")\";\r\n\r\n        dbServices.execute(sqlInsert);\r\n    }\r\n\r\n    /**\r\n     * The update function is used to update the article table in the database.\r\n     *\r\n     * @param Context     ctx Determine which table to use\r\n     * @param ArticleBase article Get the values for the update\r\n     */\r\n    @Transactional\r\n    private void update(Context ctx, ArticleBase article) {\r\n        String sqlInsert = \"UPDATE [dbo].\" + articleTableName(ctx) + \" \" + \"SET [TERRITORY] = '\"\r\n                + convertTOSQL(article.getTerritory()) + \"',\" + \"[CUSTOMER_NR] = '\"\r\n                + convertTOSQL(article.getCustomerNr()) + \"',\" + \"[CUSTOMER_ARTICLE_NR] = '\"\r\n                + convertTOSQL(article.getCustomerArticleNr()) + \"',\" + \"[ARTICLE_NR] = '\"\r\n                + convertTOSQL(article.getArticleNr()) + \"',\" + \"[CURRENCY] = '\" + convertTOSQL(article.getCurrency())\r\n                + \"',\" + \"[PRICE_FIRST] = '\" + convertTOSQL(article.getPriceFirst()) + \"',\" + \"[PRICE_X] = '\"\r\n                + convertTOSQL(article.getPriceX()) + \"',\" + \"[PRICE_TYPE] = '\" + convertTOSQL(article.getPriceType())\r\n                + \"',\" + \"[VALID_FROM] = '\" + convertTOSQL(article.getValidFrom()) + \"',\" + \"[VALID_TO] = '\"\r\n                + convertTOSQL(article.getValidTo()) + \"',\" + \"[SCALELIMIT] = '\" + convertTOSQL(article.getScalelimit())\r\n                + \"',\" + \"[FOUND_ARTICLE_STATUS] = \" + article.getFoundArticleStatus() + \",\" + \"[SPECIAL] = \"\r\n                + article.getSpecial() + \",\" + \"[COMMENT] = '\" + article.getComment() + \"',\" + \"[BASICASSORTMENT] = \"\r\n                + article.getBasicassortment() + \",\" + \"[ARTICLE_REVISION_ID] = \" + article.getArticleRevisionId() + \",\"\r\n                + \"[ASSORTMENT_ID] = \" + article.getAssortment().getId() + \" \" + \"WHERE ID = '\"\r\n                + convertTOSQL(article.getId()) + \"';\";\r\n        dbServices.execute(sqlInsert);\r\n    }\r\n\r\n    /**\r\n     * The updateList function is used to update the database with a list of articles.\r\n     *\r\n     * @param Context                 ctx Determine the table name\r\n     * @param List&lt;ArticleBase&gt; articles Update the database\r\n     */\r\n    @Transactional\r\n    private void updateList(Context ctx, List<ArticleBase> articles) {\r\n        String batch = \"\";\r\n        for (ArticleBase article : articles) {\r\n            String sqlInsert = \"UPDATE [dbo].\" + articleTableName(ctx) + \" \" + \"SET [TERRITORY] = '\"\r\n                    + article.getTerritory() + \"',\" + \"[CUSTOMER_NR] = '\" + article.getCustomerNr() + \"',\"\r\n                    + \"[CUSTOMER_ARTICLE_NR] = '\" + article.getCustomerArticleNr() + \"',\" + \"[ARTICLE_NR] = '\"\r\n                    + article.getArticleNr() + \"',\" + \"[CURRENCY] = '\" + article.getCurrency() + \"',\"\r\n                    + \"[PRICE_FIRST] = '\" + article.getPriceFirst() + \"',\" + \"[PRICE_X] = '\" + article.getPriceX()\r\n                    + \"',\" + \"[PRICE_TYPE] = '\" + article.getPriceType() + \"',\" + \"[VALID_FROM] = '\"\r\n                    + article.getValidFrom() + \"',\" + \"[VALID_TO] = '\" + article.getValidTo() + \"',\"\r\n                    + \"[SCALELIMIT] = '\" + article.getScalelimit() + \"',\" + \"[FOUND_ARTICLE_STATUS] = \"\r\n                    + article.getFoundArticleStatus() + \",\" + \"[SPECIAL] = \" + article.getSpecial() + \",\"\r\n                    + \"[COMMENT] = '\" + article.getComment() + \"',\" + \"[BASICASSORTMENT] = \"\r\n                    + article.getBasicassortment() + \",\" + \"[ARTICLE_REVISION_ID] = \" + article.getArticleRevisionId()\r\n                    + \",\" + \"[ASSORTMENT_ID] = \" + article.getAssortment().getId() + \" \" + \"WHERE ID = '\"\r\n                    + article.getId() + \"';\";\r\n            batch = batch.concat((batch.length() != 0 ? \"\\n\" : \"\") + sqlInsert);\r\n        }\r\n        dbServices.batchUpdate(batch);\r\n    }\r\n\r\n\r\n    /**\r\n     * The resetArticles function resets the FOUND_ARTICLE_STATUS, BASICASSORTMENT, COMMENT and ARTICLE_REVISION_ID columns in the article table to 0.\r\n     *\r\n     * @param Context ctx Determine the table name\r\n     */\r\n    @Transactional\r\n    public void resetArticles(Context ctx) {\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx)\r\n                + \" SET [FOUND_ARTICLE_STATUS] = 0, [BASICASSORTMENT] = 0, [COMMENT] = '',[ARTICLE_REVISION_ID] = 0 \";\r\n        dbServices.execute(sqlUpdate);\r\n    }\r\n\r\n\r\n    /**\r\n     * The insertIntoTable function takes a list of ArticleBase objects and inserts them into the database.\r\n     *\r\n     * @param Context                 ctx Determine the table name\r\n     * @param List&lt;ArticleBase&gt; articles Insert the articles into the database\r\n     */\r\n    @Transactional\r\n    public void insertIntoTable(Context ctx, List<ArticleBase> articles) {\r\n        String body = \"\";\r\n        String insertHeader = String.format(\r\n                \"INSERT INTO [dbo].[%s] ([ID],[CUSTOMER_ARTICLE_NR],[PRICE_FIRST],[PRICE_X],[SCALELIMIT]) VALUES\",\r\n                articleTableName(ctx));\r\n        for (ArticleBase article : articles) {\r\n            body = body.concat((body.isEmpty() ? \"\" : \",\") + setInsertBodyOfArticle(article));\r\n        }\r\n        dbServices.execute(insertHeader + \" \" + body);\r\n    }\r\n\r\n\r\n    /**\r\n     * The insertIntoTable function takes a list of ArticleBase objects and inserts them into the database.\r\n     *\r\n     * @param Context                 ctx Get the table name from the context\r\n     * @param List&lt;ArticleBase&gt; articles Get the data from the articles\r\n     * @param String                  table Determine the table name\r\n     */\r\n    @Transactional\r\n    public void insertIntoTable(Context ctx, List<ArticleBase> articles, String table) {\r\n        String body = \"\";\r\n        String insertHeader = String.format(\r\n                \"INSERT INTO [dbo].[%s] ([ID],[CUSTOMER_ARTICLE_NR],[PRICE_FIRST],[PRICE_X],[SCALELIMIT]) VALUES\",\r\n                articleTableName(ctx, table));\r\n        for (ArticleBase article : articles) {\r\n            body = body.concat((body.isEmpty() ? \"\" : \",\") + setInsertBodyOfArticle(article));\r\n        }\r\n        dbServices.execute(insertHeader + \" \" + body);\r\n    }\r\n\r\n\r\n    /**\r\n     * The addToTable function takes two table names as parameters, and adds the contents of one table to another.\r\n     * The function is used in the process of updating a customer's price list with new articles from their supplier.\r\n     *\r\n     * @param Context ctx Get the table name from the context\r\n     * @param String  toTable Determine which table to insert into\r\n     * @param String  addTable Add the table name to the query\r\n     */\r\n    @Transactional\r\n    public void addToTable(Context ctx, String toTable, String addTable) {\r\n        String insertHeader = String.format(\r\n                \"INSERT INTO %s ([ID],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],[PRICE_FIRST],[PRICE_X],[SCALELIMIT]) \"\r\n                        + \"SELECT [ID],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],[PRICE_FIRST],[PRICE_X],[SCALELIMIT] FROM %s a \"\r\n                        + \"WHERE a.FOUND_ARTICLE_STATUS = 0 AND a.ID NOT IN (SELECT ID FROM %s) \",\r\n                articleTableName(ctx, toTable), articleTableName(ctx, addTable),\r\n                articleTableName(ctx, toTable));\r\n\r\n        dbServices.execute(insertHeader);\r\n    }\r\n\r\n    /**\r\n     * The findAll function is used to retrieve all the articles from the database.\r\n     *\r\n     * @param Context ctx Get the table name for the current assortment\r\n     * @param int     id Get the article from the database\r\n     * @return A list of objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> findAll(Context ctx, int id) {\r\n        List<ArticleBase> result = new ArrayList<ArticleBase>();\r\n        String sqlSelect = \"SELECT \" + \"[ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],\"\r\n                + \"[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID] FROM [dbo].[\" + articleTableName(ctx) + \"]\";\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        result.addAll(dbServices.query(sqlSelect, new ArticleBaseRowMapper(assortment)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findAllNotInPositiv function is used to find all articles that are not in the POSITIV table.\r\n     *\r\n     * @param Context ctx Get the active assortment\r\n     * @param String  identifier Find the correct table in the database\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> findAllNotInPositiv(Context ctx, String identifier) {\r\n\r\n        if (Objects.nonNull(articleTableName(ctx, identifier))) {\r\n            String sqlSelect = \"SELECT \" + \"[ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],ID AS [ARTICLE_NR],\"\r\n                    + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],\"\r\n                    + \"[SCALELIMIT],4 AS [FOUND_ARTICLE_STATUS],[SPECIAL], 'NOTFOUNDINPOSITIV' AS [COMMENT],[BASICASSORTMENT],\"\r\n                    + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID] FROM [dbo].[\" + articleTableName(ctx, identifier)\r\n                    + \"] \" + \"WHERE ID NOT IN (SELECT ARTICLE_NR FROM \" + articleTableName(ctx) + \")\";\r\n\r\n            Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n            return dbServices.query(sqlSelect, new ArticleBaseRowMapper(assortment));\r\n        } else {\r\n            return new ArrayList<ArticleBase>();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The findAllInArchivByAssortment function is used to find all the ArticleBase objects in the database\r\n     * that are associated with a specific Assortment object. The function takes an Assortment object as its\r\n     * parameter and returns a list of ArticleBase objects. It does this by first creating an SQL query string,\r\n     * which selects all columns from the AST_ARTICLE_BASE table where ASSORTMENT_ID = assortment.getId().\r\n     * Then it uses dbServices to execute this query and return a list of ArticleBase objects using the\r\n     * ArticleBaseRowMapper class, which maps each row in the result set into an\r\n     *\r\n     * @param Assortment assortment Set the assortment of the articlebase object\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> findAllInArchivByAssortment(Assortment assortment) {\r\n\r\n        String sqlSelect = \"SELECT [ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],\"\r\n                + \"[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID] FROM AST_ARTICLE_BASE WHERE ASSORTMENT_ID = \"\r\n                + assortment.getId();\r\n\r\n        return dbServices.query(sqlSelect, new ArticleBaseRowMapper(assortment));\r\n    }\r\n\r\n    /**\r\n     * The findAllByAssortmentAndIsCommet function is used to find all the articles in a given assortment that have comments.\r\n     *\r\n     * @param Assortment assortment Get the assortment id of the article base\r\n     *                   private class articlebaserowmapper implements rowmapper&lt;articlebase&gt; {\r\n     *                   <p>\r\n     *                   assortment assortment;\r\n     *                   <p>\r\n     *                   public articlebaserowmapper(assortment assortment) {\r\n     *                   this\r\n     * @param boolean    isComment Determine if the article is a comment or not\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> findAllByAssortmentAndIsCommet(Assortment assortment, boolean isComment) {\r\n\r\n        String comment = \"\";\r\n        if (isComment) {\r\n            comment = \"COMMENT != '' \";\r\n        } else {\r\n            comment = \"FOUND_ARTICLE_STATUS = \" + FilterStatus.DEFAULT.getId() + \" \";\r\n        }\r\n\r\n        String sqlSelect = \"SELECT \" + \"[ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],\"\r\n                + \"[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID] FROM AST_ARTICLE_BASE \" + \"WHERE ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" AND \" + comment;\r\n\r\n        return dbServices.query(sqlSelect, new ArticleBaseRowMapper(assortment));\r\n\r\n    }\r\n\r\n    /**\r\n     * The saveCurrentArticles function saves the current articles in the assortment to a database table.\r\n     * The function is called when an assortment is saved, and it saves all of the articles that are currently\r\n     * displayed in the article list.  It does this by first deleting any existing entries for that particular\r\n     * assortment from AST_ARTICLE_BASE, then inserting new rows into AST_ARTICLE_BASE with data from [dbo].[articleTableName(ctx)].\r\n     *\r\n     * @param Context ctx Get the user session and to get the active assortment\r\n     */\r\n    @Transactional\r\n    public void saveCurrentArticles(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        String sqlDelete = \"DELETE FROM AST_ARTICLE_BASE WHERE ASSORTMENT_ID = \" + assortment.getId();\r\n        dbServices.execute(sqlDelete);\r\n\r\n        String sqlSelect = \"INSERT INTO AST_ARTICLE_BASE ([ID],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],[PRICE_FIRST],\"\r\n                + \"[PRICE_X],[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],[ASSORTMENT_ID]) SELECT \" + \"CONCAT(\" + assortment.getId() + \",'\"\r\n                + DB_DELIMITER + \"',[ID]) AS [ID],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                + \"[PRICE_FIRST],[PRICE_X],[SCALELIMIT],[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],\"\r\n                + \"[ARTICLE_REVISION_ID],\" + assortment.getId() + \" FROM [dbo].[\" + articleTableName(ctx) + \"]\";\r\n        dbServices.execute(sqlSelect);\r\n    }\r\n\r\n    /**\r\n     * The findAll function returns a list of all the articles in the database.\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> findAll(Context ctx) {\r\n        List<ArticleBase> articles = new ArrayList<ArticleBase>();\r\n        if (Objects.nonNull(ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE))) {\r\n            articles.addAll(findAll(ctx, 0));\r\n        }\r\n        return articles;\r\n    }\r\n\r\n    /**\r\n     * The exists function checks to see if the filter type exists in the database.\r\n     *\r\n     *\r\n     * @param Context ctx Determine the table name\r\n     * @param FilterType type Determine which table to query\r\n     *\r\n     * @return True if the article table contains a row with the given filter type\r\n     *\r\n\r\n     */\r\n    /**\r\n     * The exists function checks to see if the filter type exists in the database.\r\n     *\r\n     * @param Context    ctx Determine which database to use\r\n     * @param FilterType type Determine the type of filter to be used\r\n     * @return A boolean value\r\n     */\r\n    @Transactional\r\n    public boolean exists(Context ctx, FilterType type) {\r\n        String sqlCount = \"SELECT COUNT(ID) FROM \" + articleTableName(ctx) + \" WHERE COMMENT LIKE '%\"\r\n                + type.name() + \"%' \";\r\n        int count = dbServices.queryForObject(sqlCount, Integer.class);\r\n        return count != 0;\r\n    }\r\n\r\n    /**\r\n     * The findAllByFilterStatus function is used to find all articles that have a filter status of the given statuses.\r\n     *\r\n     * @param Context         ctx Get the current context\r\n     * @param String          in Determine the type of article to be returned\r\n     * @param FilterStatus... status Pass in an array of filterstatus objects\r\n     * @return A list of articlebase objects\r\n     */\r\n    @Transactional\r\n    public List<ArticleBase> findAllByFilterStatus(Context ctx, String in, FilterStatus... status) {\r\n        Integer[] filters = new Integer[status.length];\r\n\r\n        for (int i = 0; i < status.length; i++) {\r\n            filters[i] = status[i].getId();\r\n        }\r\n        return findAllByFilterStatus(ctx, in, filters);\r\n    }\r\n\r\n    /**\r\n     * The findAllByFilterStatus function is used to find all articles in the database that have a status\r\n     * matching one of the statuses passed into this function. The function takes in an array of integers,\r\n     * which are then converted into strings and concatenated together with commas separating them. This string\r\n     * is then added to a SQL query that selects all articles from the database whose FOUND_ARTICLE_STATUS matches\r\n     * any of these statuses (the &quot;in&quot; parameter determines whether it should match any or none). The results are\r\n     * returned as a list of ArticleBase objects, which contain information about each article found\r\n     *\r\n     * @param Context    ctx Get the usersession\r\n     * @param String     in Determine whether the query should be an in or not in statement\r\n     * @param Integer... status Pass a variable number of arguments to the function\r\n     * @return A list of articlebase objects\r\n     */\r\n    public List<ArticleBase> findAllByFilterStatus(Context ctx, String in, Integer... status) {\r\n        List<ArticleBase> articles = new ArrayList<>();\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        if (Objects.nonNull(tabSession)) {\r\n            Locale locale = new SessionUtils(userSession).getLocale(ctx);\r\n            List<Language> languages = enumServices.getAllLanguages();\r\n            Optional<Language> optLang = languages.stream()\r\n                    .filter(lang -> lang.getLabel().equals(locale.toLanguageTag())).findFirst();\r\n            optLang.ifPresent(lang -> {\r\n                String filters = \"\";\r\n                for (Integer stats : status) {\r\n                    filters = filters.concat((filters.isEmpty() ? \"\" : \",\") + stats.intValue());\r\n                }\r\n\r\n                String sqlSelect = \"SELECT [ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],\"\r\n                        + \"[CURRENCY],[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],[SCALELIMIT],\"\r\n                        + \"[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],a.[ARTICLE_REVISION_ID], CASE WHEN b.[PRODUCT_NAME] IS NULL THEN '' ELSE b.[PRODUCT_NAME] END as PRODUCT_NAME,[ASSORTMENT_ID] \"\r\n                        + \"FROM [dbo].[\" + articleTableName(ctx)\r\n                        + \"] a LEFT JOIN AST_PIM_ARTICLE_PRODUCT_NAME b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                        + \"AND b.LANGUAGE_ID = \" + lang.getKey() + \" WHERE FOUND_ARTICLE_STATUS \" + in + \" (\" + filters\r\n                        + \")\";\r\n\r\n                Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n                articles.addAll(dbServices.query(sqlSelect, new ArticleBaseRowMapper(assortment)));\r\n            });\r\n        }\r\n        return articles;\r\n    }\r\n\r\n\r\n    /**\r\n     * The updateGlobals function updates the article table with the correct assortment id and article number.\r\n     *\r\n     * @param Context ctx Get the table name\r\n     * @param String  table Determine which table to update\r\n     */\r\n    @Transactional\r\n    public void updateGlobals(Context ctx, String table) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx, table) + \" SET ARTICLE_NR = ID, ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" \";\r\n\r\n        dbServices.execute(sqlUpdate);\r\n    }\r\n\r\n\r\n    /**\r\n     * The clearUpdates function is used to remove the UPDATE prefix from all article IDs in the database.\r\n     * It also sets their FOUND_ARTICLE_STATUS to DEFAULT, which is 0. This function is called when a user\r\n     * clicks on &quot;Clear Updates&quot; in the GUI. The SQL query that it executes does this by first updating all articles with an ID that starts with UPDATE and has a status of -999 (which means they were updated) so that their ID no longer starts with UPDATE and their status becomes 0 (DEFAULT). Then, it deletes any articles whose IDs start with UPDATE but do not have a corresponding article\r\n     *\r\n     * @param Context ctx Get the article table name\r\n     */\r\n    @Transactional\r\n    public void clearUpdates(Context ctx) {\r\n        String sqlUpdate = \"UPDATE \" + articleTableName(ctx) + \" SET ID = REPLACE(ID,'\" + UPDATE\r\n                + \"',''), FOUND_ARTICLE_STATUS = \" + FilterStatus.DEFAULT.getId() + \" \" + \"FROM \"\r\n                + articleTableName(ctx) + \" WHERE CONCAT('\" + UPDATE + \"',ID) NOT IN (SELECT ID FROM \"\r\n                + articleTableName(ctx) + \") \" + \"AND FOUND_ARTICLE_STATUS = -999 \";\r\n\r\n        dbServices.execute(sqlUpdate);\r\n\r\n        String sqlDelete = \"DELETE FROM \" + articleTableName(ctx) + \" WHERE ID LIKE '\" + UPDATE\r\n                + \"%' AND FOUND_ARTICLE_STATUS = -999\";\r\n\r\n        dbServices.execute(sqlDelete);\r\n    }\r\n\r\n    /**\r\n     * The loadFromArchivToCache function is used to load the articles from the archive into a cache.\r\n     *\r\n     * @param Context    ctx Get the table name\r\n     * @param Assortment assortment Get the assortment id\r\n     * @param int        status Determine the status of the article\r\n     */\r\n    @Transactional\r\n    public void loadFromArchivToCache(Context ctx, Assortment assortment, int status) {\r\n        String sqlStatement = \"INSERT INTO \" + articleTableName(ctx)\r\n                + \"([ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],[CURRENCY]\"\r\n                + \",[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],[SCALELIMIT]\"\r\n                + \",[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],[ARTICLE_REVISION_ID]\"\r\n                + \",[ASSORTMENT_ID]) \"\r\n                + \" SELECT [ID],[TERRITORY],[CUSTOMER_NR],[CUSTOMER_ARTICLE_NR],[ARTICLE_NR],[CURRENCY]\"\r\n                + \",[PRICE_FIRST],[PRICE_X],[PRICE_TYPE],[VALID_FROM],[VALID_TO],[SCALELIMIT]\"\r\n                + \",[FOUND_ARTICLE_STATUS],[SPECIAL],[COMMENT],[BASICASSORTMENT],[ARTICLE_REVISION_ID]\"\r\n                + \",[ASSORTMENT_ID]\" + \"FROM [eCatMgmt].[dbo].[AST_ARTICLE_BASE] WHERE ASSORTMENT_ID = \" + assortment.getId()\r\n                + \" AND FOUND_ARTICLE_STATUS = \" + status;\r\n        dbServices.execute(sqlStatement);\r\n    }\r\n\r\n    /**\r\n     * The findAllTypesInComments function returns a list of all the types in the comments column.\r\n     *\r\n     * @param Context ctx Determine the table name\r\n     * @return A list of all the types in comments\r\n     */\r\n    @Transactional\r\n    public List<String> findAllTypesInComments(Context ctx) {\r\n        List<String> types = null;\r\n\r\n        /*\r\n         * Select DISTINCT names from AST_ARTICLE_BASE_01 a INNER JOIN\r\n         * (VALUES('GHS_CODES'),('NOTFREE'),('NOTAPPROVAL'),('NOTINPIM'),('NOPRICE'),('\r\n         * BRANDS'),('NOTFOUNDINPOSITIV'),('REMOVEBYPOSTIV'),('CONFIG'),('STRUCTURE'),('\r\n         * STRUCTURE_ARTICLE'),('BASIC_ASSORTMENT'),('INTRASTAT'),('ZUORDNUNG_MATERIAL')\r\n         * ,('ARTIKELKLASSE'),('INFOTYPE'),('COUNTRY_LOCK'),('INDIVIDUAL')) E(names) ON\r\n         * a.COMMENT LIKE '%'+names+'%'\r\n         */\r\n\r\n        String values = \"\";\r\n        for (FilterType type : FilterType.values()) {\r\n            values = values.concat((!values.isEmpty() ? \",\" : \"\") + \"('\" + type.name() + \"')\");\r\n        }\r\n\r\n        String sqlSelect = \"Select DISTINCT names from \" + articleTableName(ctx) + \" a INNER JOIN (VALUES \"\r\n                + values + \" E(names) ON a.COMMENT LIKE '%'+names+'%' order by names\";\r\n        types = dbServices.queryForList(sqlSelect, String.class);\r\n        return types;\r\n    }\r\n\r\n    /**\r\n     * The setInsertBodyOfArticle function is used to create the body of an SQL INSERT statement.\r\n     * The function takes a single ArticleBase object as input and returns a String containing the\r\n     * values for each column in the table, formatted according to SQL syntax.  This function is called by\r\n     * setInsertStatementOfArticle, which uses it to build an entire INSERT statement from scratch.  It's also used by\r\n     * setUpdateStatementOfArticle, which uses it to build only part of an UPDATE statement (the SET clause).\r\n     *\r\n     * @param ArticleBase article Get the data from the article object\r\n     * @return A string\r\n     */\r\n    private String setInsertBodyOfArticle(ArticleBase article) {\r\n        // [ID],[CUSTOMER_ARTICLE_NR],[PRICE_FIRST],[PRICE_X],[SCALELIMIT]\r\n        String body = String.format(\"('%s','%s','%s','%s','%s')\"\r\n                /* X [ID] */, convertTOSQL(article.getArticleNr())\r\n                /* X [CUSTOMER_ARTICLE_NR] */, convertTOSQL(article.getCustomerArticleNr())\r\n                /* X [PRICE_FIRST] */, convertTOSQL(article.getPriceFirst())\r\n                /* X [PRICE_X] */, convertTOSQL(article.getPriceX())\r\n                /* X [SCALELIMIT] */, convertTOSQL(article.getScalelimit()));\r\n\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * The convertTOSQL function takes a string and replaces all single quotes with two single quotes.\r\n     * This is necessary because SQL uses the single quote as its delimiter, so if you want to use a\r\n     * literal in your query, you need to escape it by doubling it up. For example:\r\n     * SELECT name FROM people WHERE name = 'John O''Brien'; // John O'Brien is the person's actual name!\r\n     *\r\n     * @param String value Store the value that is being passed in from the user\r\n     * @return A string that is safe to insert into a sql database\r\n     */\r\n    private String convertTOSQL(String value) {\r\n        String result = value;\r\n        result = result.replace(\"'\", \"''\");\r\n        return result;\r\n    }\r\n\r\n    private class ArticleBaseRowMapper implements RowMapper<ArticleBase> {\r\n\r\n        private Assortment assortment = null;\r\n\r\n        public ArticleBaseRowMapper(Assortment assortment) {\r\n            this.assortment = assortment;\r\n        }\r\n\r\n        @Override\r\n        public ArticleBase mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            ArticleBase article = new ArticleBase();\r\n            article.setId(rs.getString(\"ID\"));\r\n            article.setTerritory(rs.getString(\"TERRITORY\"));\r\n            article.setCustomerNr(rs.getString(\"CUSTOMER_NR\"));\r\n            article.setCustomerArticleNr(rs.getString(\"CUSTOMER_ARTICLE_NR\"));\r\n            article.setArticleNr(rs.getString(\"ARTICLE_NR\"));\r\n            article.setCurrency(rs.getString(\"CURRENCY\"));\r\n            article.setPriceFirst(rs.getString(\"PRICE_FIRST\"));\r\n            article.setPriceX(rs.getString(\"PRICE_X\"));\r\n            article.setPriceType(rs.getString(\"PRICE_TYPE\"));\r\n            article.setValidFrom(rs.getString(\"VALID_FROM\"));\r\n            article.setValidTo(rs.getString(\"VALID_TO\"));\r\n            article.setScalelimit(rs.getString(\"SCALELIMIT\"));\r\n            article.setFoundArticleStatus(rs.getInt(\"FOUND_ARTICLE_STATUS\"));\r\n            article.setSpecial(rs.getInt(\"SPECIAL\"));\r\n            article.setComment(rs.getString(\"COMMENT\"));\r\n            article.setBasicassortment(rs.getInt(\"BASICASSORTMENT\"));\r\n            article.setArticleRevisionId(rs.getInt(\"ARTICLE_REVISION_ID\"));\r\n            article.setAssortment(assortment);\r\n\r\n            try {\r\n                String productName = rs.getString(\"PRODUCT_NAME\");\r\n                if (Objects.nonNull(productName)) {\r\n                    article.setProductName(productName);\r\n                }\r\n            } catch (SQLException e) {\r\n                log.debug(\"productName not exist\");\r\n            }\r\n\r\n            return article;\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ArticleBaseRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ArticleStatisticCustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.model.ArticleStatistic;\r\nimport com.hom.ebmw.jpa.model.TemplateData;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.InternalUtils;\r\nimport com.hom.ebmw.view.dialogs.CustomDialog;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.util.List;\r\n\r\n@Repository\r\npublic class ArticleStatisticCustomRepository {\r\n    private final JdbcTemplate dbServices;\r\n\r\n    /**\r\n     * The ArticleStatisticCustomRepository function is a custom repository that allows the user to query the database for\r\n     * articles with specific characteristics. The function takes in an ArticleStatistic object and returns a list of\r\n     * Article objects that match the criteria specified by the user. The function also has two optional parameters, which\r\n     * allow users to specify whether they want their results sorted by article title or publication date, and whether they\r\n     * want their results sorted in ascending or descending order. If no sorting options are specified, then default values\r\n     * will be used (sorted by title in ascending order).\r\n     *\r\n     * @param JdbcTemplate dbServices Access the database\r\n     * @return The articlestatisticcustomrepository\r\n     */\r\n    public ArticleStatisticCustomRepository(JdbcTemplate dbServices) {\r\n        this.dbServices = dbServices;\r\n    }\r\n\r\n    /**\r\n     * The removeByTemplate function removes all ArticleStatisticData objects from the database that are associated with a given TemplateData object.\r\n     *\r\n     * @param TemplateData template Identify the template to be deleted\r\n     */\r\n    @Transactional\r\n    public void removeByTemplate(TemplateData template) {\r\n        String sqlStatement = \"DELETE FROM AST_ARTICLE_STATISTIC WHERE TEMPLATE_ID = \" + template.getId();\r\n        dbServices.execute(sqlStatement);\r\n    }\r\n\r\n    /**\r\n     * The insertList function is a function that takes in a list of ArticleStatistic objects and inserts them into the database.\r\n     * The function splits the list into parts of 1000 items each, and then inserts those parts one by one.\r\n     * This is done to prevent memory errors from occurring when inserting large amounts of data at once.\r\n     *\r\n     * @param Context                      ctx Create a dialog\r\n     * @param List&lt;ArticleStatistic&gt; values Pass the list of articlestatistic objects to be inserted into the database\r\n     */\r\n    public void insertList(Context ctx, List<ArticleStatistic> values) {\r\n        int partSize = 1000;\r\n        CustomDialog dialog = new CustomDialog(ctx);\r\n        List<List<ArticleStatistic>> splitParts = InternalUtils.listSplitter(values, partSize);\r\n        dialog.setCom(() -> {\r\n            dialog.setProgressReset();\r\n            dialog.setProgressVisible(true);\r\n            dialog.setProgressMinMax(0, splitParts.size());\r\n            splitParts.forEach(items -> {\r\n                dialog.setValue(splitParts.indexOf(items) + 1.0);\r\n                insertValues(items);\r\n            });\r\n        });\r\n        dialog.open();\r\n        dialog.run();\r\n    }\r\n\r\n    /**\r\n     * The insertValues function takes a list of ArticleStatistic objects and inserts them into the AST_ARTICLE_STATISTIC table.\r\n     * The function first creates an empty string called items, then loops through each ArticleStatistic object in the values list.\r\n     * For each object, it calls buildInsertItem to create a string that represents one row in the database table (the identifier and templateId).\r\n     * It then adds this new item to items with a comma separating it from any previous items added to the string. Once all of these strings have been created,\r\n     * they are concatenated together with commas between them and inserted\r\n     *\r\n     * @param List&lt;ArticleStatistic&gt; values Pass in a list of articlestatistic objects to the function\r\n     */\r\n    @Transactional\r\n    private void insertValues(List<ArticleStatistic> values) {\r\n        String sqlStatment = \"INSERT INTO AST_ARTICLE_STATISTIC (IDENTIFIER, TEMPLATE_ID) VALUES \";\r\n        String items = \"\";\r\n        for (ArticleStatistic articleStatistic : values) {\r\n            items = items.concat((items.isEmpty() ? \"\" : \",\") + buildInsertItem(articleStatistic));\r\n        }\r\n\r\n        dbServices.execute(sqlStatment + items);\r\n    }\r\n\r\n    /**\r\n     * The buildInsertItem function takes an ArticleStatistic object and returns a string that can be used in the SQL query to insert it into the database.\r\n     *\r\n     * @param ArticleStatistic item Get the identifier and template id of the article\r\n     * @return A string that looks like this:\r\n     */\r\n    private String buildInsertItem(ArticleStatistic item) {\r\n        return \"('\" + item.getIdentifier() + \"',\" + item.getTemplate().getId() + \")\";\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\ArticleStatisticCustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\AssortmentCustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.dao.ArticleBaseQueueDAO;\r\nimport com.hom.ebmw.jpa.dao.AssortmentDAO;\r\nimport com.hom.ebmw.jpa.model.ArticleBaseQueue;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.AstFile;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.time.LocalDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Slf4j\r\n@Repository\r\npublic class AssortmentCustomRepository {\r\n\r\n    private final ArticleBaseRepository articleBaseService;\r\n    private final AssortmentDAO assortmentService;\r\n    private final ArticleBaseQueueDAO articleBaseQueueService;\r\n\r\n    /**\r\n     * The AssortmentCustomRepository function is a custom repository that allows for the creation of new Assortment objects.\r\n     *\r\n     * @param ArticleBaseRepository articleBaseService Call the findall() method in articlebaserepository\r\n     * @param AssortmentDAO         assortmentService Call the getassortmentbyarticlebaseid() method\r\n     * @param ArticleBaseQueueDAO   articleBaseQueueService Call the function below\r\n     * @return An assortmentcustomrepository object\r\n     */\r\n    public AssortmentCustomRepository(ArticleBaseRepository articleBaseService, AssortmentDAO assortmentService, ArticleBaseQueueDAO articleBaseQueueService) {\r\n        this.articleBaseService = articleBaseService;\r\n        this.assortmentService = assortmentService;\r\n        this.articleBaseQueueService = articleBaseQueueService;\r\n    }\r\n\r\n    /**\r\n     * The remove function is used to delete an assortment from the database.\r\n     * It first truncates the article table, then deletes any wrong closed assortments,\r\n     * and finally sets the deleted by and on fields of the assortment object.\r\n     *\r\n     * @param Context    ctx Get the current user\r\n     * @param Assortment assortment Get the assortment that is to be deleted\r\n     */\r\n    public void remove(Context ctx, Assortment assortment) {\r\n        articleBaseService.truncateArticleTable(ctx);\r\n        deleteWrongClosedAssortment(assortment);\r\n        assortment.setDeleteBy(ctx.getSession().getCurrentUser(ctx));\r\n        assortment.setDeleteOn(LocalDateTime.now());\r\n\r\n        assortmentService.save(assortment);\r\n    }\r\n\r\n    /**\r\n     * The deleteWrongClosedAssortment function is used to delete the assortment from the temporary table.\r\n     *\r\n     * @param Assortment assortment Delete the assortment from the database\r\n     */\r\n    @Transactional\r\n    public void deleteWrongClosedAssortment(Assortment assortment) {\r\n        List<ArticleBaseQueue> queues = new ArrayList<>(articleBaseQueueService.findAll());\r\n        queues.removeIf(item -> item.getSession().isEmpty());\r\n        queues.forEach(item -> {\r\n            try {\r\n                String table = item.getTableName();\r\n                AstFile tempAssortment = articleBaseService.getTempTableAssortment(table);\r\n                if (tempAssortment.getId() == assortment.getId()) {\r\n                    articleBaseService.truncateArticleTable(table);\r\n                    item.setSession(\"\");\r\n                    item.setUser(null);\r\n                }\r\n            } catch (Exception e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        });\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\AssortmentCustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\CustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.sql.SQLException;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@Repository\r\npublic class CustomRepository {\r\n\r\n    private final JdbcTemplate jdbcTemplate;\r\n\r\n    /**\r\n     * The CustomRepository function is a function that allows the user to create their own custom query.\r\n     * The CustomRepository function takes in two parameters:\r\n     *\r\n     * @param JdbcTemplate jdbcTemplate Create a new jdbctemplate object\r\n     * @return A jdbctemplate object\r\n     */\r\n    public CustomRepository(JdbcTemplate jdbcTemplate) {\r\n        this.jdbcTemplate = jdbcTemplate;\r\n    }\r\n\r\n    /**\r\n     * The findAllByCustom function is a function that allows the user to query the database using their own custom SQL statement.\r\n     * This function will return a list of maps, where each map represents one row in the result set.\r\n     * The keys of each map are column names and values are cell values for that row/column combination.\r\n     *\r\n     * @param String query Pass in the query to be executed\r\n     * @return A list of maps\r\n     */\r\n    public List<Map<String, Object>> findAllByCustom(String query) throws SQLException {\r\n        //NO CRUD ALLOWED\r\n        if (query.toUpperCase().contains(\"DELETE \")) throw new SQLException(\"DELETE NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"INSERT \")) throw new SQLException(\"INSERT NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"INTO \")) throw new SQLException(\"INSERT NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"UPDATE \")) throw new SQLException(\"UPDATE NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"ALTER \")) throw new SQLException(\"UPDATE NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"DROP \")) throw new SQLException(\"DROP NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"CREATE \")) throw new SQLException(\"CREATE NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"TRUNCATE \")) throw new SQLException(\"TRUNCATE NOT ALLOWED\");\r\n\r\n        if (query.toUpperCase().contains(\"--\")) throw new SQLException(\"COMMENT NOT ALLOWED\");\r\n        if (query.toUpperCase().contains(\"/*\")) throw new SQLException(\"COMMENT NOT ALLOWED\");\r\n\r\n        return jdbcTemplate.queryForList(query);\r\n    }\r\n\r\n    /**\r\n     * The findAllFiltersByRole function is used to find all filters by role.\r\n     *\r\n     * @param Role role Get the role id from the role object\r\n     * @return A list of map objects\r\n     */\r\n    public List<Map<String, Object>> findAllFiltersByRole(Role role) throws SQLException {\r\n        String sqlStatement = \"Select concat(d.NAME, '_',a.NAME) as NAME, LABEL as FILTER_NAME , \" +\r\n                \"CASE WHEN c.DIRECTION < 0 THEN 'OUT' ELSE 'IN' END AS DIRECTION , CONCAT(b.SUR_NAME, ', ', b.GIVEN_NAME) AS CREATOR from AST_FILTER a \" +\r\n                \"INNER JOIN AST_USER b ON a.CREATEBY = b.ID \" +\r\n                \"INNER JOIN AST_FILTERBASE c ON c.FILTER_ID = a.ID \" +\r\n                \"INNER JOIN AST_ROLE d ON a.TM_ID = d.ID \" +\r\n                \"WHERE a.TM_ID = \" + role.getId() + \" AND a.DELETEBY IS NULL \" +\r\n                \"ORDER BY 1 \";\r\n\r\n        return findAllByCustom(sqlStatement);\r\n    }\r\n\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\CustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\DelayParameterRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.model.LocalCustomer;\r\nimport com.hom.ebmw.pojo.DelayWrapper;\r\nimport com.hom.ebmw.utilities.Blob;\r\nimport com.hom.ebmw.utilities.enums.FileParam;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic class DelayParameterRepository {\r\n\r\n    private final JdbcTemplate jdbcTemplate;\r\n\r\n    private final LocalCustomerCustomRepository customerService;\r\n\r\n    /**\r\n     * The DelayParameterRepository function is used to retrieve the delay parameters for a given customer.\r\n     *\r\n     * @param JdbcTemplate                  jdbcTemplate Access the database\r\n     * @param LocalCustomerCustomRepository customerService Get the customerid from the database\r\n     * @return A delayparameterrepository object\r\n     */\r\n    public DelayParameterRepository(JdbcTemplate jdbcTemplate, LocalCustomerCustomRepository customerService) {\r\n        this.jdbcTemplate = jdbcTemplate;\r\n        this.customerService = customerService;\r\n    }\r\n\r\n    /**\r\n     * The getDelayWrappers function is used to retrieve a list of DelayWrapper objects from the database.\r\n     * The function takes in a FileParam object as an argument, and uses this to filter the results returned by the query.\r\n     * The SQL_QUERY_PARAMETERS string contains all of the necessary information for querying data from our database, including:\r\n     * -The table names we are querying (AST_FILE, AST_PARAMETER) and their associated columns (ID, NAME)\r\n     * -The join conditions between these tables (a.ID = b.FILE_ID) which allow us to combine data\r\n     *\r\n     * @param FileParam paramFilter Filter the query\r\n     * @return A list of delaywrapper objects\r\n     */\r\n    @Transactional\r\n    public List<DelayWrapper> getDelayWrappers(FileParam paramFilter) {\r\n        String SQL_QUERY_PARAMETERS = \"Select a.ID,NAME, c.VALUE, b.ID as QUEUE_ID, d.VALUE AS TYPE, f.CUSTOMER_NR from AST_FILE a \"\r\n                + \"INNER JOIN AST_PARAMETER b ON a.ID = b.FILE_ID \" // UPLOAD\r\n                + \"INNER JOIN AST_PARAMETER c ON a.ID = c.FILE_ID \" // VALID_FROM\r\n                + \"INNER JOIN AST_PARAMETER d ON a.ID = d.FILE_ID \" // TYPE\r\n                + \"INNER JOIN AST_PROJECT_ROLE e ON a.PROJECT_ROLE_ID = e.ID \"\r\n                + \"INNER JOIN AST_PROJECT f ON e.PROJECT_ID = f.ID \"\r\n                + \"WHERE a.DELETEBY IS NULL \"\r\n                + \"AND b.PARAM = '\" + paramFilter.getName() + \"' \"\r\n                + \"AND c.PARAM = '\" + FileParam.VALID_FROM.getName() + \"' \"\r\n                + \"AND d.PARAM = '\" + FileParam.FILE_TYPE.getName() + \"' \";\r\n\r\n        List<DelayWrapper> table = jdbcTemplate.query(SQL_QUERY_PARAMETERS,\r\n                new DelayWrapperRowMapper());\r\n\r\n        return table;\r\n    }\r\n\r\n    private class DelayWrapperRowMapper implements RowMapper<DelayWrapper> {\r\n\r\n        @Override\r\n        public DelayWrapper mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            DelayWrapper wrap = new DelayWrapper();\r\n\r\n            wrap.setId(rs.getInt(\"ID\"));\r\n            wrap.setName(rs.getString(\"NAME\"));\r\n            wrap.setQueueId(rs.getInt(\"QUEUE_ID\"));\r\n            wrap.setType(Blob.convertByte2Object(rs.getBytes(\"TYPE\")));\r\n            wrap.setValidFrom(Blob.convertByte2Object(rs.getBytes(\"VALUE\")));\r\n            Optional<LocalCustomer> customer = customerService.findByCustomerNr(rs.getString(\"CUSTOMER_NR\"));\r\n            customer.ifPresent(wrap::setCustomer);\r\n\r\n            return wrap;\r\n        }\r\n\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\DelayParameterRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseBlankGetRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.service.EnumerationService;\r\nimport com.hom.ebmw.ipim.service.IPIMService;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filter;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.KatalogVersion;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.FilterUtils;\r\nimport com.hom.ebmw.utilities.TreeConverter;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\n@Repository\r\npublic class FilterBaseBlankGetRepository {\r\n\r\n    private final JdbcTemplate dbService;\r\n\r\n    private final EnumerationService enumerationService;\r\n\r\n    private final IPIMService iPimService;\r\n\r\n    /**\r\n     * The FilterBaseBlankGetRepository function is used to retrieve the data from the database for a blank filter.\r\n     *\r\n     * @param JdbcTemplate       dbService Query the database\r\n     * @param EnumerationService enumerationService Get the enumeration values for a given enumeration name\r\n     * @param IPIMService        iPimService Call the getallproducts() function\r\n     * @return A filterbaseblankgetrepository object\r\n     */\r\n    public FilterBaseBlankGetRepository(JdbcTemplate dbService, EnumerationService enumerationService, IPIMService iPimService) {\r\n        this.dbService = dbService;\r\n        this.enumerationService = enumerationService;\r\n        this.iPimService = iPimService;\r\n    }\r\n\r\n    /**\r\n     * The getStartDate function returns the start date of the current assortment.\r\n     *\r\n     * @param Context ctx Get the active assortment and filter\r\n     * @return The date of the current assortment\r\n     */\r\n    private LocalDate getStartDate(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        Filter filter = ctx.getUserSession().get(Params.ACTIVE_FILTER);\r\n        KatalogVersion version = null;\r\n        if (Objects.nonNull(assortment)) {\r\n            version = CompUtils.getParameter(ctx, FileParam.KATALOG_VERSION, assortment);\r\n            version = CompUtils.getKatalogVersion(ctx, filter.getSortType());\r\n        } else {\r\n            version = CompUtils.getKatalogVersion(ctx, ObjectType.ECAT);\r\n        }\r\n\r\n        return version.getValidFrom();\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterialInBasicAssortment function returns a list of Filterbase objects.\r\n     * The function is called by the getArticleAssignedMaterialInBasicAssortment method in the ArticleService class.\r\n     * The getArticleAssignedMaterialInBasicAssortment function takes two parameters: locale and status, which are both int arrays.\r\n     * The locale parameter is used to determine whether or not to return German or English labels for each Filterbase object in the list that will be returned by this function.\r\n     * The status parameter determines what type of article statuses should be included in the results (e.g., only articles with a status of &quot;\r\n     *\r\n     * @param Locale locale Get the language of the user\r\n     * @param int... status Pass in an array of ints\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleAssignedMaterialInBasicAssortment(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"Select 'BASIC_ASSORTMENT' AS LABEL \";\r\n        result.addAll(dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.ZUORDNUNG_MATERIAL)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterial function returns a list of Filterbase objects.\r\n     * The function is called by the getFilterList function in the FilterService class.\r\n     * The getArticleAssignedMaterial function calls the query method from DBService, which executes an SQL statement and returns a List of Filterbase objects.\r\n     *\r\n     * @param Context ctx Get the language of the user\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass in an array of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleAssignedMaterial(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM ( \"\r\n                + \"Select CASE WHEN NEXT_ASSIGNED_MATERIAL IS NOT NULL THEN SUBSTRING(NEXT_ASSIGNED_MATERIAL, 1,3) ELSE CURRENT_ASSIGNED_MATERIAL END AS LABEL \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_ASSIGNED_MATERIAL) temp GROUP BY LABEL \";\r\n        result.addAll(dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.ZUORDNUNG_MATERIAL)));\r\n        FilterUtils.updateAssignedMaterialLabels(ctx, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleInfoType function returns a list of Filterbase objects, which are used to populate the\r\n     * dropdown menu in the filter section of the PIM. The function takes two parameters: a Context object and an int array.\r\n     * The Context object is used to get information about the user's session, such as their locale (language). This is necessary because\r\n     * some fields in our database are language-specific; for example, we have separate columns for English and German labels. We need to know what language\r\n     * we should be using when querying these columns so that we can return results that make sense to our users. The int array\r\n     *\r\n     * @param Context ctx Get the start date\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleInfoType(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM ( \"\r\n                + \"Select CASE WHEN NEXT_INFO_TYPE IS NOT NULL THEN SUBSTRING(NEXT_INFO_TYPE, 1,3) ELSE CURRENT_INFO_TYPE END AS LABEL \"\r\n                + \"from AST_PIM_FILTER_ARTICLE_INFO_TYPE Where (VALID_FROM < '\"\r\n                + getStartDate(ctx).toString() + \"' OR VALID_FROM IS NULL) ) temp GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.INFOTYPE));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleClass function returns a list of article classes.\r\n     *\r\n     * @param Context ctx Get the start date of the current season\r\n     * @param Locale  locale Determine the language of the returned values\r\n     * @param int...  status Define the status of the article\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleClass(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM ( \"\r\n                + \"Select CASE WHEN NEXT_CLASS IS NOT NULL THEN SUBSTRING(NEXT_CLASS, 1,3) ELSE CURRENT_CLASS END AS LABEL \"\r\n                + \"from AST_PIM_FILTER_ARTICLE_CLASS Where (VALID_FROM < '\"\r\n                + getStartDate(ctx).toString() + \"' OR VALID_FROM IS NULL) ) temp GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.ARTIKELKLASSE));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleBrand function returns a list of all the brands in the database.\r\n     *\r\n     * @param Locale locale Determine the language of the result\r\n     * @param int... status Pass in a variable number of int values\r\n     * @return A list of brands\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleBrand(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM AST_PIM_FILTER_ARTICLE_BRANDS GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.BRANDS));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleBrandAndAssortment function is used to get the article brand and assortment.\r\n     *\r\n     * @param Context ctx Get the locale of the user\r\n     * @param String  assortmentName Filter the results by assortment name\r\n     * @param Locale  locale Get the correct language for the labels\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleBrandAndAssortment(Context ctx, String assortmentName, Locale locale,\r\n                                                         int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT b.LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_ASSORTMENT a \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_BRANDS b ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                + \"WHERE ASSORTMENT_NAME = '\" + assortmentName + \"' \" + \"GROUP BY b.LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.S3_CATALOGS));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleGHSCode function is used to retrieve the GHS codes for a given article.\r\n     *\r\n     * @param Locale locale Get the language of the user\r\n     * @param int... status Pass in a variable number of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleGHSCode(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM AST_PIM_FILTER_ARTICLE_GHS_CODE GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.GHS_CODES));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleConfig function returns a list of Filterbase objects.\r\n     * The function is used to retrieve the article configuration data from the database.\r\n     *\r\n     * @param Locale locale Get the language of the user\r\n     * @param int... status Pass in a variable number of ints\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleConfig(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM AST_PIM_FILTER_ARTICLE_CONFIG GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.CONFIG));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleIntraStat function returns a list of Filterbase objects.\r\n     * The function takes in a locale and an array of ints as parameters.\r\n     * The function uses the dbService to query the database for all labels from AST_PIM_FILTER_ARTICLE_INTRA_STAT where TERRITORY = 'DE' and groups them by label.\r\n     * It then creates a new ArrayList called result, which is populated with the results from this query using the FilterbaseRowMapper class to map each row into an object.\r\n     *\r\n     * @param Locale locale Determine the language of the returned results\r\n     * @param int... status Pass an array of integers to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIntraStat(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM AST_PIM_FILTER_ARTICLE_INTRA_STAT Where TERRITORY = 'DE' GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.INTRASTAT));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleNotFree function returns a list of Filterbase objects that are not free.\r\n     *\r\n     * @param Locale locale Determine the language of the result\r\n     * @param int... status Pass an array of int values to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleNotFree(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL FROM AST_PIM_FILTER_ARTICLE_NOT_FREE Where TERRITORY = 'DE' GROUP BY LABEL \";\r\n        result = dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.NOTFREE));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureClassification function is used to retrieve the article structure classification\r\n     * from the database. The function takes in a string representing the name of an article structure, a locale\r\n     * object representing which language to use when retrieving data from the database, and an integer array\r\n     * containing status values. The function returns a list of Filterbase objects that contain information about\r\n     * each article structure classification retrieved from the database. This information includes: label (the name),\r\n     * identifier (a unique ID number), and key (the ID number). If no results are found in the database for any given query, then null is returned instead of an\r\n     *\r\n     * @param String structureName Get the structure name from the database\r\n     * @param Locale locale Get the language of the user\r\n     * @param int... status Pass an array of ints to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructureClassification(String structureName, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        List<Language> languages = enumerationService.getAllLanguages();\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(locale.toLanguageTag()))\r\n                .findFirst();\r\n        optLang.ifPresent(lang -> {\r\n\r\n            String sqlParent = \" SELECT CONCAT('(',sl.IDENTIFIER,') ', sl.LABEL) LABEL, sl.STRUCTURE_GROUP_ID \"\r\n                    + \"FROM AST_PIM_FILTER_STRUCTURE_CLASSIFICATION sc \"\r\n                    + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG sl ON sl.STRUCTURE_GROUP_ID = sc.STRUCTURE_GROUP_ID \"\r\n                    + \"AND sl.LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                    + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP artStr ON artStr.STRUCTURE_GROUP_ID = sc.STRUCTURE_GROUP_ID \"\r\n                    + \"WHERE STRUCTURE_NAME LIKE '\" + structureName\r\n                    + \"' GROUP BY sl.LABEL, sl.IDENTIFIER, sl.STRUCTURE_GROUP_ID \";\r\n\r\n            result.addAll(dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getStructureTree function is used to retrieve the structure tree for a given setting.\r\n     *\r\n     * @param Setting  setting Determine the type of filter (optional or mandatory)\r\n     * @param Language lang Get the language of the structure\r\n     * @return A list of filterbase objects\r\n     */\r\n    public List<Filterbase> getStructureTree(Setting setting, Language lang) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        SettingType type = SettingType.valueOf(setting.getIdentifier());\r\n\r\n        String sqlParent = \" Select ID, ENTITY_IDENTIFIER, a.IDENTIFIER, a.LABEL ,TYPE, DIRECTION,a.STRUCTURE_GROUP_ID,STRUCTURE_TYPE, a.STRUCTURE_GROUP_ID from AST_FILTERBASE a \"\r\n\r\n                //+ \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG b ON a.STRUCTURE_GROUP_ID = b.STRUCTURE_GROUP_ID \"\r\n                + \"WHERE LOWER(STRUCTURE_TYPE) = '\" + type.getOptional()\r\n                + \"' AND [DELETE] = 0 \"\r\n                //+ \"AND b.LANGUAGE_ID = \" + lang.getKey()\r\n                + \" ORDER BY LABEL, SORT \";\r\n\r\n        result.addAll(dbService.query(sqlParent, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructure function is used to get the article structure of a given category.\r\n     *\r\n     * @param Setting structureSetting Get the structure of a category\r\n     * @param Locale  locale Get the language of the article\r\n     * @param int...  status Filter the articles by status\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructure(Setting structureSetting, Locale locale, int... status) {\r\n        List<Filterbase> buffer = new ArrayList<>();\r\n        List<Language> languages = enumerationService.getAllLanguages();\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(locale.toLanguageTag()))\r\n                .findFirst();\r\n        if (optLang.isPresent()) {\r\n            Language lang = optLang.get();\r\n            buffer = iPimService.getAllStructureOfCategory(structureSetting, lang);\r\n\r\n            buffer.removeIf(item -> item.getIdentifier().split(\":\").length < 2);\r\n            buffer.forEach(item -> item.setParent(null));\r\n\r\n            TreeConverter convert = new TreeConverter(buffer);\r\n\r\n            buffer = convert.convertToTree();\r\n\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n\r\n    private class FilterbaseRowMapper implements RowMapper<Filterbase> {\r\n\r\n        private String type = \"\";\r\n\r\n        public FilterbaseRowMapper(FilterType type) {\r\n            this.type = type.name();\r\n        }\r\n\r\n        @Override\r\n        public Filterbase mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            Filterbase base = new Filterbase();\r\n\r\n            try {\r\n                base.setId(rs.getInt(\"ID\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            try {\r\n                base.setEntityIdentifier(rs.getString(\"ENTITY_IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            base.setLabel(rs.getString(\"LABEL\"));\r\n            try {\r\n                base.setIdentifier(rs.getString(\"IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                base.setIdentifier(rs.getString(\"LABEL\"));\r\n            }\r\n            base.setType(type);\r\n            try {\r\n                base.setStructureGroupId(rs.getInt(\"STRUCTURE_GROUP_ID\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setChildCount(rs.getInt(\"COUNTER\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setDirection(rs.getInt(\"DIRECTION\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setSort(rs.getInt(\"SORT\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            return base;\r\n        }\r\n\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseBlankGetRepository.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-XijUWnIR1VyLU3vgHBoxLmAxmQhdCvkq",
    "created" : 1762170712,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\ArticleBaseGetRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"SQL Injection risk through string concatenation of parameters (e.g., articleTableName, lang.getKey(), label)\",\n      \"justification\": \"User-controlled values are directly inserted into SQL strings without using prepared statements, allowing malicious input to alter queries.\",\n      \"action\": \"Refactor all queries to use JdbcTemplate's query methods with parameter placeholders; add unit tests verifying that unsafe inputs are escaped or rejected.\",\n      \"source\": \"getArticleAssignedMaterialNotInBasicAssortment, getArticleCustomColumn, getArticleCustomFilter, getArticleS3CatalogFilter, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security-critical, prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Potential NullPointerException in articleTableName and getStartDate when session data is missing\",\n      \"justification\": \"Methods assume ctx.getUserSession().get(...) returns non-null maps; if missing, a NPE will crash the service.\",\n      \"action\": \"Add null checks and fallback handling for missing session entries; write tests simulating absent session data.\",\n      \"source\": \"articleTableName(Context ctx), getStartDate(Context ctx)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Unnecessary @Transactional on readonly methods\",\n      \"justification\": \"Readonly queries do not need a transaction, which can add overhead and lock resources.\",\n      \"action\": \"Remove @Transactional from methods that only perform SELECTs; verify behavior with integration tests.\",\n      \"source\": \"getArticleAssignedMaterialInBasicAssortment, getArticleAssignedMaterialNotInBasicAssortment, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"performance\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"String concatenation for dates using toString() may cause format mismatches\",\n      \"justification\": \"Localedependent string formats can break SQL date comparisons.\",\n      \"action\": \"Use java.sql.Date or proper date formatting (ISO8601) when building date literals; add tests for different locales.\",\n      \"source\": \"getArticleCustomColumn, getArticleCustomFilter, getArticleInfoType, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"logic correctness\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"RowMapper only maps a subset of ArticleBase fields\",\n      \"justification\": \"Missing fields (e.g., PRICE_TYPE, VALID_TO) may lead to incomplete objects and hidden bugs.\",\n      \"action\": \"Extend ArticleBaseRowMapper to map all columns defined in SELECT statements; add unit tests verifying full mapping.\",\n      \"source\": \"ArticleBaseRowMapper.mapRow\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"functionality\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"2\",\n    \"top_todos\": [\n      \"Migrate all raw SQL concatenations to prepared statements with parameter binding\",\n      \"Add defensive null checks for sessionderived values and write corresponding tests\",\n      \"Remove unnecessary @Transactional annotations from readonly repository methods\"\n    ]\n  }\n}\n{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\ArticleBaseRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Extensive SQL injection surface due to unchecked string concatenation\",\n      \"justification\": \"Methods like save, insert, update, truncateArticleTable(String) embed userderived values (e.g., table names, IDs, article fields) directly into SQL, exposing the DB to injection attacks.\",\n      \"action\": \"Rewrite all queries using JdbcTemplate parameter placeholders; validate and whitelist table names before use; add integration tests with malicious inputs.\",\n      \"source\": \"save, insert, update, truncateArticleTable, updateGlobals, clearUpdates, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security-critical, prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Malformed SQL in save(): missing space before WHERE clause\",\n      \"justification\": \"Generated query becomes \\\"... FROM tableWHERE ID = ...\\\", causing runtime SQL syntax errors and potential data loss.\",\n      \"action\": \"Insert a space before \\\"WHERE\\\" in the query string; add unit test verifying correct SQL generation.\",\n      \"source\": \"save(Context ctx, ArticleBase article)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Potential NPE when articleTableName returns empty string or null\",\n      \"justification\": \"If session data is missing, subsequent queries will reference an invalid table name, causing failures.\",\n      \"action\": \"Add explicit null/empty checks and throw a meaningful exception; include tests for missing session entries.\",\n      \"source\": \"articleTableName(Context ctx) and overloaded version\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"convertTOSQL only escapes single quotes, leaving other characters unchecked\",\n      \"justification\": \"While it prevents basic quote injection, other characters (e.g., backslashes) may still lead to malformed queries.\",\n      \"action\": \"Replace manual escaping with prepared statements; if still needed, use Apache Commons StringEscapeUtils for full SQL escaping.\",\n      \"source\": \"convertTOSQL(String value)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Batch updates built by concatenating huge SQL strings (insertIntoTable, updateList)\",\n      \"justification\": \"Large strings can exceed DB limits and degrade performance.\",\n      \"action\": \"Use JdbcTemplate.batchUpdate with parameter arrays instead of one massive concatenated statement.\",\n      \"source\": \"insertIntoTable, updateList\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"performance\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Unnecessary @Transactional on simple read methods (e.g., findAllByFilterStatus)\",\n      \"justification\": \"Adds transaction overhead without benefit.\",\n      \"action\": \"Remove @Transactional from pure read queries; verify with integration tests.\",\n      \"source\": \"findAllByFilterStatus, findAllNotInPositiv, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"performance\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"clearUpdates uses a mutable constant UPDATE = \\\"\\\" leading to unclear intent\",\n      \"justification\": \"The constant name suggests a prefix but is empty; future changes may break logic.\",\n      \"action\": \"Rename constant to CLEAR_UPDATE_PREFIX and document its purpose; ensure tests cover both update and delete branches.\",\n      \"source\": \"clearUpdates(Context ctx)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"maintainability\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"2\",\n    \"top_todos\": [\n      \"Migrate all raw SQL to parameterised statements with proper validation\",\n      \"Fix malformed SQL in save() by adding missing whitespace before WHERE\",\n      \"Replace large stringbased batch updates with JdbcTemplate.batchUpdate\"\n    ]\n  }\n}\n{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\ArticleStatisticCustomRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"SQL injection via string concatenation in insertValues()\",\n      \"justification\": \"Identifier and template ID are concatenated directly into the INSERT statement without escaping or parameterisation.\",\n      \"action\": \"Rewrite insertValues to use JdbcTemplate.batchUpdate with placeholders; add tests for special characters in identifier.\",\n      \"source\": \"insertValues(List<ArticleStatistic> values)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Repository mixes UI logic by creating and controlling CustomDialog\",\n      \"justification\": \"Violates separation of concerns; makes the repository hard to test and reuse.\",\n      \"action\": \"Move dialog handling to a service or controller layer; repository should only perform DB operations.\",\n      \"source\": \"insertList(Context ctx, List<ArticleStatistic> values)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"maintainability\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"No exception handling for DB errors in removeByTemplate() and insertValues()\",\n      \"justification\": \"SQL exceptions will propagate unchecked, possibly causing transaction rollbacks without clear logging.\",\n      \"action\": \"Wrap DB calls in trycatch, log errors with stack trace, and rethrow a custom DataAccessException.\",\n      \"source\": \"removeByTemplate(TemplateData template), insertValues(...)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"reliability\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Refactor insertList/insertValues to use prepared statements and remove UI dialog handling from repository\",\n      \"Add proper exception handling and logging for database operations\",\n      \"Write unit tests covering special characters in identifiers\"\n    ]\n  }\n}\n{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\AssortmentCustomRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Potential SQL injection via truncateArticleTable(table) in deleteWrongClosedAssortment\",\n      \"justification\": \"Table name originates from queue data without validation; malicious input could drop/modify unintended tables.\",\n      \"action\": \"Validate table names against a whitelist of allowed patterns before truncating; add tests for invalid names.\",\n      \"source\": \"deleteWrongClosedAssortment\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Possible NullPointerException when tempAssortment is null\",\n      \"justification\": \"articleBaseService.getTempTableAssortment(table) may return null; accessing getId() will throw NPE.\",\n      \"action\": \"Add null check for tempAssortment before comparing IDs; log a warning if null.\",\n      \"source\": \"deleteWrongClosedAssortment (tempAssortment.getId())\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"remove(Context, Assortment) is not transactional\",\n      \"justification\": \"Sequence of truncate, delete, and save should be atomic to avoid partial state.\",\n      \"action\": \"Annotate remove() with @Transactional; verify with integration tests that rollback occurs on failure.\",\n      \"source\": \"remove(Context ctx, Assortment assortment)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"data integrity\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Logging only error message without stack trace in deleteWrongClosedAssortment\",\n      \"justification\": \"Makes debugging harder when unexpected exceptions occur.\",\n      \"action\": \"Log full exception (e.g., log.error(\\\"Error truncating table\\\", e)); add unit test ensuring logging occurs.\",\n      \"source\": \"catch (Exception e) { log.error(e.getLocalizedMessage()); }\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"maintainability\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Validate table names before truncating in deleteWrongClosedAssortment\",\n      \"Add null checks for tempAssortment and improve exception logging\",\n      \"Make remove() method transactional to ensure atomic operation\"\n    ]\n  }\n}\n{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\CustomRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Incomplete SQL whitelist allows sophisticated injection bypasses\",\n      \"justification\": \"Only simple keyword checks are performed; attackers can use whitespace, comments, or Unicode tricks to inject malicious statements.\",\n      \"action\": \"Replace freeform query execution with a safe DSL or restrict to readonly prepared statements; add exhaustive unit tests for injection patterns.\",\n      \"source\": \"findAllByCustom(String query)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security-critical, prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Potential information leakage via thrown SQLException messages\",\n      \"justification\": \"Stack traces or DB error messages may expose schema details to callers.\",\n      \"action\": \"Wrap SQLException in a custom unchecked exception with generic message; log original exception internally.\",\n      \"source\": \"findAllByCustom\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"findAllFiltersByRole constructs SQL with role.getId() directly\",\n      \"justification\": \"Although role IDs are likely safe, using parameter binding would be more robust.\",\n      \"action\": \"Use JdbcTemplate.queryForList with \\\"?\\\" placeholder for role ID; add test verifying correct parameterisation.\",\n      \"source\": \"findAllFiltersByRole\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"maintainability\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"2\",\n    \"top_todos\": [\n      \"Replace adhoc whitelist with prepared statements or a safe query builder\",\n      \"Wrap and sanitize SQL exceptions to avoid leaking DB details\",\n      \"Parameterise role ID in findAllFiltersByRole\"\n    ]\n  }\n}\n{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\DelayParameterRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"SQL injection via concatenated parameters (paramFilter.getName(), etc.)\",\n      \"justification\": \"FileParam values are inserted directly into the query without escaping, opening a vector for injection if an attacker controls the enum name.\",\n      \"action\": \"Use JdbcTemplate query with \\\"?\\\" placeholders for all dynamic values; add unit tests with malicious enum names.\",\n      \"source\": \"getDelayWrappers(FileParam paramFilter)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Deserialization of BLOB data without validation (Blob.convertByte2Object)\",\n      \"justification\": \"Converting arbitrary byte arrays to objects may lead to remote code execution if data is tampered.\",\n      \"action\": \"Validate the class type before deserialization or replace with a safe data format (e.g., JSON); add tests for malformed blobs.\",\n      \"source\": \"DelayWrapperRowMapper.mapRow\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"No explicit error handling for JDBC failures\",\n      \"justification\": \"SQLExceptions will propagate and may cause transaction rollbacks without clear logging.\",\n      \"action\": \"Wrap query execution in trycatch, log errors with stack trace, and rethrow a custom DataAccessException.\",\n      \"source\": \"getDelayWrappers\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"reliability\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Switch to prepared statements for all query parameters\",\n      \"Securely deserialize BLOB data or replace with safer format\",\n      \"Add proper exception handling and logging for DB operations\"\n    ]\n  }\n}\n{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\jpa\\\\dao\\\\impl\\\\FilterBaseBlankGetRepository.java\",\n  \"issues\": [\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"SQL injection in multiple methods (e.g., getArticleBrandAndAssortment, getStructureTree) due to direct concatenation of parameters\",\n      \"justification\": \"Usercontrolled values like assortmentName are embedded without escaping, risking injection attacks.\",\n      \"action\": \"Rewrite queries to use parameter placeholders; validate/whitelist inputs; add tests for injection attempts.\",\n      \"source\": \"getArticleBrandAndAssortment, getStructureTree, getArticleStructureClassification, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"security\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Potential NullPointerException in getStartDate when assortment or filter is null\",\n      \"justification\": \"The method assumes ctx contains a valid assortment and filter; missing values will cause NPEs.\",\n      \"action\": \"Add null checks and fallback defaults; write unit tests covering missing session data.\",\n      \"source\": \"getStartDate(Context ctx)\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Lack of pagination or result size limiting for queries that may return large datasets\",\n      \"justification\": \"Methods like getArticleBrand could load entire tables into memory, causing performance degradation.\",\n      \"action\": \"Introduce LIMIT/OFFSET parameters and expose pagination support; add performance tests.\",\n      \"source\": \"getArticleBrand, getArticleAssignedMaterial, etc.\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"performance\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"RowMapper silently ignores missing columns with catchall Exception blocks\",\n      \"justification\": \"Swallowing exceptions can hide schema mismatches and make debugging harder.\",\n      \"action\": \"Log missing column warnings explicitly and consider failing fast; add tests for expected column presence.\",\n      \"source\": \"FilterbaseRowMapper.mapRow\",\n      \"component\": \"repository\",\n      \"impact_scope\": \"maintainability\",\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Convert all concatenated SQL statements to prepared statements with proper parameter binding\",\n      \"Add null checks in getStartDate and improve error handling for missing session data\",\n      \"Implement pagination for methods returning large result sets\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to produce a JSON review for each file? The prompt: \"You are a senior code reviewer. Analyze each code chunk.\" There are multiple files. We need to output a single JSON? Probably per file, but schema expects a single file field. Might need separate JSON objects per file? The instruction says respond with only JSON, but not multiple. Could combine multiple file entries? Possibly need an array? But schema is fixed: keys file, issues, summary. Probably produce one JSON per file, but we can output multiple JSON objects? Might be ambiguous. Usually they expect one JSON per file chunk. Might combine? I think we can output multiple JSON objects concatenated? But \"always as a single JSON object\". Might need to choose one file at a time. The user gave multiple files; maybe we need to review each and output separate JSON objects in an array? But schema doesn't allow array. Could embed multiple objects under a top-level \"files\" array? Not specified.\n\nProbably we should produce a JSON with file name as something like \"multiple\" and list issues across all? But they'd be unrelated.\n\nBetter to produce separate JSON objects sequentially separated by newline, each complying. Might be acceptable.\n\nI'll output one JSON per file, separated by newline.\n\nNow analyze each file for issues.\n\nFile 1: ArticleBaseGetRepository.java\n\nIssues:\n\n1 High: SQL injection risk: constructing SQL with concatenated parameters (articleTableName, lang.getKey(), label) directly without prepared statements. Impact: security.\n\n2 Med: No input validation for label, locale not used, potential NPE if lang is null.\n\n3 Med: Potential NPE in articleTableName: ctx.getUserSession().get may return null -> NullPointer.\n\n4 Low: Transactional annotation on read-only queries; maybe not needed.\n\n5 Low: Duplicate code in getArticleCustomColumn similar to other methods; could refactor.\n\n6 Med: Using string concatenation for dates via toString; may cause format issues.\n\n7 Low: No pagination, could cause performance issues on large tables.\n\n8 High: No handling of SQL exceptions, may bubble.\n\n9 Med: Using magic numbers for column names etc.\n\n10 Low: RowMapper does not map all columns (e.g., missing fields).\n\nFile 2: ArticleBaseRepository.java\n\nIssues:\n\n1 High: SQL injection throughout (concatenated strings with parameters like ctx, id, etc.) especially in save, insert, update.\n\n2 High: Potential SQL syntax errors missing space before \"WHERE\" in save (articleTableName(ctx) + \"WHERE ID = ...\").\n\n3 Med: Missing validation of ctx and articleTableName may cause NPE.\n\n4 Med: convertTOSQL only escapes single quotes, but not other characters; still vulnerable.\n\n5 Med: Batch update building large string with concatenation, could exceed size limit.\n\n6 Low: Use of raw JDBC instead of Spring's parameterized queries leads to security and performance.\n\n7 Med: In truncateArticleTable(String table) no validation; possible injection.\n\n8 Low: In findFirst method, uses (ctx) as string in FROM clause -> likely bug.\n\n9 Med: In findAllByFilterStatus, building filters string without parameterization, risk.\n\n10 Low: In clearUpdates, using UPDATE prefix constant UPDATE which is empty string? Might be bug.\n\nFile 3: ArticleStatisticCustomRepository.java\n\nIssues:\n\n1 Med: No input validation for ctx, values; but uses batch insert with string concat -> injection risk.\n\n2 Med: Building SQL with concatenated identifiers and template IDs, no escaping.\n\n3 Low: Using CustomDialog in repository (UI logic) violates separation of concerns.\n\n4 Low: No transaction for deleteByTemplate? It has @Transactional.\n\n5 Low: No error handling.\n\nFile 4: AssortmentCustomRepository.java\n\nIssues:\n\n1 Med: deleteWrongClosedAssortment uses truncateArticleTable(table) without validation, possible injection.\n\n2 Med: Potential NPE if tempAssortment null.\n\n3 Low: Logging only error message, no stack trace.\n\n4 Low: Method remove not transactional, could cause partial updates.\n\nFile 5: CustomRepository.java\n\nIssues:\n\n1 High: findAllByCustom attempts to whitelist but still vulnerable to SQL injection via comment detection only; could bypass.\n\n2 Med: Using toUpperCase and contains may be bypassed with whitespace or comments.\n\n3 Med: No parameterization; returning raw query.\n\n4 Low: Throwing SQLException for disallowed statements may expose details.\n\nFile 6: DelayParameterRepository.java\n\nIssues:\n\n1 Med: SQL concatenation with paramFilter.getName() and other values without escaping -> injection.\n\n2 Med: No handling of nulls.\n\n3 Low: Blob.convertByte2Object may cause deserialization security risk if data untrusted.\n\nFile 7: FilterBaseBlankGetRepository.java\n\nIssues:\n\n1 Med: SQL injection in many methods building queries with parameters (assortmentName, locale not used but could be). No escaping.\n\n2 Med: getStartDate uses CompUtils.getParameter possibly null, risk NPE.\n\n3 Low: Methods return empty list but may hide errors.\n\n4 Low: No pagination, could be large.\n\nNow produce JSON per file summarizing top 3 todos.\n\nProceed."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 5580,
      "prompt_tokens" : 23058,
      "total_tokens" : 28638
    },
    "timings" : {
      "cache_n" : 62,
      "prompt_n" : 22996,
      "prompt_ms" : 17230.372,
      "prompt_per_token_ms" : 0.7492769177248216,
      "prompt_per_second" : 1334.6200534730185,
      "predicted_n" : 5580,
      "predicted_ms" : 67158.637,
      "predicted_per_token_ms" : 12.035598028673835,
      "predicted_per_second" : 83.08685597654402
    }
  }
}