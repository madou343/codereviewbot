{
  "timestamp" : "2025-11-03T13:03:28.2720859",
  "index" : 15,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\BreadCrumble.java =====\n```\npackage com.hom.ebmw.view.components.interfaces;\r\n\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\n\r\npublic interface BreadCrumble {\r\n\r\n    default org.slf4j.Logger getLogger() {\r\n        return org.slf4j.LoggerFactory.getLogger(getClass());\r\n    }\r\n\r\n    default void reloadCrumb() {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n\r\n    default void reloadButtons() {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n\r\n    default void goToNext() {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n\r\n    default void goToLast() {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n\r\n    default void goFinish() {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n\r\n    default void doBeforeNext(CrumbProgressDialog dialog) {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n\r\n    default void exit() {\r\n        getLogger().debug(\"not implemented yet\");\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\BreadCrumble.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\FileInputConverter.java =====\n```\npackage com.hom.ebmw.view.components.interfaces;\r\n\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.view.dialogs.FileConvertDialog;\r\n\r\nimport java.util.List;\r\n\r\npublic interface FileInputConverter {\r\n\r\n    void initLayout(FileConvertDialog dialog);\r\n\r\n    void directSave(FileConvertDialog dialog, List<ArticleBase> articles);\r\n\r\n    void doOnSave(FileConvertDialog dialog);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\FileInputConverter.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\FileInputLoader.java =====\n```\npackage com.hom.ebmw.view.components.interfaces;\r\n\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.view.dialogs.FileImportDialog;\r\n\r\nimport java.util.List;\r\n\r\npublic interface FileInputLoader {\r\n\r\n    void initLayout(FileImportDialog dialog);\r\n\r\n    void directSave(FileImportDialog dialog, List<ArticleBase> articles);\r\n\r\n    void doOnSave(FileImportDialog dialog);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\FileInputLoader.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\GridReloadService.java =====\n```\npackage com.hom.ebmw.view.components.interfaces;\r\n\r\nimport com.vaadin.flow.data.provider.DataProvider;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\n\r\nimport java.util.List;\r\n\r\npublic interface GridReloadService<E> {\r\n    void onFoundChanged();\r\n\r\n    void reload(List<E> items);\r\n\r\n    ListDataProvider<E> getDataProvider();\r\n\r\n    <F> void setDataProvider(DataProvider<E, F> dataProvider);\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\interfaces\\GridReloadService.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\JiraIssueCollector.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.component.page.Page;\r\nimport lombok.Setter;\r\n\r\nimport java.util.Objects;\r\n\r\n\r\npublic class JiraIssueCollector {\r\n\r\n    private final String jQuery = \"https://code.jquery.com/jquery-latest.js\";\r\n    private final String js = \"https://hoffmann-group-digital.atlassian.net/s/d41d8cd98f00b204e9800998ecf8427e-T/o2joag/b/24/a44af77267a987a660377e5c46e0fb64/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=de-DE&collectorId=bce26392\";\r\n    private @Setter Page page;\r\n    private UI ui;\r\n\r\n    /**\r\n     * The JiraIssueCollector function is used to collect information about the user's browser and environment,\r\n     * as well as any additional information that may be useful in diagnosing a problem. This function is called\r\n     * when an exception occurs within the application. The JiraIssueCollector function then creates a new issue\r\n     * on JIRA with all of this collected data, which can then be used by developers to diagnose and fix problems.\r\n     *\r\n     * @return A jiraissuecollector object\r\n     */\r\n    public JiraIssueCollector() {\r\n        ui = UI.getCurrent();\r\n        if (Objects.nonNull(ui)) {\r\n            page = ui.getPage();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The loadReport function is used to load the report into the page.\r\n     * It does this by adding jQuery and js to the page, then executing js on an empty string.\r\n     */\r\n    public void loadReport() {\r\n        if (Objects.nonNull(page)) {\r\n            page.addJavaScript(jQuery);\r\n            page.addJavaScript(js);\r\n            page.executeJs(js, \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The setUi function is used to set the UI of the current page.\r\n     */\r\n    public void setUi() {\r\n        this.ui = UI.getCurrent();\r\n        if (Objects.nonNull(ui)) {\r\n            page = ui.getPage();\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\JiraIssueCollector.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\MyDialog.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.hom.ebmw.pojo.Position;\r\nimport com.vaadin.flow.component.dialog.Dialog;\r\nimport com.vaadin.flow.function.SerializableConsumer;\r\nimport org.apache.commons.lang3.StringUtils;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class MyDialog extends Dialog {\r\n    private static final String SET_PROPERTY_IN_OVERLAY_JS = \"this.$.overlay.$.overlay.style[$0]=$1\";\r\n\r\n    /**\r\n     * The setPosition function sets the position of the overlay.\r\n     *\r\n     * @param Position position Set the position of the overlay\r\n     */\r\n    public void setPosition(Position position) {\r\n        enablePositioning(true);\r\n        getElement().executeJs(SET_PROPERTY_IN_OVERLAY_JS, \"left\", position.getLeft());\r\n        getElement().executeJs(SET_PROPERTY_IN_OVERLAY_JS, \"top\", position.getTop());\r\n    }\r\n\r\n    /**\r\n     * The enablePositioning function sets the align-self and position properties of the overlay element.\r\n     * The align-self property is set to flex-start if positioningEnabled is true, otherwise it's set to unset.\r\n     * The position property is set to absolute if positioningEnabled is true, otherwise it's set to relative.\r\n     *\r\n     * @param boolean positioningEnabled Determine whether the position of the overlay should be set to absolute or relative\r\n     */\r\n    private void enablePositioning(boolean positioningEnabled) {\r\n        getElement()\r\n                .executeJs(SET_PROPERTY_IN_OVERLAY_JS, \"align-self\", positioningEnabled ? \"flex-start\" : \"unset\");\r\n        getElement()\r\n                .executeJs(SET_PROPERTY_IN_OVERLAY_JS, \"position\", positioningEnabled ? \"absolute\" : \"relative\");\r\n    }\r\n\r\n    /**\r\n     * The getPosition function is used to get the position of the overlay.\r\n     *\r\n     * @param SerializableConsumer&lt;Position&gt; consumer Pass the position of the overlay to a consumer\r\n     */\r\n    public void getPosition(SerializableConsumer<Position> consumer) {\r\n        getElement()\r\n                .executeJs(\r\n                        \"return [\" + \"this.$.overlay.$.overlay.style['top'], this.$.overlay.$.overlay.style['left']\" + \"]\"\r\n                )\r\n                .then(\r\n                        String.class,\r\n                        s -> {\r\n                            String[] split = StringUtils.split(s, ',');\r\n                            if (split.length == 2 && split[0] != null && split[1] != null) {\r\n                                Position position = new Position(split[0], split[1]);\r\n                                consumer.accept(position);\r\n                            }\r\n                        }\r\n                );\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\MyDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\RoleChanger.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.hom.ebmw.jpa.model.LocalCustomer;\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.CTXAttribute;\r\nimport com.hom.ebmw.utilities.enums.SessionParams;\r\nimport com.hom.ebmw.view.sortment.dialogs.CloseWithOption;\r\nimport com.vaadin.flow.component.combobox.ComboBox;\r\nimport com.vaadin.flow.component.html.Div;\r\nimport lombok.Getter;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\npublic class RoleChanger extends Div {\r\n\r\n    private static final long serialVersionUID = 6236086318634166339L;\r\n\r\n    private @Getter ComboBox<Role> roleCombo = null;\r\n    private final Context ctx;\r\n\r\n    /**\r\n     * The RoleChanger function is used to change the role of a user.\r\n     *\r\n     * @param Context ctx Get the current session and to set the http_session attribute\r\n     * @return A combobox&lt;role&gt;\r\n     */\r\n    public RoleChanger(Context ctx) {\r\n        this.ctx = ctx;\r\n        ctx.put(CTXAttribute.HTTP_SESSION, ctx.getSession().getHttpSession());\r\n\r\n        roleCombo = new ComboBox<>();\r\n        roleCombo.setClearButtonVisible(true);\r\n        roleCombo.setVisible(false);\r\n        roleCombo.setReadOnly(true);\r\n        roleCombo.setLabel(getTranslation(TMS.ROLE_CHANGER, getLocale(), ctx));\r\n        CompUtils.addToolTip(ctx, roleCombo, TMS.ROLE_CHANGER_TOOLTIP);\r\n\r\n        roleCombo.setItemLabelGenerator(Role::getName);\r\n        roleCombo.addValueChangeListener(event -> {\r\n            CloseWithOption cDialog = new CloseWithOption(ctx);\r\n            cDialog.setCom(() -> {\r\n                ctx.putHttpAttribute(SessionParams.ACTIVE_ROLE, event.getValue());\r\n                LocalCustomer customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n                if (Objects.nonNull(customer))\r\n                    CompUtils.setSessionProjectByCustomer(ctx, customer);\r\n            });\r\n            cDialog.open();\r\n            cDialog.run();\r\n        });\r\n        add(roleCombo);\r\n        reload();\r\n    }\r\n\r\n    /**\r\n     * The reload function is called when the user clicks on the &quot;Reload&quot; button.\r\n     * It reloads all of the data in this view, and updates it to reflect any changes that may have been made by other users.\r\n     */\r\n    public void reload() {\r\n\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        List<Role> roles = ctx.getServices().getRoleService().findAllInUser(user);\r\n        if (Objects.nonNull(roles) && roles.size() > 1) {\r\n            roleCombo.setReadOnly(false);\r\n            roleCombo.setVisible(true);\r\n            roleCombo.setItems(roles);\r\n        }\r\n        if (Objects.nonNull(ctx.getUserSession())) {\r\n            Role current = ctx.getHttpAttribute(SessionParams.ACTIVE_ROLE);\r\n            if (!roles.isEmpty()) {\r\n                if (Objects.isNull(current)) {\r\n                    current = user.getRole();\r\n                }\r\n                roleCombo.setItems(roles);\r\n                roleCombo.setValue(current);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\RoleChanger.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\SpcComponent.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.vaadin.flow.component.customfield.CustomField;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.select.Select;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\npublic class SpcComponent\r\n        extends\r\n        CustomField<String> {\r\n\r\n    public static final String CONTAINS = \"contains\";\r\n    public static final String START_WITH = \"startWith\";\r\n    public static final String END_WITH = \"endWith\";\r\n    public static final String EQUALS = \"=\";\r\n    public static final String NOT_EQUALS = \"!=\";\r\n    public static final String LESSER_THAN = \"<\";\r\n    public static final String GREATER_THAN = \">\";\r\n    public static final String UNUSED = \"----\";\r\n\r\n    public String type;\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private final HorizontalLayout row = new HorizontalLayout();\r\n    private TextField txtFld = null;\r\n    private Select<String> optionsBox = null;\r\n    private String selectedOptions = CONTAINS;\r\n    private final Context ctx;\r\n\r\n    private final List<String> optionString = Arrays.asList(UNUSED, EQUALS, NOT_EQUALS, CONTAINS, START_WITH, END_WITH);\r\n    private final List<String> optionNumber = Arrays.asList(UNUSED, LESSER_THAN, GREATER_THAN, EQUALS, NOT_EQUALS, CONTAINS, START_WITH, END_WITH);\r\n\r\n    /**\r\n     * The SpcComponent function is a constructor for the SpcComponent class.\r\n     * It takes in three parameters: a Context, an id, and a type.\r\n     * The function sets the context to ctx, sets the type to type,\r\n     * calls setTxtFld with getTranslation(id), setId(id), and then calls setOptionsBox().\r\n     *\r\n     * @param Context ctx Get the translation of the id parameter\r\n     * @param String  id Set the text of the label\r\n     * @param String  type Determine the type of component to be created\r\n     * @return A row with a text field, button and options box\r\n     */\r\n    public SpcComponent(\r\n            Context ctx,\r\n            String id,\r\n            String type) {\r\n        this.ctx = ctx;\r\n        this.type = type;\r\n        setTxtFld1(getTranslation(id, getLocale(), ctx));\r\n        setId(id);\r\n        setOptionsBox();\r\n\r\n        CompUtils.removeMSP(row, \"MSP\");\r\n        row.getStyle().set(\"margin-top\", \"-0.5em\");\r\n        getElement().getStyle().set(\"margin-top\", \"-1.2em\");\r\n        add(row);\r\n    }\r\n\r\n    /**\r\n     * The setTxtFld1 function sets the label and text field for the first row of the form.\r\n     *\r\n     * @param String translationName Set the label of the row\r\n     */\r\n    private void setTxtFld1(String translationName) {\r\n        setLabel(translationName);\r\n        txtFld = new TextField();\r\n        txtFld.setWidth(\"10em\");\r\n\r\n        row.add(txtFld);\r\n    }\r\n\r\n    /**\r\n     * The setOptionsBox function sets the optionsBox to a new Select object.\r\n     * If the type is &quot;NUMBER&quot;, then it sets the items of optionsBox to optionNumber, which is an array of strings containing all possible search operators for numbers.\r\n     * Otherwise, it sets the items of optionsBox to optionString, which contains all possible search operators for strings.\r\n     * It then gives this select box a width and item label generator (which translates each operator into its respective language).\r\n     * Finally, it adds a value change listener that updates selectedOptions whenever there's been a change in value and clears txtFld if UNUSED\r\n     */\r\n    private void setOptionsBox() {\r\n        optionsBox = new Select<String>();\r\n        if (type.equals(\"NUMBER\"))\r\n            optionsBox.setItems(optionNumber);\r\n        else\r\n            optionsBox.setItems(optionString);\r\n\r\n        optionsBox.setWidth(\"6.0em\");\r\n        optionsBox.setItemLabelGenerator(item -> {\r\n            String sResult = \"\";\r\n            if (item.length() > 4) {\r\n                sResult = getTranslation(TMS.setSearchOption(item), getLocale(), ctx);\r\n            } else {\r\n                sResult = item;\r\n            }\r\n            return sResult;\r\n        });\r\n        optionsBox.setValue(CONTAINS);\r\n        optionsBox.addValueChangeListener(event -> {\r\n            if (Objects.nonNull(event.getValue())) {\r\n                selectedOptions = event.getValue();\r\n            } else {\r\n                selectedOptions = CONTAINS;\r\n            }\r\n            if (selectedOptions.equals(UNUSED)) {\r\n                txtFld.setValue(\"\");\r\n            } else {\r\n            }\r\n        });\r\n        row.add(optionsBox);\r\n    }\r\n\r\n    /**\r\n     * The reset function sets the selectedOptions variable to CONTAINS, and then\r\n     * sets the optionsBox's value to CONTAINS. This is done so that when a user\r\n     * clicks on &quot;Reset&quot; in the GUI, it will reset all of their selections back to\r\n     * default values.\r\n     */\r\n    public void reset() {\r\n        selectedOptions = CONTAINS;\r\n        optionsBox.setValue(CONTAINS);\r\n    }\r\n\r\n    /**\r\n     * The getSelectedOptions function returns the selectedOptions variable.\r\n     *\r\n     * @return The selected options as a string\r\n     */\r\n    public String getSelectedOptions() {\r\n        return selectedOptions;\r\n    }\r\n\r\n    /**\r\n     * The getValue function returns the value of the text field.\r\n     *\r\n     * @return The value of the text field\r\n     */\r\n    public String getValue() {\r\n        String value = txtFld.getValue();\r\n        if (Objects.isNull(value)) {\r\n            value = \"\";\r\n        }\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * The generateModelValue function is used to generate a string that will be stored in the model.\r\n     * The function takes the value of the optionsBox and concatenates it with a &quot;#&quot; character, then\r\n     * concatenates it with the value of txtFld. This allows for both values to be stored in one field\r\n     * within our database, which makes things easier when we want to retrieve them later on.\r\n     *\r\n     * @return The values of the text field and\r\n     */\r\n    @Override\r\n    protected String generateModelValue() {\r\n        return optionsBox.getValue() + \"#\" + txtFld.getValue();\r\n    }\r\n\r\n    /**\r\n     * The setPresentationValue function is used to set the value of the text field.\r\n     *\r\n     * @param String newPresentationValue Set the text of the textfield\r\n     */\r\n    @Override\r\n    protected void setPresentationValue(String newPresentationValue) {\r\n        if (newPresentationValue == null) {\r\n            txtFld = null;\r\n        }\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\SpcComponent.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\TabBox.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.TranslationProvider;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.SessionParams;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.progressbar.ProgressBar;\r\nimport com.vaadin.flow.component.tabs.Tab;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.provider.DataProvider;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\nimport com.vaadin.flow.function.ValueProvider;\r\nimport lombok.Data;\r\n\r\nimport java.util.Locale;\r\n\r\npublic @Data class TabBox<T> {\r\n    private Tab tab = null;\r\n    private Grid<T> grid = null;\r\n    private TextField searchField = new TextField();\r\n    private Paragraph foundArticle = new Paragraph(\"\");\r\n    private ProgressBar load = null;\r\n    private DownloadButton download;\r\n    private VerticalLayout layout;\r\n    private HorizontalLayout buttons = new HorizontalLayout();\r\n    private Context ctx;\r\n\r\n    /**\r\n     * The TabBox function creates a tabbed box that contains the preview image,\r\n     * download button, and metadata table.  The TabBox function is called by the\r\n     * PreviewBox function in order to create a complete preview box.  The TabBox\r\n     * function takes two arguments: (i) an array of strings containing the metadata; and (ii) an integer specifying which layer is being displayed.\r\n     *\r\n     * @param Context ctx Create the downloadbutton object\r\n     * @return A tabbox object\r\n     */\r\n    public TabBox(Context ctx) {\r\n        this.ctx = ctx;\r\n        download = new DownloadButton(ctx, TMS.PREVIEW_BOX_DOWNLOAD_TOOLTIP);\r\n    }\r\n\r\n    /**\r\n     * The setLayout function is used to set the layout of the GUI.\r\n     * It uses a GridPane object called grid, which is then populated with\r\n     * various nodes (buttons and text fields). The buttons are added to a HBox object called buttons,\r\n     * which is then added to the grid. The load button has its own HBox object because it needs more space than other buttons.\r\n     */\r\n    public void setLayout() {\r\n        buttons.add(searchField, download, foundArticle);\r\n        layout = buildLayout(grid, buttons, load);\r\n    }\r\n\r\n    /**\r\n     * The runFoundArticle function is a function that updates the foundArticle text field to display the number of articles in the grid.\r\n     */\r\n    public void runFoundArticle() {\r\n        foundArticle.setText(CompUtils.filterGridObjects(ctx, grid));\r\n    }\r\n\r\n    /**\r\n     * The getDataProvider function returns the data provider for the grid.\r\n     *\r\n     * @return The data provider for the grid\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public ListDataProvider<T> getDataProvider() {\r\n        return (ListDataProvider<T>) grid.getDataProvider();\r\n    }\r\n\r\n    /**\r\n     * The setDataProvider function is used to set the data provider for the grid.\r\n     *\r\n     * @param DataProvider&lt;T Set the data provider for the grid\r\n     * @param F&gt;             dataprovider Set the data provider for the grid\r\n     */\r\n    public <F> void setDataProvider(DataProvider<T, F> dataprovider) {\r\n        grid.setDataProvider(dataprovider);\r\n        runFoundArticle();\r\n    }\r\n\r\n    /**\r\n     * The buildLayout function is responsible for creating the layout of the grid and buttons.\r\n     *\r\n     * @param Grid&lt;?&gt;    grid Add the grid to the body layout\r\n     * @param HorizontalLayout buttonBay Add buttons to the layout\r\n     * @param ProgressBar      load Display the progress of a task\r\n     * @return A verticallayout\r\n     */\r\n    private VerticalLayout buildLayout(Grid<?> grid, HorizontalLayout buttonBay, ProgressBar load) {\r\n        VerticalLayout body = new VerticalLayout();\r\n        body.setSizeFull();\r\n        CompUtils.removeMSP(body, \"SP\");\r\n\r\n        buttonBay.setWidth(\"100%\");\r\n        buttonBay.setSpacing(true);\r\n        buttonBay.setPadding(false);\r\n\r\n        body.add(buttonBay, load, grid);\r\n\r\n        body.setVisible(false);\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * The setSearchField function is used to set the search field for a grid.\r\n     *\r\n     * @param ValueProvider&lt;T Get the value of a field in the object t\r\n     * @param V&gt;              provider Get the value of the field that is being searched\r\n     */\r\n    public <V> void setSearchField(ValueProvider<T, V> provider) {\r\n        Locale locale = ctx.getHttpAttribute(SessionParams.LOCALE);\r\n        TranslationProvider transService = ctx.getServices().getTranslationService();\r\n        searchField.setPlaceholder(transService.getTranslation(TMS.PREVIEW_SEARCH_PLACEHOLDER, locale, getCtx()));\r\n        searchField.addValueChangeListener(event -> {\r\n            ListDataProvider<T> listProvider = getDataProvider();\r\n            listProvider.setFilter(provider, value -> CompUtils.searchWithParameters(value, searchField));\r\n            setDataProvider(listProvider);\r\n        });\r\n\r\n\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\TabBox.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\TimeBox.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.vaadin.flow.component.customfield.CustomField;\r\nimport com.vaadin.flow.component.html.H3;\r\nimport lombok.Setter;\r\n\r\nimport java.time.LocalTime;\r\nimport java.time.format.DateTimeFormatter;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class TimeBox extends CustomField<String> {\r\n\r\n    private @Setter LocalTime start;\r\n    private @Setter LocalTime current;\r\n    private @Setter int maxItemNumber;\r\n\r\n    private final H3 text;\r\n\r\n    /**\r\n     * The TimeBox function is used to create a time box that will be displayed on the calendar.\r\n     *\r\n     * @param LocalTime start Set the start time of a timebox\r\n     * @param int       maxItemNumber Set the maxitemnumber variable\r\n     * @return A new timebox object\r\n     */\r\n    public TimeBox(LocalTime start, int maxItemNumber) {\r\n        this.maxItemNumber = maxItemNumber;\r\n        this.start = start;\r\n        text = new H3();\r\n        add(text);\r\n    }\r\n\r\n    /**\r\n     * The TimeBox function is a constructor for the TimeBox class. It takes in a LocalTime object and sets it as the start time of the TimeBox.\r\n     *\r\n     * @param LocalTime start Set the start time of the timebox\r\n     * @return A h3 element with the text &quot;timebox&quot;\r\n     */\r\n    public TimeBox(LocalTime start) {\r\n        this.start = start;\r\n        text = new H3();\r\n        add(text);\r\n    }\r\n\r\n    /**\r\n     * The TimeBox function is a constructor that creates a new TimeBox object.\r\n     * The TimeBox object contains an H3 element, which is used to display the time.\r\n     *\r\n     * @return A timebox object\r\n     */\r\n    public TimeBox() {\r\n        text = new H3();\r\n        add(text);\r\n    }\r\n\r\n    /**\r\n     * The setProgress function takes in an integer value and sets the progress bar to that value.\r\n     * It also updates the text field with a new estimated time of completion based on how much has been done so far.\r\n     *\r\n     * @param int done Calculate the estimated time remaining\r\n     */\r\n    public void setProgress(int done) {\r\n        current = LocalTime.now();\r\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"mm:ss\");\r\n        text.setText(\"( \" + getEstimatedTime(done).format(dtf) + \" / \" + getMaxTime().format(dtf) + \" )\");\r\n    }\r\n\r\n    /**\r\n     * The getEstimatedTime function takes the number of items that have been processed and returns an estimated time\r\n     * for how long it will take to process all of the items. It does this by taking the current time, subtracting from it\r\n     * the start time, dividing that difference by how many items have been processed so far (to get an average), then\r\n     * multiplying that average by how many more items there are to be processed. This gives us a rough estimate for\r\n     * when we can expect all of our work to be done. The function returns a LocalTime object with this information in it.\r\n     *\r\n     * @param int done Calculate the estimated time\r\n     * @return The estimated time of completion\r\n     */\r\n    private LocalTime getEstimatedTime(int done) {\r\n        long nanoSec = 0;\r\n        nanoSec = current.getNano() - (long) start.getNano();\r\n        if (done > 1 && nanoSec > 0) {\r\n            nanoSec = nanoSec / done;\r\n        } else {\r\n            nanoSec = 1;\r\n        }\r\n        nanoSec = nanoSec * (maxItemNumber - done);\r\n        return LocalTime.ofNanoOfDay(nanoSec);\r\n    }\r\n\r\n    private LocalTime getMaxTime() {\r\n        long nanoSec = 0;\r\n        nanoSec = current.getNano() - (long) start.getNano();\r\n        nanoSec = nanoSec * maxItemNumber;\r\n        return LocalTime.ofNanoOfDay(nanoSec);\r\n    }\r\n\r\n\r\n    /**\r\n     * The generateModelValue function is used to generate a string that will be stored in the model.\r\n     * This function is called when the user presses enter or clicks on another cell.\r\n     * The text field's value is returned as a string and stored in the model.\r\n     *\r\n     * @return A string, so the generateviewvalue function must return a string\r\n     */\r\n    @Override\r\n    protected String generateModelValue() {\r\n        return text.getText();\r\n    }\r\n\r\n    /**\r\n     * The setPresentationValue function is called by the superclass, and it sets the text of this\r\n     * TextField to be equal to newPresentationValue.\r\n     *\r\n     * @param String newPresentationValue Set the text of the text field\r\n     */\r\n    @Override\r\n    protected void setPresentationValue(String newPresentationValue) {\r\n        text.setText(newPresentationValue);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\TimeBox.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\TitleMap.java =====\n```\npackage com.hom.ebmw.view.components;\r\n\r\nimport com.vaadin.flow.component.Component;\r\nimport com.vaadin.flow.component.HasEnabled;\r\nimport com.vaadin.flow.component.Synchronize;\r\nimport com.vaadin.flow.component.Tag;\r\n\r\n@SuppressWarnings(\"serial\")\r\n@Tag(\"hom-title-map\")\r\npublic class TitleMap extends Component implements HasEnabled {\r\n\r\n    /**\r\n     * The TitleMap function takes a string and returns the same string with the first letter of each word capitalized.\r\n     *\r\n     * @param String value Set the value of the titlemap\r\n     * @return The value of the titlemap variable\r\n     */\r\n    public TitleMap(String value) {\r\n        setValue(value);\r\n    }\r\n\r\n    /**\r\n     * The getValue function returns the value of the input element.\r\n     *\r\n     * @return The value of the input field\r\n     */\r\n    @Synchronize(\"change\")\r\n    public String getValue() {\r\n        return getElement().getProperty(\"value\");\r\n    }\r\n\r\n    /**\r\n     * The setValue function sets the value of the input field.\r\n     *\r\n     * @param String value Set the value of the input element\r\n     */\r\n    public void setValue(String value) {\r\n        getElement().setProperty(\"value\", value);\r\n    }\r\n\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\components\\TitleMap.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\dialogs\\CrumbProgressDialog.java =====\n```\npackage com.hom.ebmw.view.dialogs;\r\n\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.configuration.security.SessionUtils;\r\nimport com.hom.ebmw.exceptions.ArticleBaseQueueException;\r\nimport com.hom.ebmw.exceptions.DoubleFoundException;\r\nimport com.hom.ebmw.exceptions.ParameterException;\r\nimport com.hom.ebmw.jpa.dao.impl.ArticleBaseRepository;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.*;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.hom.ebmw.utilities.interfaces.HasPermission;\r\nimport com.hom.ebmw.view.components.BreadBox;\r\nimport com.hom.ebmw.view.components.Crumb;\r\nimport com.hom.ebmw.view.sortment.subview.InfoBox;\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.component.dialog.Dialog;\r\nimport com.vaadin.flow.component.html.H2;\r\nimport com.vaadin.flow.component.html.Image;\r\nimport com.vaadin.flow.component.notification.Notification;\r\nimport com.vaadin.flow.component.notification.Notification.Position;\r\nimport com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.progressbar.ProgressBar;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.File;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class CrumbProgressDialog extends Dialog implements HasPermission {\r\n\r\n    private final @Getter List<ArticleBase> articles = new ArrayList<>();\r\n    private final @Getter List<ArticleBase> positives = new ArrayList<>();\r\n    private final Map<String, Boolean> progressMap = new HashMap<>();\r\n\r\n    private final H2 label = new H2();\r\n    private final VerticalLayout body = new VerticalLayout();\r\n    private final VerticalLayout progressMinMax = new VerticalLayout();\r\n    private ProgressBar progress = new ProgressBar();\r\n    private @Setter Image interDim = null;\r\n    private final Map<String, ProgressBar> importBars = new HashMap<>();\r\n    private @Getter\r\n    @Setter Exception thrower = null;\r\n    private final Context ctx;\r\n    private final Locale locale;\r\n    private UI ui;\r\n    private final @Getter AstNotification notify;\r\n\r\n\r\n    /**\r\n     * The CrumbProgressDialog function is a constructor for the CrumbProgressDialog class.\r\n     * It initializes the following variables:\r\n     * notify, ctx, ui, locale.\r\n     *\r\n     * @param Context ctx Get the current session and locale\r\n     * @return A crumbprogressdialog object\r\n     */\r\n    public CrumbProgressDialog(Context ctx) {\r\n\r\n        notify = new AstNotification(ctx);\r\n        this.ctx = ctx;\r\n        setInterDim(getInterDim(ctx));\r\n        ui = UI.getCurrent();\r\n        if (Objects.isNull(ui)) {\r\n            ui = ctx.getUserSession().get(Params.ACTIVE_UI);\r\n            UI.setCurrent(ui);\r\n        }\r\n\r\n        if (Objects.isNull(ctx)) {\r\n            log.error(\"Context is NULL\");\r\n        } else if (Objects.isNull(ctx.getSession())) {\r\n            log.error(\"Session in Context is NULL\");\r\n        } else if (Objects.isNull(ctx.getSession().getLocale(getCtx()))) {\r\n            log.error(\"Locale in Context is NULL\");\r\n        }\r\n\r\n        this.locale = ctx.getSession().getLocale(getCtx());\r\n        init();\r\n\r\n        setCloseOnEsc(false);\r\n        setCloseOnOutsideClick(false);\r\n    }\r\n\r\n    /**\r\n     * The getInterDim function returns the intermediate dimension of a given image.\r\n     * The intermediate dimension is defined as the largest possible square that can be inscribed in an image.\r\n     *\r\n     * @param Context ctx Get the current context of the application\r\n     * @return The image which is the result of\r\n     */\r\n    private Image getInterDim(Context ctx) {\r\n        return CompUtils.getInterDim(ctx);\r\n    }\r\n\r\n    /**\r\n     * The getServices function returns the Services object that is used to access\r\n     * all of the services provided by this application.\r\n     *\r\n     * @return The services object\r\n     */\r\n    public Services getServices() {\r\n        return ctx.getServices();\r\n    }\r\n\r\n    /**\r\n     * The getSession function returns the session object for this context.\r\n     *\r\n     * @return A sessionutils object\r\n     */\r\n    public SessionUtils getSession() {\r\n        return ctx.getSession();\r\n    }\r\n\r\n    /**\r\n     * The getCtx function returns the context of the application.\r\n     *\r\n     * @return The context of the activity\r\n     */\r\n    public Context getCtx() {\r\n        return ctx;\r\n    }\r\n\r\n    /**\r\n     * The createDummy function creates a dummy progress bar that is not visible.\r\n     * This function is used to create the initial progress bars in the GUI, which are then replaced by real ones when needed.\r\n     *\r\n     * @return A progressbar with the value 0\r\n     */\r\n    private ProgressBar createDummy() {\r\n        ProgressBar progressBar = new ProgressBar();\r\n        progressBar.setIndeterminate(false);\r\n        progressBar.setValue(0.0);\r\n        progressBar.setVisible(false);\r\n        return progressBar;\r\n    }\r\n\r\n    /**\r\n     * The initImportBars function initializes the importBars HashMap with a dummy JProgressBar.\r\n     * The function also adds the dummy JProgressBar to an ArrayList of JProgressBars called progressMinMax.\r\n     */\r\n    private void initImportBars() {\r\n        String count = getServices().getProperty().getTempAssortments();\r\n        int anz = Parse.toInt(count);\r\n        importBars.put(Table.MAIN, createDummy());\r\n        progressMinMax.add(importBars.get(Table.MAIN));\r\n        for (int i = 1; i < anz; i++) {\r\n            String key = Table.getTemp(i);\r\n            importBars.put(key, createDummy());\r\n            progressMinMax.add(importBars.get(key));\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The init function is used to initialize the progress bar.\r\n     * It sets the width and height of the progress bar, as well as its visibility.\r\n     */\r\n    public void init() {\r\n        HorizontalLayout header = new HorizontalLayout();\r\n        header.add(label);\r\n\r\n        CompUtils.removeMSP(body, \"MSP\");\r\n        setWidth(\"50%\");\r\n        setMinWidth(\"30%\");\r\n        setMaxWidth(\"50%\");\r\n\r\n        initImportBars();\r\n\r\n        interDim.setVisible(true);\r\n        interDim.setWidth(\"10%\");\r\n        interDim.setHeight(\"10%\");\r\n        body.add(header, interDim, progressMinMax);\r\n        body.setAlignItems(Alignment.CENTER);\r\n        add(body);\r\n    }\r\n\r\n    /**\r\n     * The setLabel function is used to set the label of a component.\r\n     *\r\n     * @param String label Set the text of the label\r\n     * @param Locale locale Set the locale of the label\r\n     */\r\n    public void setLabel(String label, Locale locale) {\r\n        ui.access(() -> {\r\n            this.label.setVisible(true);\r\n            String value = getTranslation(label, locale, getCtx());\r\n            this.label.setText(value);\r\n            log.info(value);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setLabel function is used to set the label of a component.\r\n     *\r\n     * @param String label Set the text of the label\r\n     * @param Locale locale Get the translation of the label\r\n     * @param String description Add a description to the label\r\n     */\r\n    public void setLabel(String label, Locale locale, String description) {\r\n        ui.access(() -> {\r\n            this.label.setVisible(true);\r\n            String value = getTranslation(label, locale, getCtx()) + \"\\n\" + description;\r\n            this.label.setText(value);\r\n            log.info(value.replace(\"\\n\", \" - \"));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setLabelVisible function sets the visibility of the label.\r\n     *\r\n     * @param boolean isVisible Set the visibility of the label\r\n     */\r\n    public void setLabelVisible(boolean isVisible) {\r\n        ui.access(() ->\r\n                this.label.setVisible(isVisible)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The setLabel function is used to set the label of a component.\r\n     *\r\n     * @param String header1 Get the translation of the header\r\n     * @param String header2 Set the text of the label\r\n     * @param Locale locale Get the translation from the properties file\r\n     */\r\n    public void setLabel(String header1, String header2, Locale locale) {\r\n        ui.access(() -> {\r\n            this.label.setVisible(true);\r\n            String value1 = getTranslation(header1, locale, getCtx());\r\n            String value2 = getTranslation(header2, locale, getCtx());\r\n            this.label.setText(\"[\" + value1 + \"] \" + value2);\r\n            log.info(\"[\" + value1 + \"] \" + value2);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setLabel function sets the label of a button.\r\n     *\r\n     * @param String label Set the label of the button\r\n     */\r\n    public void setLabel(String label) {\r\n        setLabel(label, locale);\r\n    }\r\n\r\n    /**\r\n     * The setLabelDescription function sets the label and description for a given locale.\r\n     *\r\n     * @param String label Set the label of the field\r\n     * @param String description Set the description of the label\r\n     */\r\n    public void setLabelDescription(String label, String description) {\r\n        setLabel(label, locale, description);\r\n    }\r\n\r\n    /**\r\n     * The setLabel function sets the header of the table.\r\n     *\r\n     * @param String header1 Set the header of the first column\r\n     * @param String header2 Set the header of the second column\r\n     */\r\n    public void setLabel(String header1, String header2) {\r\n        setLabel(header1, header2, locale);\r\n    }\r\n\r\n    /**\r\n     * The nextBreadCrumb function is used to move the current breadcrumb forward one position in the list of breadcrumbs.\r\n     * This function is called when a user clicks on the &quot;Next&quot; button in a BreadBox.\r\n     */\r\n    protected void nextBreadCrumb() {\r\n        BreadBox box = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n        if (Objects.nonNull(box)) {\r\n            box.next();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The firstUIBreadCrumb function is called when the user clicks on a link in the first breadcrumb.\r\n     * It sets up the second breadcrumb and displays it, then calls setUpSecondBreadCrumb to set up\r\n     * all of its links.  The function also hides all of the other breadcrumbs and their links, so that\r\n     * only two are visible at any given time.  Finally, it calls updateUI to update everything else on\r\n     * screen (the table).\r\n     */\r\n    public void firstUIBreadCrumb() {\r\n        ui.access(this::firstBreadCrumb);\r\n    }\r\n\r\n    /**\r\n     * The gotoUIBreadCrumb function is used to navigate the user to a new page.\r\n     * It takes in a Crumb object, which contains information about the page that\r\n     * we want to navigate the user to. The function then gets an instance of BreadBox,\r\n     * which is essentially a stack of pages that have been visited by the user. The\r\n     * gotoNext method on this BreadBox object navigates us forward one step in our stack,\r\n     * and thus brings up our desired page for viewing by the user. This function also uses\r\n     * ui access so as not to cause any threading issues with Vaadin's UI\r\n     *\r\n     * @param Crumb crumb Get the next breadcrumb in the list\r\n     */\r\n    protected void gotoUIBreadCrumb(Crumb crumb) {\r\n        BreadBox box = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n        ui.access(() ->\r\n                box.gotoNext(crumb)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The lastUIBreadCrumb function is a helper function that calls the lastBreadCrumb\r\n     * function, but does so in the UI thread. This is necessary because we cannot\r\n     * call any Vaadin functions outside of the UI thread. The reason for this is that\r\n     * Vaadin uses a single-threaded model to ensure consistency and avoid race conditions.\r\n     */\r\n    protected void lastUIBreadCrumb() {\r\n        ui.access(this::lastBreadCrumb);\r\n    }\r\n\r\n    /**\r\n     * The nextUIBreadCrumb function is a helper function that calls the nextBreadCrumb\r\n     * function, but does so in the UI thread. This is necessary because we are using\r\n     * Vaadin to display our data, and it requires all changes to be made in its own thread.\r\n     */\r\n    protected void nextUIBreadCrumb() {\r\n        ui.access(this::nextBreadCrumb);\r\n    }\r\n\r\n    /**\r\n     * The firstBreadCrumb function is used to set the current breadcrumb in a BreadBox object\r\n     * to the first breadcrumb in that BreadBox. This function is called when a user clicks on\r\n     * the &quot;first&quot; button at the top of their screen, which will take them back to their home page.\r\n     */\r\n    protected void firstBreadCrumb() {\r\n        Object object = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n        if (Objects.nonNull(object) && object instanceof BreadBox) {\r\n            BreadBox box = (BreadBox) object;\r\n            box.first();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The lastBreadCrumb function is used to set the current breadcrumb in a BreadBox object\r\n     * to the last breadcrumb in that BreadBox. This function is called when a user clicks on\r\n     * the &quot;Last&quot; button at the bottom of any page, and it allows them to navigate back through\r\n     * their history of pages visited. The function first checks if there exists an active\r\n     * BreadBox object stored as part of this session's attributes, and then sets that\r\n     * BreadBox's current breadcrumb index (i) equal to its size - 1 (the last element). If no\r\n     * such attribute exists\r\n     */\r\n    protected void lastBreadCrumb() {\r\n        Object object = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n        if (Objects.nonNull(object) && object instanceof BreadBox) {\r\n            BreadBox box = (BreadBox) object;\r\n            box.last();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The isInstanceOfBreadBox function checks to see if the object stored in the user session\r\n     * is an instance of BreadBox. If it is, then we know that a breadbox has been created and\r\n     * can be used for further operations. This function returns true if there is a breadbox, false otherwise.\r\n     *\r\n     * @return True if the object is an instance of breadbox\r\n     */\r\n    protected boolean isInstanceOfBreadBox() {\r\n        Object object = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n        return object instanceof BreadBox;\r\n    }\r\n\r\n    /**\r\n     * The resetPushCount function is called when the user clicks on the &quot;Reset&quot; button.\r\n     * It resets the push count to zero, and also updates the UI with this new value.\r\n     */\r\n    protected void resetPushCount() {\r\n        Object object = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n        if (Objects.nonNull(object) && object instanceof BreadBox) {\r\n            BreadBox box = (BreadBox) object;\r\n            box.resetPrellCount();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The uiClose function is used to close the UI.\r\n     * It is called by the server when it wants to close the UI.\r\n     */\r\n    public void uiClose() {\r\n        ui.access(this::close);\r\n    }\r\n\r\n    /**\r\n     * The run function is the main function of this class. It starts a new thread\r\n     * and loads the assortment, reloads details, resets push count if it's an instance\r\n     * of BreadBox and closes the UI. If there are any exceptions thrown during this process,\r\n     * they will be caught here and handled accordingly. The exception handling is done by\r\n     * deleting all articles in AssortmentUtil (which deletes them from memory) and then calling\r\n     * firstUIBreadCrumb() which takes us back to where we started before loading anything into memory.\r\n     */\r\n    public void run() {\r\n        new Thread(() -> {\r\n            try {\r\n                load();\r\n                reloadDetails();\r\n                if (isInstanceOfBreadBox())\r\n                    resetPushCount();\r\n            } catch (DoubleFoundException | ParameterException e) {\r\n                notify.errorMessage(e);\r\n                AssortmentUtil.delete(ctx);\r\n                firstUIBreadCrumb();\r\n            } catch (ArticleBaseQueueException e) {\r\n                notify.errorPrintMessage(e.getLocalMessage(ctx));\r\n                AssortmentUtil.delete(ctx);\r\n                firstUIBreadCrumb();\r\n            } catch (Exception e) {\r\n                log.error(e.getClass().getSimpleName(), e);\r\n                AssortmentUtil.delete(ctx);\r\n                firstUIBreadCrumb();\r\n            }\r\n            uiClose();\r\n        }).start();\r\n    }\r\n\r\n    /**\r\n     * The execute function is the main function of this class. It loads the assortment,\r\n     * reloads its details and resets its push count if it's an instance of BreadBox.\r\n     */\r\n    public void execute() {\r\n        ui.access(() -> {\r\n            try {\r\n                load();\r\n                reloadDetails();\r\n                if (isInstanceOfBreadBox())\r\n                    resetPushCount();\r\n            } catch (DoubleFoundException | ParameterException e) {\r\n                notify.errorMessage(e.getMessage());\r\n                AssortmentUtil.delete(ctx);\r\n                firstUIBreadCrumb();\r\n                uiClose();\r\n            } catch (ArticleBaseQueueException e) {\r\n                notify.errorPrintMessage(e.getLocalMessage(ctx));\r\n                AssortmentUtil.delete(ctx);\r\n                firstUIBreadCrumb();\r\n                uiClose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The load function is responsible for loading the data from the source into\r\n     * a format that can be used by the rest of this program.  It should also\r\n     * perform any necessary validation on that data, and throw an exception if it\r\n     * fails to do so.  The load function should not return anything; instead, it\r\n     * should store its results in instance variables which are accessible to other functions.\r\n     */\r\n    protected void load() throws DoubleFoundException, ArticleBaseQueueException, ParameterException {\r\n        log.debug(\"Init loader\");\r\n    }\r\n\r\n    /**\r\n     * The setProgressMinMax function sets the minimum and maximum values of the progress bar.\r\n     *\r\n     * @param double min Set the minimum value of the progress bar\r\n     * @param double max Set the maximum value of the progress bar\r\n     */\r\n    public void setProgressMinMax(double min, double max) {\r\n        ui.access(() -> {\r\n            progress.setMin(min);\r\n            progress.setMax(max);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setProgressVisible function sets the visibility of the progress bar.\r\n     *\r\n     * @param boolean visible Set the visibility of the progress bar\r\n     */\r\n    public void setProgressVisible(boolean visible) {\r\n        ui.access(() ->\r\n                body.setVisible(visible)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The setProgressReset function is used to reset the progress bar.\r\n     * It sets the progress bar to be indeterminate, which means that it will not have a set value.\r\n     */\r\n    public void setProgressReset() {\r\n        ui.access(() -> {\r\n            progress = new ProgressBar();\r\n            progress.setIndeterminate(true);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setValue function is used to set the value of a progress bar.\r\n     *\r\n     * @param double      min Set the value of the progress bar\r\n     * @param ProgressBar progress Set the value of the progress bar\r\n     */\r\n    public void setValue(double min, ProgressBar progress) {\r\n        ui.access(() ->\r\n                progress.setValue(min)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The setValue function sets the value of the progress bar.\r\n     *\r\n     * @param double min Set the progress bar to a certain value\r\n     */\r\n    public void setValue(double min) {\r\n        ui.access(() ->\r\n                progress.setValue(min)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The deActiveIndeterminate function is used to deactivate the indeterminate progress bar.\r\n     * This function is called when the user clicks on a button that will cause an action to occur,\r\n     * and then again after that action has completed.  The first call hides the progress bar, and\r\n     * the second call shows it again.  This allows for a more fluid experience for users of this application.\r\n     */\r\n    public void deActiveIndeterminate() {\r\n        ui.access(() ->\r\n                interDim.setVisible(false)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The activeIndeterminate function is used to make the progress bar visible.\r\n     * It is called when a user clicks on the &quot;Start&quot; button in order to start\r\n     * processing data. The function makes the progress bar visible and sets its\r\n     * value to 0, which indicates that it has not yet started processing data.\r\n     */\r\n    public void activeIndeterminate() {\r\n        ui.access(() ->\r\n                interDim.setVisible(true)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The getDialogUI function returns the UI object that is used to display the dialog.\r\n     *\r\n     * @return The ui object\r\n     */\r\n    public UI getDialogUI() {\r\n        return ui;\r\n    }\r\n\r\n    /**\r\n     * The showUploadSuccess function is called when the upload of a file to the server has been successful.\r\n     * It displays a notification message on the screen, informing that the upload was successful.\r\n     */\r\n    public void showUploadSuccess() {\r\n        ui.access(() ->\r\n                Notification.show(getTranslation(TMS.UPLOAD_SUCCESSFUL, getLocale(), ctx), 5000, Position.MIDDLE)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The reloadDetails function is called when the user clicks on a new InfoBox.\r\n     * It reloads the details of that InfoBox, which are displayed in the DetailsPanel.\r\n     */\r\n    public void reloadDetails() {\r\n        ui.access(() -> {\r\n            InfoBox active = ctx.getUserSession().get(Params.ACTIVE_INFO_BOX);\r\n            if (Objects.nonNull(active))\r\n                active.reload();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The reloadCrumb function is used to update the breadcrumb bar at the top of\r\n     * the page. It is called whenever a new page is loaded, and it updates all of\r\n     * the buttons in that breadcrumb bar so that they are clickable and will take\r\n     * you back to their respective pages. This function also makes sure that only\r\n     * one button in each crumb can be clicked at a time, which prevents users from\r\n     * going back more than one step at a time. The reloadCrumb function also makes\r\n     * sure that if there are no previous pages (i.e., if you're\r\n     */\r\n    public void reloadCrumb() {\r\n        ui.access(() -> {\r\n            BreadBox box = ctx.getUserSession().get(Params.ACTIVE_BREADBOX);\r\n            box.getCurrent().reloadButtons();\r\n            box.getCurrent().reloadCrumb();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The clearTable function is used to clear the contents of a table.\r\n     *\r\n     * @param String table Get the table name from the activearticlebasetable map\r\n     */\r\n    public void clearTable(String table) {\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        getServices().getArticleBaseService().truncateArticleTable(tabSession.get(table));\r\n    }\r\n\r\n    /**\r\n     * The resetProgressMap function clears the progressMap HashMap.\r\n     */\r\n    public void resetProgressMap() {\r\n        progressMap.clear();\r\n    }\r\n\r\n    /**\r\n     * The importLists function is used to import a list of articles into the database.\r\n     * It takes in two parameters: a List of ArticleBase objects and the name of the table that they are being imported into.\r\n     * The function then creates a new thread, which splits up the list into smaller lists (of size 1000) and imports them one by one.\r\n     * After each import, it updates its progress bar accordingly so that users can see how far along it is in importing their data.\r\n     *\r\n     * @param List&lt;ArticleBase&gt; articles Pass a list of articlebase objects to the function\r\n     * @param String                  table Identify the progress bar that should be updated\r\n     */\r\n    public void importLists(List<ArticleBase> articles, String table) {\r\n        final ProgressBar progressBar = importBars.get(table);\r\n        ui.access(() -> {\r\n            progressBar.setVisible(true);\r\n            progressBar.setMin(0.0);\r\n            importBars.put(table, progressBar);\r\n            progressMap.put(table, Boolean.FALSE);\r\n        });\r\n        final ArticleBaseRepository artRepo = getServices().getArticleBaseService();\r\n        new Thread(() -> {\r\n            int partSize = 1000;\r\n            List<List<ArticleBase>> splitList = InternalUtils.listSplitter(articles, partSize);\r\n            progressBar.setMax(splitList.size() * 1.0);\r\n\r\n            for (int i = 0; i < splitList.size(); i++) {\r\n                setValue(i, importBars.get(table));\r\n                artRepo.insertIntoTable(ctx, splitList.get(i), table);\r\n            }\r\n            artRepo.updateGlobals(ctx, table);\r\n            progressMap.put(table, Boolean.TRUE);\r\n        }).start();\r\n    }\r\n\r\n\r\n    /**\r\n     * The waitOfImport function is used to wait for the import process to finish.\r\n     * It does this by checking if there are any false values in the progressMap, which indicates that an import is still running.\r\n     * If there are no false values, then all imports have finished and we can hide all of the progress bars and break out of the loop.\r\n     */\r\n    public void waitOfImport() {\r\n        while (true) {\r\n            InternalUtils.wait(500);\r\n            if (!progressMap.containsValue(Boolean.FALSE)) {\r\n                ui.access(() ->\r\n                        importBars.forEach((k, v) -> {\r\n                            v.setValue(0.0);\r\n                            v.setVisible(false);\r\n                        })\r\n                );\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The getSetting function is used to retrieve a setting from the database.\r\n     *\r\n     * @param SettingType type Get the setting value from the database\r\n     * @return A string\r\n     */\r\n    protected String getSetting(SettingType type) {\r\n        String result = \"\";\r\n        Optional<Setting> optSetting = getServices().getSettingCustomServices().findBySettingType(getCtx(), type);\r\n        if (optSetting.isPresent()) {\r\n            result = optSetting.get().getValue();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The resetCurrentAssortment function is used to reset the current assortment.\r\n     * It does this by first checking if there is an active assortment, and then checks if it has a name.\r\n     * If both of these conditions are met, then the function sets the deleteBy field to be equal to the current user's session ID and sets deleteOn equal to now (the time at which this function was called).\r\n     * Finally, it saves all changes made in order for them to take effect.\r\n     */\r\n    public void resetCurrentAssortment() {\r\n        Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        if (Objects.nonNull(assortment) && assortment.getName().isEmpty()) {\r\n            assortment.setDeleteBy(getCtx().getSession().getCurrentUser(getCtx()));\r\n            assortment.setDeleteOn(LocalDateTime.now());\r\n            getCtx().getServices().getAssortmentService().save(assortment);\r\n        }\r\n        reloadCrumb();\r\n    }\r\n\r\n    /**\r\n     * The getParameter function is a helper function that returns the value of a parameter\r\n     * from an AstFile object.  The parameter is specified by its name, and the file\r\n     * object must be provided as well.  If no such parameter exists in the file, then null\r\n     * will be returned.  This function can also return null if there was some error while trying to get\r\n     * the value of this particular parameter (for example, if it's not possible to convert it into an integer).\r\n     *\r\n     * @param FileParam                      param Identify the parameter to retrieve\r\n     * @param com.hom.ebmw.jpa.model.AstFile file Get the file name\r\n     * @return A generic object\r\n     */\r\n    public <E> E getParameter(FileParam param, com.hom.ebmw.jpa.model.AstFile file) {\r\n        return CompUtils.getParameter(getCtx(), param, file);\r\n    }\r\n\r\n    /**\r\n     * The setParameter function is used to set the value of a parameter in an AstFile.\r\n     *\r\n     * @param FileParam                      param Specify the parameter to be set\r\n     * @param E                              value Set the value of the parameter\r\n     * @param com.hom.ebmw.jpa.model.AstFile file Set the file name in the generated code\r\n     */\r\n    public <E> void setParameter(FileParam param, E value, com.hom.ebmw.jpa.model.AstFile file) {\r\n        CompUtils.setParameter(getCtx(), param, value, file);\r\n    }\r\n\r\n    /**\r\n     * The getStorage function returns the storage object for a given file.\r\n     *\r\n     * @param AstFile astFile Get the storage for a file\r\n     * @return The storage of the file\r\n     */\r\n    public Storage getStorage(AstFile astFile) {\r\n        return CompUtils.getStorage(getCtx(), astFile);\r\n    }\r\n\r\n    /**\r\n     * The saveStorage function saves the storage of a given AST file to a given source file.\r\n     *\r\n     * @param AstFile astFile Store the ast file\r\n     * @param File    srcFile Save the file\r\n     */\r\n    public void saveStorage(AstFile astFile, File srcFile) {\r\n        CompUtils.saveStorage(ctx, astFile, srcFile);\r\n    }\r\n\r\n    /**\r\n     * The getTranslation function is a helper function that returns the translation of a given key.\r\n     *\r\n     * @param String key Identify the translation to be returned\r\n     * @return The translation of the key\r\n     */\r\n    public String getTranslation(String key) {\r\n        return getTranslation(key, locale, ctx);\r\n    }\r\n\r\n    /**\r\n     * The getCurrentCustomerFilter function is used to retrieve the current customer filter for a given assortment.\r\n     * The function first checks if the user has permission to read from this class, and if so, it retrieves the customer number from either\r\n     * a parameter or an active local customer. It then uses these values along with other parameters (the type of object being filtered and\r\n     * role of the user) to find all filters that match these criteria in order to determine which one is currently active. If there are no\r\n     * matching filters or none are marked as active, then an empty optional will be returned; otherwise, it returns an optional containing\r\n     *\r\n     * @param Assortment assortment Get the customer number from the request\r\n     * @return An optional&lt;filter&gt; object\r\n     */\r\n    protected Optional<Filter> getCurrentCustomerFilter(Assortment assortment) {\r\n        User user = getSession().getCurrentUser(ctx);\r\n        if (getPermission(user, getServices(), this.getClass().getCanonicalName() + \".CustomerFilter\").isRead()) {\r\n            String customerNr = getParameter(FileParam.CUSTOMER_ID, assortment);\r\n            if (Objects.isNull(customerNr)) {\r\n                LocalCustomer localCustomer = getCtx().getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n                customerNr = localCustomer.getCustomerId();\r\n            }\r\n\r\n            ObjectType type = getCtx().getUserSession().get(Params.ACTIVE_TYPE);\r\n            Role role = getCtx().getSession().get(SessionParams.ACTIVE_ROLE);\r\n\r\n            List<CustomerFilter> cusFilter = getCtx().getServices().getCustomerFilterService().findAllByCustomerNrAndRoleAndDeleteByIsNullAndType(customerNr, role, type.getName());\r\n            Optional<CustomerFilter> optCusFilter = cusFilter.stream().filter(CustomerFilter::isActive).findFirst();\r\n            return optCusFilter.map(CustomerFilter::getFilter);\r\n        } else {\r\n            return Optional.empty();\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\dialogs\\CrumbProgressDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\dialogs\\CustomDialog.java =====\n```\npackage com.hom.ebmw.view.dialogs;\r\n\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.interfaces.Command;\r\nimport com.vaadin.flow.component.Component;\r\n\r\npublic class CustomDialog extends CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n    private Command com;\r\n\r\n    /**\r\n     * The CustomDialog function creates a custom dialog box that displays the\r\n     * message passed to it. The user can then click on the &quot;OK&quot; button to dismiss\r\n     * the dialog box.\r\n     *\r\n     * @param Context ctx Create a new instance of the customdialog class\r\n     * @return A dialog object\r\n     */\r\n    public CustomDialog(Context ctx) {\r\n        super(ctx);\r\n    }\r\n\r\n    /**\r\n     * The setCom function sets the Command object for this class.\r\n     *\r\n     * @param Command com Set the command object to be used when the button is pressed\r\n     */\r\n    public void setCom(Command com) {\r\n        this.com = com;\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the dialog is opened.\r\n     * It should be used to load data from the database and populate fields in the dialog.\r\n     */\r\n    @Override\r\n    protected void load() {\r\n        getDialogUI().access(() -> {\r\n            com.execute();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The add function adds a component to the dialog.\r\n     *\r\n     * @param Component... components Add multiple components to the dialog\r\n     */\r\n    @Override\r\n    public void add(Component... components) {\r\n        getDialogUI().access(() -> {\r\n            super.add(components);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The remove function removes the specified components from the dialog.\r\n     *\r\n     * @param Component... components Pass a variable number of arguments to the method\r\n     */\r\n    @Override\r\n    public void remove(Component... components) {\r\n        getDialogUI().access(() -> {\r\n            super.remove(components);\r\n        });\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\dialogs\\CustomDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\dialogs\\CustomerDialog.java =====\n```\npackage com.hom.ebmw.view.dialogs;\r\n\r\nimport com.hom.ebmw.ipim.model.Currency;\r\nimport com.hom.ebmw.ipim.model.Enumerator;\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.model.Territory;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.*;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.hom.ebmw.view.sortment.subview.CustomerLabelLayout;\r\nimport com.vaadin.flow.component.Component;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.combobox.ComboBox;\r\nimport com.vaadin.flow.component.dialog.Dialog;\r\nimport com.vaadin.flow.component.formlayout.FormLayout;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.textfield.TextArea;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.binder.Binder;\r\nimport com.vaadin.flow.data.binder.ValidationResult;\r\nimport com.vaadin.flow.data.binder.Validator;\r\nimport com.vaadin.flow.data.binder.ValueContext;\r\n\r\nimport java.io.File;\r\nimport java.util.*;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class CustomerDialog extends Dialog {\r\n\r\n    private final VerticalLayout body = new VerticalLayout();\r\n    private final HorizontalLayout buttons = new HorizontalLayout();\r\n\r\n    private final TextArea name = new TextArea();\r\n    private final TextField customerNr = new TextField();\r\n    private final TextField companyBranch = new TextField();\r\n    private final TextField eBusiness = new TextField();\r\n    private final TextField street = new TextField();\r\n    private final TextField postal = new TextField();\r\n    private final TextField city = new TextField();\r\n\r\n    private final ComboBox<Territory> country = new ComboBox<>();\r\n    private final ComboBox<Language> language = new ComboBox<>();\r\n    private final ComboBox<Territory> pricelist = new ComboBox<>();\r\n    private final ComboBox<Currency> currency = new ComboBox<>();\r\n\r\n    private final Paragraph header = CompUtils.createDialogHeader();\r\n\r\n    private List<Territory> countryLst = new ArrayList<>();\r\n    private List<Language> languageLst = new ArrayList<>();\r\n    private List<Currency> currencyLst = new ArrayList<>();\r\n\r\n    private final Button saveBtn = new Button();\r\n    private Button closeBtn;\r\n\r\n    private LocalCustomer customer = new LocalCustomer();\r\n    private final Binder<LocalCustomer> binder = new Binder<>();\r\n\r\n    private Context ctx = new Context();\r\n    private final CustomerLabelLayout layout;\r\n    private String praefix;\r\n    private final Setting globalPrefix;\r\n\r\n    /**\r\n     * The CustomerDialog function is a constructor for the CustomerDialog class.\r\n     * It initializes all of the fields in the dialog box, and sets their values to default.\r\n     *\r\n     * @param Context             ctx Get the services from the context\r\n     * @param CustomerLabelLayout layout Update the customer label in the customerlabellayout class\r\n     * @return A dialog\r\n     */\r\n    public CustomerDialog(Context ctx, CustomerLabelLayout layout) {\r\n        setId(\"customer-dialog\");\r\n        this.ctx = ctx;\r\n        this.layout = layout;\r\n\r\n        globalPrefix = SettingUtils.getSettingByType(ctx, SettingType.DEFAULT_CUSTOMER_PREFIX);\r\n\r\n        binder.setBean(new LocalCustomer());\r\n\r\n        countryLst = ctx.getServices().getEnumerationService().getAllTerritories();\r\n        languageLst = ctx.getServices().getEnumerationService().getAllLanguages();\r\n        languageLst.removeIf(lang -> lang.getKey().equals(\"-1\"));\r\n        currencyLst = ctx.getServices().getEnumerationService().getAllCurrencies();\r\n\r\n        body.removeAll();\r\n        body.add(header);\r\n        addToForm(name, TMS.CUSTOMER_NAME);\r\n        addToForm(customerNr, TMS.CUSTOMER_NR);\r\n        addToForm(companyBranch, TMS.CUSTOMER_BRANCH);\r\n        addToForm(eBusiness, TMS.CUSTOMER_E_BUSINESS);\r\n        addToForm(street, TMS.CUSTOMER_STREET);\r\n        addToForm(postal, TMS.CUSTOMER_POSTAL);\r\n        addToForm(city, TMS.CUSTOMER_CITY);\r\n        addToForm(country, TMS.CUSTOMER_COUNTRY);\r\n        addToForm(language, TMS.CUSTOMER_LANGUAGE);\r\n        addToForm(pricelist, TMS.CUSTOMER_PRICELIST);\r\n        addToForm(currency, TMS.CUSTOMER_CURRENCY);\r\n\r\n        loadBranchPraefix();\r\n        setCountry();\r\n        setCurrency();\r\n        setLanguage();\r\n        setPriceList();\r\n\r\n        setFieldWidth();\r\n\r\n        updateFields();\r\n        bindFields();\r\n\r\n        setResetBtn();\r\n\r\n        setFullWidth(customerNr, name, companyBranch, eBusiness, street, postal, city, country, language, pricelist,\r\n                currency);\r\n        body.add(buttons);\r\n        CompUtils.removeMSP(body, \"MSP\");\r\n\r\n        setSizeUndefined();\r\n        removeAll();\r\n\r\n        add(body);\r\n\r\n        setCloseOnEsc(false);\r\n        setCloseOnOutsideClick(false);\r\n    }\r\n\r\n    /**\r\n     * The isNotCustomerPrefixValid function checks if the prefix of a customer number is valid.\r\n     *\r\n     * @param String value Get the first 3 characters of the string\r\n     * @return True if the value is not valid\r\n     */\r\n    private boolean isNotCustomerPrefixValid(String value) {\r\n        loadBranchPraefix();\r\n        boolean valid = false;\r\n        String prefix = value.substring(0, 3);\r\n        if (praefix.equals(globalPrefix.getValue())) {\r\n            valid = !(praefix.equals(globalPrefix.getValue()) || Parse.toInt(prefix) != 0);\r\n        } else {\r\n            valid = !value.startsWith(praefix);\r\n        }\r\n\r\n        return valid;\r\n    }\r\n\r\n    /**\r\n     * The isNotCustomerAfterPrefixValid function checks if the value is a valid customer number.\r\n     *\r\n     * @param String value Check if the value is a valid customer number\r\n     * @return True if the value is not a valid customer\r\n     */\r\n    private boolean isNotCustomerAfterPrefixValid(String value) {\r\n        loadBranchPraefix();\r\n        String search = value;\r\n        String buffer = search.substring(0, 3);\r\n\r\n        if (Parse.toInt(buffer) == 0) {\r\n            search = search.replace(search.substring(0, 4), \"\");\r\n        } else {\r\n            search = search.replace(praefix + \"_\", \"\");\r\n        }\r\n\r\n        return Parse.toInt(search) == 0;\r\n    }\r\n\r\n    /**\r\n     * The validationCheck function is used to validate the input of a TextField.\r\n     * The function checks if the value is empty, if it contains any special characters and if it has more than 50 characters.\r\n     * If one of these conditions are met, an error message will be displayed in the UI.\r\n     *\r\n     * @param String       value Get the value of the field\r\n     * @param ValueContext context Get the current value of the field\r\n     * @return A validationresult object\r\n     */\r\n    private ValidationResult validationCheck(String value, ValueContext context) {\r\n        if (!value.isEmpty()) {\r\n            String search = value;\r\n            String buffer = search.substring(0, 3);\r\n\r\n            if (Parse.toInt(buffer) == 0) {\r\n                search = search.replace(search.substring(0, 4), \"\");\r\n            } else {\r\n                search = search.replace(praefix + \"_\", \"\");\r\n            }\r\n\r\n            String replacePattern = \"[ _.,;:!?&%$\\\"'=\\\\\\\\\\\\/\\\\]\\\\[\\\\|\\\\{\\\\}\\\\u200A\\\\u00a0\\\\u000a\\\\u000d\\\\u0d0a\\\\u0009]\";\r\n            String clearPattern = \"[_.,;:!?&%$\\\"'=\\\\ /][|{}]\";\r\n            search = search.replaceAll(replacePattern, \"XXallowedCharXX\");\r\n\r\n            if (search.contains(\"XXallowedCharXX\")) {\r\n                return ValidationResult\r\n                        .error(getTranslation(TMS.ERROR_VALIDATION_NOT_ALLOWED_CHARACTER, getLocale(), ctx)\r\n                                + clearPattern);\r\n            }\r\n            if (search.isEmpty()) {\r\n                return ValidationResult.error(getTranslation(TMS.ERROR_VALIDATION_NOT_EMPTY, getLocale(), ctx));\r\n            }\r\n            if (value.length() > 50) {\r\n                return ValidationResult\r\n                        .error(getTranslation(TMS.ERROR_VALIDATION_MORE_THAN_50_CHARACTER, getLocale(), ctx));\r\n            }\r\n            if (isNotCustomerPrefixValid(value)) {\r\n                return ValidationResult\r\n                        .error(getTranslation(TMS.ERROR_VALIDATION_PREFIX_NOT_VALID, getLocale(), ctx) + \"[\"\r\n                                + praefix + \"]\");\r\n            }\r\n            if (isNotCustomerAfterPrefixValid(value)) {\r\n                return ValidationResult\r\n                        .error(getTranslation(TMS.ERROR_VALIDATION_AFTER_PREFIX_NOT_VALID, getLocale(), ctx) + \"[\"\r\n                                + praefix + \"]\");\r\n            }\r\n            return ValidationResult.ok();\r\n        } else {\r\n            return ValidationResult.ok();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * The initLayout function is used to initialize the layout of the CustomerForm.\r\n     * It sets up a new customer or an existing one, depending on whether a customer object was passed in as an argument.\r\n     * If it's a new customer, then it will set up the form for creating a new one and bind all fields to their respective values.\r\n     * If it's an existing customer, then it will set up the form for editing that specific user and bind all fields to their respective values.\r\n     *\r\n     * @param Context       ctx Get the translation of the header text\r\n     * @param LocalCustomer customer Set the values of the fields in the form\r\n     */\r\n    public void initLayout(Context ctx, LocalCustomer customer) {\r\n        if (Objects.isNull(customer)) {\r\n            header.setText(getTranslation(TMS.TITLE_CUSTOMER_NEW, getLocale(), ctx));\r\n            customer = new LocalCustomer();\r\n            customerNr.setReadOnly(false);\r\n            setSaveBtn();\r\n            binder.forField(customerNr).withValidator(this::validationCheck)\r\n                    .bind(LocalCustomer::getCustomerId, LocalCustomer::setCustomerId);\r\n\r\n            binder.setBean(customer);\r\n        } else {\r\n            header.setText(getTranslation(TMS.TITLE_CUSTOMER_EDIT, getLocale(), ctx));\r\n            customerNr.setReadOnly(true);\r\n            clone(customer);\r\n            setUpdateBtn();\r\n            binder.setBean(customer);\r\n\r\n            customerNr.setReadOnly(true);\r\n            binder.forField(customerNr).bind(LocalCustomer::getCustomerId, LocalCustomer::setCustomerId);\r\n        }\r\n\r\n\r\n        if ((Objects.isNull(binder.getBean().getCustomerId()) || binder.getBean().getCustomerId().isEmpty()) && !globalPrefix.getValue().equals(praefix)) {\r\n            customerNr.setValue(praefix + \"_\");\r\n        }\r\n\r\n        buttons.removeAll();\r\n        buttons.add(saveBtn, closeBtn);\r\n    }\r\n\r\n    /**\r\n     * The loadBranchPraefix function is used to load the branch prefix from the user parameter.\r\n     * If no user parameter exists, it will use a global prefix instead.\r\n     */\r\n    private void loadBranchPraefix() {\r\n        Role role = UserParameterUtils.getParameter(ctx, UserParameterType.CUSTOMER_PREFIX, ctx.getSession().getCurrentUser(ctx));\r\n\r\n        if (Objects.nonNull(role))\r\n            praefix = role.getName();\r\n        else {\r\n            praefix = globalPrefix.getValue();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The addToForm function is used to add a field to the form.\r\n     *\r\n     * @param Component field Add the field to the form\r\n     * @param String    id Get the translation from the properties file\r\n     */\r\n    private void addToForm(Component field, String id) {\r\n        String label = getTranslation(id, getLocale(), ctx);\r\n\r\n        final FormLayout form = new FormLayout();\r\n        form.setId(id);\r\n\r\n        if (field instanceof TextField) {\r\n            TextField comp = (TextField) field;\r\n            comp.setRequiredIndicatorVisible(true);\r\n            comp.setRequired(true);\r\n            form.addFormItem(comp, label);\r\n        } else if (field instanceof TextArea) {\r\n            TextArea comp = (TextArea) field;\r\n            comp.setRequiredIndicatorVisible(true);\r\n            comp.setRequired(true);\r\n            form.addFormItem(comp, label);\r\n        } else {\r\n            ComboBox<?> comp = (ComboBox<?>) field;\r\n            comp.setClearButtonVisible(true);\r\n            comp.setRequiredIndicatorVisible(true);\r\n            comp.setRequired(true);\r\n            form.addFormItem(comp, label);\r\n        }\r\n\r\n        body.add(form);\r\n    }\r\n\r\n    /**\r\n     * The setFullWidth function sets the width of a component to 500px.\r\n     *\r\n     * @param Component... components Pass a variable number of arguments to the function\r\n     */\r\n    private void setFullWidth(Component... components) {\r\n        for (Component component : components) {\r\n            if (component instanceof TextField) {\r\n                TextField demo = (TextField) component;\r\n                demo.getStyle().set(\"width\", \"500px\");\r\n            }\r\n            if (component instanceof ComboBox<?>) {\r\n                ComboBox<?> demo = (ComboBox<?>) component;\r\n                demo.getStyle().set(\"width\", \"500px\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The setSaveBtn function sets the text of the saveBtn to &quot;Save&quot; and adds a click listener that validates\r\n     * the binder, checks if there is already a customer with that ID in the database, and creates a new customer\r\n     * if there isn't. If there is an existing customer with that ID, it displays an error message. It also reloads\r\n     * layout and closes this window after creating or displaying an error message.\r\n     */\r\n    private void setSaveBtn() {\r\n        saveBtn.setText(getTranslation(TMS.GLB_BUTTON_SAVE, getLocale(), ctx));\r\n        saveBtn.setId(TMS.GLB_BUTTON_SAVE);\r\n        saveBtn.addClickListener(event -> {\r\n            binder.validate();\r\n            if (binder.isValid()) {\r\n                Optional<LocalCustomer> optCustomer = ctx.getServices().getLocalCustomerService()\r\n                        .findByCustomerId((binder.getBean().getCustomerId()));\r\n\r\n                if (optCustomer.isPresent()) {\r\n                    AstNotification notify = new AstNotification(ctx);\r\n                    notify.errorMessage(getTranslation(TMS.ERROR_MSG_CUSTOMER_EXISTS, getLocale(), ctx));\r\n                } else {\r\n                    createCustomer(binder.getBean());\r\n                    layout.reload();\r\n                    this.close();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setUpdateBtn function is used to set the text of the saveBtn button to &quot;Update&quot; and\r\n     * add a click listener that validates the binder, uploads a customer file if it is valid,\r\n     * and closes this window.\r\n     */\r\n    private void setUpdateBtn() {\r\n        saveBtn.setText(getTranslation(TMS.GLB_BUTTON_UPDATE, getLocale(), ctx));\r\n        saveBtn.setId(TMS.GLB_BUTTON_UPDATE);\r\n        saveBtn.addClickListener(event -> {\r\n            binder.validate();\r\n            if (binder.isValid()) {\r\n                uploadCustomerFile(binder.getBean());\r\n                this.close();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setResetBtn function sets the reset button to clear all fields in the form.\r\n     */\r\n    private void setResetBtn() {\r\n        closeBtn = new Button(getTranslation(TMS.GLB_BUTTON_CLOSE, getLocale(), ctx));\r\n        closeBtn.setId(TMS.GLB_BUTTON_CLOSE);\r\n        closeBtn.addClickListener(event -> clearFields());\r\n    }\r\n\r\n    /**\r\n     * The setFieldWidth function sets the width of the fields to 100% and adds a value change listener\r\n     * that checks if the length of name is greater than 50. If it is, then it will set name to an empty string.\r\n     * The customerNr field also has a value change listener that sets its value to whatever was entered in by user.\r\n     */\r\n    private void setFieldWidth() {\r\n        name.setWidth(\"100%\");\r\n        name.addValueChangeListener(event -> {\r\n            if (event.getValue().length() > 50) {\r\n                name.setValue(\"\");\r\n            }\r\n        });\r\n        customerNr.setWidth(\"100%\");\r\n        customerNr.addValueChangeListener(event -> {\r\n            String value = event.getValue();\r\n            customerNr.setValue(value);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The updateFields function is used to update the fields of the form.\r\n     * It takes no parameters and returns nothing.\r\n     */\r\n    private void updateFields() {\r\n        if (customer == null) {\r\n            customer = new LocalCustomer();\r\n        }\r\n        binder.setBean(customer);\r\n    }\r\n\r\n    /**\r\n     * The clearFields function clears the fields of the customer object and closes\r\n     * the window.\r\n     */\r\n    private void clearFields() {\r\n        customer = new LocalCustomer();\r\n        updateFields();\r\n        close();\r\n    }\r\n\r\n    /**\r\n     * The createCustomer function is used to create a new customer.\r\n     *\r\n     * @param LocalCustomer customer Pass the customer object to the createcustomer function\r\n     */\r\n    private void createCustomer(LocalCustomer customer) {\r\n        uploadCustomerFile(customer);\r\n        customer = ctx.getServices().getLocalCustomerService().save(customer);\r\n        layout.getCustomerCbx().setValue(customer);\r\n        ctx.putHttpAttribute(SessionParams.ACTIVE_CUSTOMER, customer);\r\n        clearFields();\r\n    }\r\n\r\n    /**\r\n     * The setKeyLabel function is used to set the key and label of an enumerator.\r\n     *\r\n     * @param Enumerator item Get the key and label of the enumerator\r\n     * @return A string\r\n     */\r\n    private String setKeyLabel(Enumerator item) {\r\n        return item.getKey() + \" \" + item.getLabel();\r\n    }\r\n\r\n    /**\r\n     * The setCountry function sets the country field to a list of countries.\r\n     */\r\n    private void setCountry() {\r\n        country.setItems(countryLst);\r\n        country.setItemLabelGenerator(this::setKeyLabel);\r\n    }\r\n\r\n    /**\r\n     * The setCurrency function sets the currency dropdown menu to display the\r\n     * currencies in the currencyLst list. It also sets a label for each item in\r\n     * that list, which is displayed when an item is selected. The setKeyLabel\r\n     * function returns a string representation of each object in the list, which\r\n     * will be used as its label. This allows us to use objects other than strings\r\n     * as items in our dropdown menu (in this case, Currency objects). We can then\r\n     * access these objects later on by using their index number within the list.\r\n     */\r\n    private void setCurrency() {\r\n        currency.setItems(currencyLst);\r\n        currency.setItemLabelGenerator(this::setKeyLabel);\r\n    }\r\n\r\n    /**\r\n     * The setLanguage function sets the language dropdown menu to display a list of languages.\r\n     * The function also sets the item label generator for each item in the list, which is used to\r\n     * determine what text will be displayed for each option in the dropdown menu. In this case,\r\n     * we are displaying two-letter abbreviations of each language followed by its full name in that language.\r\n     */\r\n    private void setLanguage() {\r\n        language.setItems(languageLst);\r\n        language.setItemLabelGenerator(item -> item.getLabel().substring(0, 2) + \" \"\r\n                + Locale.forLanguageTag(item.getLabel()).getDisplayLanguage(getLocale()));\r\n    }\r\n\r\n    /**\r\n     * The setPriceList function sets the price list to be displayed in the UI.\r\n     */\r\n    private void setPriceList() {\r\n        pricelist.setItems(countryLst);\r\n        pricelist.setItemLabelGenerator(this::setKeyLabel);\r\n    }\r\n\r\n    /**\r\n     * The bindFields function binds the fields of the form to a LocalCustomer object.\r\n     * The bindFields function is called in the constructor of this class, and it uses\r\n     * binder.forField(field).withValidator((Validator&lt;String&gt;) (value, context) -&gt; isNullOrEmpty(value))\r\n     * .bind(LocalCustomer:getName, LocalCustomer:setName); to bind each field with its corresponding getter and setter method from\r\n     * the LocalCustomer class. This allows for easy access to all data entered into each field by using getters and setters from\r\n     * within other\r\n     */\r\n    private void bindFields() {\r\n        binder.forField(name).withValidator((Validator<String>) (value, context) -> isNullOrEmpty(value))\r\n                .bind(LocalCustomer::getName, LocalCustomer::setName);\r\n        binder.forField(companyBranch).withValidator((Validator<String>) (value, context) -> isNullOrEmpty(value))\r\n                .bind(LocalCustomer::getCompanyBranch, LocalCustomer::setCompanyBranch);\r\n        binder.forField(eBusiness).withValidator((Validator<String>) (value, context) -> isNullOrEmpty(value))\r\n                .bind(LocalCustomer::getEBusiness, LocalCustomer::setEBusiness);\r\n        binder.forField(street).withValidator((Validator<String>) (value, context) -> isNullOrEmpty(value))\r\n                .bind(LocalCustomer::getStreet, LocalCustomer::setStreet);\r\n        binder.forField(postal).withValidator((Validator<String>) (value, context) -> isNullOrEmpty(value))\r\n                .bind(LocalCustomer::getPostal, LocalCustomer::setPostal);\r\n        binder.forField(city).withValidator((Validator<String>) (value, context) -> isNullOrEmpty(value))\r\n                .bind(LocalCustomer::getCity, LocalCustomer::setCity);\r\n        binder.forField(country).withValidator((Validator<Territory>) (value, context) -> isNullOrEmpty(value)).bind(\r\n                item -> getValue(ctx.getServices().getEnumerationService().getAllTerritories(), item.getCountry()),\r\n                LocalCustomer::setCountryByEnum);\r\n        binder.forField(language).withValidator((Validator<Language>) (value, context) -> isNullOrEmpty(value)).bind(\r\n                item -> getValue(ctx.getServices().getEnumerationService().getAllLanguages(), item.getLanguage()),\r\n                LocalCustomer::setLanguageByEnum);\r\n        binder.forField(pricelist).withValidator((Validator<Territory>) (value, context) -> isNullOrEmpty(value)).bind(\r\n                item -> getValue(ctx.getServices().getEnumerationService().getAllTerritories(), item.getPricelist()),\r\n                LocalCustomer::setPricelistByEnum);\r\n        binder.forField(currency).withValidator((Validator<Currency>) (value, context) -> isNullOrEmpty(value)).bind(\r\n                item -> getValue(ctx.getServices().getEnumerationService().getAllCurrencies(), item.getCurrency()),\r\n                LocalCustomer::setCurrencyByEnum);\r\n    }\r\n\r\n    /**\r\n     * The isNullOrEmpty function checks if the value is null or empty.\r\n     *\r\n     * @param Object value Check if the value is null or empty\r\n     * @return Validationresult\r\n     */\r\n    private ValidationResult isNullOrEmpty(Object value) {\r\n        boolean isEmpty = false;\r\n        if (value instanceof String) {\r\n            String text = (String) value;\r\n            text = text.replace(\" \", \"\");\r\n            isEmpty = text.isEmpty();\r\n        }\r\n        if (Objects.isNull(value) || isEmpty) {\r\n            return ValidationResult.error(getTranslation(TMS.ERROR_VALIDATION_NOT_EMPTY, getLocale(), ctx));\r\n        }\r\n        return ValidationResult.ok();\r\n    }\r\n\r\n    /**\r\n     * The uploadCustomerFile function uploads the customer file to the server.\r\n     *\r\n     * @param LocalCustomer customer Get the customer id and file content\r\n     */\r\n    private void uploadCustomerFile(LocalCustomer customer) {\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        Optional<Setting> optSetting = ctx.getServices().getSettingCustomServices().findBySettingType(ctx,\r\n                SettingType.UPLOAD_FOLDER_CUSTOMER);\r\n        if (optSetting.isPresent()) {\r\n            String directory = SettingUtils.getTempFolder(ctx);\r\n            ctx.getUserSession().put(Params.ACTIVE_CUSTOMER, customer);\r\n            String fileName = ExportFileUtils.buildCustomerFileName(ctx);\r\n            File srcFile = ExportFileUtils.saveContentAsFile(directory + fileName, customer.getFileContent());\r\n            CustomerFile cFile = new CustomerFile();\r\n            cFile.setName(fileName);\r\n            cFile.setDate(user);\r\n            ctx.getServices().getCustomerService().save(cFile);\r\n            CompUtils.saveStorage(ctx, cFile, srcFile);\r\n            CompUtils.setParameter(ctx, FileParam.CUSTOMER_ID, customer.getCustomerId(), cFile);\r\n            FileUtils.copyFileTo(srcFile, new File(optSetting.get().getValue() + File.separator + fileName));\r\n\r\n        } else {\r\n            AstNotification notify = new AstNotification(ctx);\r\n            notify.errorMessage(getTranslation(TMS.ERROR_MSG_UPLOAD_PATH_NOT_FOUND, getLocale(), ctx));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The clone function is used to create a copy of the customer object.\r\n     * This is done so that we can make changes to the clone without affecting\r\n     * the original customer object.  The clone function will be called in \r\n     * order to create a new LocalCustomer object, which will then be passed into \r\n     * this class's constructor.  \r\n     *\r\n     * @param LocalCustomer customer Pass the customer object to the clone function\r\n     *\r\n\r\n     */\r\n    private void clone(LocalCustomer customer) {\r\n        this.customer = new LocalCustomer();\r\n        this.customer.setCity(customer.getCity());\r\n        this.customer.setCustomerId(customer.getCustomerId());\r\n        this.customer.setCompanyBranch(customer.getCompanyBranch());\r\n        this.customer.setCountry(customer.getCountry());\r\n        this.customer.setCurrency(customer.getCurrency());\r\n        this.customer.setEBusiness(customer.getEBusiness());\r\n        this.customer.setStreet(customer.getStreet());\r\n        this.customer.setPostal(customer.getPostal());\r\n        this.customer.setLanguage(customer.getLanguage());\r\n        this.customer.setPricelist(customer.getPricelist());\r\n        this.customer.setName(customer.getName());\r\n    }\r\n\r\n    /**\r\n     * The getValue function takes a list of enumerators and a string to compare.\r\n     * It then filters the list for any values that match the string, and returns\r\n     * an optional containing either the first matching value or null if no matches are found.\r\n     *\r\n     * @param List&lt;E&gt; collection Pass the list of enumerators to be searched\r\n     * @param String        toCompare Find the value in the collection\r\n     * @return An enumerator\r\n     */\r\n    private <E extends Enumerator> E getValue(List<E> collection, String toCompare) {\r\n        Optional<E> optEnum = collection.stream().filter(value -> value.getKey().equals(toCompare)).findFirst();\r\n        if (optEnum.isPresent()) {\r\n            return optEnum.get();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\dialogs\\CustomerDialog.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-gaszM3rbqep7aHCVaSdKX2kgIMVF1atR",
    "created" : 1762171408,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"multiple\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Hardcoded external JavaScript URLs in JiraIssueCollector\",\n      \"justification\": \"Loading scripts from external sources without validation opens XSS and supplychain attack surface; URLs are static strings making it impossible to configure or restrict in production.\",\n      \"action\": \"Externalize URLs to configuration, validate them against a whitelist, and load them via UI.getCurrent().getPage().addJavaScript only after verification; add unit tests for URL validation.\",\n      \"source\": \"JiraIssueCollector.loadReport(), line 49-55\",\n      \"component\": \"frontend-security\",\n      \"impact_scope\": \"sicherheitskritisch, produktiv relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential NPE in MyDialog.getPosition due to unsafe split handling\",\n      \"justification\": \"executeJs may return null or a string without a comma; split may have length <2 causing ArrayIndexOutOfBounds, leading to runtime crashes.\",\n      \"action\": \"Check for null and length before accessing split array; fallback to default Position or log error; add tests for empty and malformed style values.\",\n      \"source\": \"MyDialog.getPosition(), line 38-48\",\n      \"component\": \"ui-component\",\n      \"impact_scope\": \"prodrelevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"SpcComponent.setPresentationValue nullifies txtFld reference\",\n      \"justification\": \"Assigning txtFld = null loses the TextField instance, causing subsequent calls to generateModelValue or getValue to throw NPE.\",\n      \"action\": \"Do not set txtFld to null; instead clear its value with txtFld.clear(); add tests verifying component state after setPresentationValue(null).\",\n      \"source\": \"SpcComponent.setPresentationValue(), line 140-144\",\n      \"component\": \"ui-component\",\n      \"impact_scope\": null,\n      \"relations\": \"Duplicate of NPE risk in generateModelValue\",\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Unsynchronized access to progressMap and importBars in CrumbProgressDialog.importLists\",\n      \"justification\": \"Multiple threads modify shared maps without synchronization, risking race conditions and inconsistent UI state.\",\n      \"action\": \"Wrap map accesses in synchronized blocks or use ConcurrentHashMap; ensure UI updates are performed via ui.access; add concurrency unit tests.\",\n      \"source\": \"CrumbProgressDialog.importLists(), line 388-405\",\n      \"component\": \"background-processing\",\n      \"impact_scope\": \"performancekritisch\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Busywait loop in CrumbProgressDialog.waitOfImport\",\n      \"justification\": \"Infinite while(true) with Thread.sleep can block resources and lacks timeout; may lead to UI thread starvation if invoked incorrectly.\",\n      \"action\": \"Replace with a CompletableFuture or CountDownLatch that signals completion; add timeout handling; unit test for proper termination.\",\n      \"source\": \"CrumbProgressDialog.waitOfImport(), line 423-436\",\n      \"component\": \"background-processing\",\n      \"impact_scope\": \"performancekritisch\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"StringIndexOutOfBounds risk in CustomerDialog.validation methods\",\n      \"justification\": \"Methods isNotCustomerPrefixValid and isNotCustomerAfterPrefixValid call value.substring(0,3) without checking length, causing crashes on short inputs.\",\n      \"action\": \"Validate input length before substring; treat shorter strings as invalid and return appropriate ValidationResult; add tests for edgecase inputs (<3 chars).\",\n      \"source\": \"CustomerDialog.isNotCustomerPrefixValid(), line 122-133; CustomerDialog.isNotCustomerAfterPrefixValid(), line 137-148\",\n      \"component\": \"ui-validation\",\n      \"impact_scope\": \"prodrelevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Recursive value change listener in CustomerDialog.customerNr\",\n      \"justification\": \"Listener sets the same value it receives, which can cause an infinite loop or unnecessary UI updates.\",\n      \"action\": \"Remove the listener or only set value when transformation is needed; verify with UI tests that no recursion occurs.\",\n      \"source\": \"CustomerDialog.setFieldWidth(), line 219-224\",\n      \"component\": \"ui-component\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"BreadCrumble interface provides default methods that silently hide missing implementations\",\n      \"justification\": \"Default methods only log 'not implemented yet', making it easy to forget to implement required behavior and leading to silent failures.\",\n      \"action\": \"Convert to abstract methods or throw UnsupportedOperationException; add documentation to enforce implementation.\",\n      \"source\": \"BreadCrumble interface, lines 11-38\",\n      \"component\": \"architecture\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"TabBox.getDataProvider casts without null check\",\n      \"justification\": \"If grid is not initialized, getDataProvider() will cause NPE; also unchecked cast may cause ClassCastException.\",\n      \"action\": \"Add null guard and proper generic handling; unit test scenario where grid is null.\",\n      \"source\": \"TabBox.getDataProvider(), line 80-84\",\n      \"component\": \"ui-component\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"resetCurrentAssortment checks assortment.getName().isEmpty() without null check\",\n      \"justification\": \"If assortment.getName() returns null, NPE occurs; defensive coding needed.\",\n      \"action\": \"Check for null before calling isEmpty(); add test for null name case.\",\n      \"source\": \"CrumbProgressDialog.resetCurrentAssortment(), line 274-280\",\n      \"component\": \"business-logic\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Externalize and validate external script URLs in JiraIssueCollector.\",\n      \"Fix NPE and unsafe string handling in MyDialog and CustomerDialog validation.\",\n      \"Synchronize map access and UI updates in CrumbProgressDialog background threads.\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to produce JSON review for each file? The prompt says \"analyse jeweils einen Code-Chunk\". It gave many files. Probably need to output one JSON per file? But schema has \"file\" and \"issues\". Could combine all into one JSON? It says \"Deine Antwort MUSS exakt dieses JSON-Objekt\". So single object. Might need to summarize issues across all files? Could list issues across all files but file field maybe file name of chunk. Could set file as \"multiple\" or maybe list each? Probably we need separate JSON per file but instruction says single JSON object. Maybe we need to combine issues for each file into one array but include file path? Could set file as \"multiple\" but ambiguous.\n\nBetter to produce separate JSON objects for each file? But violates single JSON object rule. The rule says answer must be a single JSON object. So maybe we need to output an object with \"file\" being the chunk identifier (maybe path) and issues for that file. Since multiple files, maybe need separate calls per file. But prompt gave many files at once; maybe we should output a combined report with multiple entries? Could use top-level array? Not allowed. So likely they expect one report per file, but we need to choose one? The instruction: \"Du analysierst jeweils einen Code-Chunk.\" Might be per chunk, but they gave many chunks. Possibly we need to output for each file as separate object, but we can embed them in a list under \"reports\". But schema doesn't have that.\n\nThus maybe we should choose to output a summary for the entire set, with file set to \"multiple\" or null. Let's set file to \"multiple\". Provide issues referencing each file in source field.\n\nWe must not exceed 10 issues total. So pick top issues across codebase.\n\nIdentify major issues:\n\n1. BreadCrumble interface default methods just log \"not implemented\". Not a bug but maybe design issue: interface with default methods that hide missing implementations.\n\n2. JiraIssueCollector: hardcoded external URLs, possible security risk (loading remote scripts). Also page.addJavaScript may cause XSS if URL compromised. Also page may be null but handled. Also setUi method not used.\n\n3. MyDialog getPosition: uses executeJs returning string, splits by ',' but style values may contain commas? Also no null check for split length.\n\n4. RoleChanger: roleCombo is @Getter but initialized after ctx.put; roleCombo initially null then set. No NPE risk. In reload, roleCombo setReadOnly false etc but if roles null? Also uses ctx.getSession().getCurrentUser(ctx) without null checks.\n\n5. SpcComponent: setPresentationValue sets txtFld = null losing reference; should set value not null. Also generateModelValue may produce NullPointer if optionsBox null. Also setValue not handling null. Also optionString includes \"----\" maybe placeholder. Also getSelectedOptions returns raw value, no validation.\n\n6. TabBox: generic type T; getDataProvider casts without null check; setLayout uses buildLayout with load may be null (load not set). Also setSearchField uses getTranslation, but getLocale from ctx? getLocale method not defined? Might compile because inherits from component? Not sure.\n\n7. CrumbProgressDialog: many UI thread issues. In importLists, progressBar accessed from thread without UI access for UI updates (setVisible, setMax). Could cause concurrency issues. Also progressMap uses Boolean objects, but no synchronization; map accessed from multiple threads.\n\n8. CrumbProgressDialog.waitOfImport uses while(true) busy loop with InternalUtils.wait (likely Thread.sleep) but no timeout; could block UI thread if called from UI thread? It runs on UI thread? Not sure.\n\n9. CrumbProgressDialog.resetCurrentAssortment checks assortment.getName().isEmpty() but should check null.\n\n10. CustomerDialog: validation uses substring(0,3) without length check => possible StringIndexOutOfBounds for short inputs. Also isNotCustomerPrefixValid uses value.substring(0,3) similarly. Also loadBranchPraefix called many times. Also setFieldWidth adds listener that sets value back leading to infinite loop? customerNr.addValueChangeListener sets same value; could cause recursion.\n\nAlso possible NPE in bindFields: getValue may return null and binder expects non-null.\n\nSelect top 10.\n\nNow produce JSON.\n\nWe'll set file to \"multiple\".\n\nProvide issues list.\n\nLet's craft."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 2406,
      "prompt_tokens" : 20902,
      "total_tokens" : 23308
    },
    "timings" : {
      "cache_n" : 527,
      "prompt_n" : 20375,
      "prompt_ms" : 15225.163,
      "prompt_per_token_ms" : 0.747247263803681,
      "prompt_per_second" : 1338.2451143544408,
      "predicted_n" : 2406,
      "predicted_ms" : 28519.903,
      "predicted_per_token_ms" : 11.85365876974231,
      "predicted_per_second" : 84.36213825832438
    }
  }
}