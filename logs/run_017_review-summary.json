{
  "timestamp" : "2025-11-03T13:06:13.3338754",
  "index" : 17,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\FilterRemoveGrid.java =====\n```\npackage com.hom.ebmw.view.filter;\r\n\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.ExcelUtils;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.constans.ASTConst;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport com.hom.ebmw.view.components.DownloadButton;\r\nimport com.hom.ebmw.view.filter.service.GridLoader;\r\nimport com.vaadin.flow.component.Composite;\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.grid.Grid.SelectionMode;\r\nimport com.vaadin.flow.component.gridpro.GridPro;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.provider.DataProvider;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\nimport org.apache.commons.collections4.map.HashedMap;\r\nimport org.vaadin.gatanaso.MultiselectComboBox;\r\n\r\nimport java.util.*;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class FilterRemoveGrid\r\n        extends\r\n        Composite<VerticalLayout>\r\n        implements\r\n        GridLoader<ArticleBase> {\r\n\r\n    private GridPro<ArticleBase> grid = new GridPro<ArticleBase>();\r\n    private final TextField searchFld = new TextField();\r\n    private MultiselectComboBox<String> typeBox;\r\n    private DownloadButton downloadBtn = null;\r\n    private final Context ctx;\r\n    private final UI ui;\r\n\r\n    /**\r\n     * The FilterRemoveGrid function is a constructor that initializes the FilterRemoveGrid object.\r\n     *\r\n     * @param Context ctx Get the current context of the application\r\n     * @return A grid\r\n     */\r\n    public FilterRemoveGrid(\r\n            Context ctx) {\r\n        this.ctx = ctx;\r\n        initial();\r\n        ui = UI.getCurrent();\r\n    }\r\n\r\n    /**\r\n     * The initial function sets up the grid, search field, and multi-select box.\r\n     * It also calls the downloader function to set up a button that downloads\r\n     * data from the database. Finally it adds all of these components to a layout\r\n     * and removes margins from them so they are displayed properly on screen.\r\n     */\r\n    private void initial() {\r\n        setGrid();\r\n        setSearchFld();\r\n        setMulitBox();\r\n        downloader();\r\n\r\n        HorizontalLayout buttons = new HorizontalLayout();\r\n        buttons.add(searchFld, downloadBtn, typeBox);\r\n        CompUtils.removeMSP(buttons, \"MP\");\r\n\r\n        CompUtils.removeMSP(getContent(), \"MSP\");\r\n        getContent().add(buttons, grid);\r\n    }\r\n\r\n    /**\r\n     * The setSearchFld function sets the search field for the grid.\r\n     * It also adds a value change listener to it, which filters the data provider of the grid.\r\n     */\r\n    private void setSearchFld() {\r\n        searchFld.setPlaceholder(getTranslation(TMS.FILTER_GRID_SEARCH_PLACEHOLDER, getLocale(), ctx));\r\n        searchFld.addValueChangeListener(event -> {\r\n            @SuppressWarnings(\"unchecked\")\r\n            ListDataProvider<ArticleBase> listProvider = (ListDataProvider<ArticleBase>) grid.getDataProvider();\r\n            listProvider.setFilter(ArticleBase::getArticleNr, name -> {\r\n                String nameLower = name == null ? \"\" : name.toLowerCase(Locale.ENGLISH);\r\n                String filterLower = searchFld.getValue().toLowerCase(Locale.ENGLISH);\r\n                return nameLower.contains(filterLower);\r\n            });\r\n            grid.setDataProvider(listProvider);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setGrid function is used to set the grid for the article filter.\r\n     * The grid has three columns: ArticleNr, Comment and a column with an icon that shows if there are comments or not.\r\n     * The first two columns are sortable and resizable, while the third one is not.\r\n     */\r\n    private void setGrid() {\r\n        grid = new GridPro<ArticleBase>();\r\n        grid.addColumn(ArticleBase::getArticleNr)\r\n                .setHeader(getTranslation(TMS.FILTER_GRID_ARTICLE_NR, getLocale(), ctx))\r\n                .setResizable(true)\r\n                .setSortable(true)\r\n                .setKey(\"ArticleNr\");\r\n        grid.addComponentColumn(item -> CompUtils.addColumnToolTip(ctx, item.getComment(), ASTConst.EMPTY))\r\n                .setHeader(getTranslation(TMS.FILTER_GRID_COMMENT, getLocale(), ctx))\r\n                .setResizable(true)\r\n                .setSortable(true)\r\n                .setKey(\"Comment\");\r\n        grid.setSelectionMode(SelectionMode.MULTI);\r\n    }\r\n\r\n    /**\r\n     * The setMulitBox function is used to create a multiselect combobox that allows the user to filter\r\n     * the grid by selecting multiple types of articles. The function takes no parameters and returns nothing.\r\n     * It creates a new MultiselectComboBox object called typeBox, sets it in compact mode, and adds an event listener\r\n     * that filters the grid based on what types are selected in the combobox. The event listener first gets all of\r\n     * values from typeBox as a list of strings called values, then it gets all of the data from grid as a ListDataProvider&lt;ArticleBase&gt; object called list\r\n     */\r\n    private void setMulitBox() {\r\n        typeBox = new MultiselectComboBox<String>();\r\n        typeBox.setCompactMode(true);\r\n        typeBox.addValueChangeListener(event -> {\r\n            @SuppressWarnings(\"unchecked\")\r\n            ListDataProvider<ArticleBase> listProvider = (ListDataProvider<ArticleBase>) grid.getDataProvider();\r\n\r\n            List<String> values = new ArrayList<String>();\r\n            values.addAll(event.getValue());\r\n\r\n            listProvider.setFilter(ArticleBase::getComment, name -> {\r\n                final List<String> comments = new ArrayList<String>();\r\n                comments.addAll(Arrays.asList(name.split(\"#\")));\r\n                comments.removeIf(item -> item.equals(\"0\"));\r\n                comments.removeIf(item -> item.isEmpty());\r\n                values.forEach(type -> {\r\n                    String value = type;\r\n                    comments.removeIf(item -> item.contains(value));\r\n                });\r\n\r\n                return comments.size() == 0;\r\n            });\r\n\r\n            grid.setDataProvider(listProvider);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The downloader function is used to download the selected articles from the grid.\r\n     * It uses a ListDataProvider to get all of the items in the grid, and then adds them\r\n     * to an ArrayList. Then it creates a new DownloadButton object with its context and tooltip,\r\n     * which will be used for downloading. Finally, it calls on this button's download function\r\n     * with our list of articles as its parameter. This will cause all of these articles' files\r\n     * (if they have any) to be downloaded into their respective folders in our downloads directory!\r\n     */\r\n    private void downloader() {\r\n        @SuppressWarnings(\"unchecked\")\r\n        ListDataProvider<ArticleBase> dataProvider = (ListDataProvider<ArticleBase>) grid.getDataProvider();\r\n        List<ArticleBase> articles = new ArrayList<ArticleBase>();\r\n        downloadBtn = new DownloadButton(ctx, TMS.FILTER_REMOVE_DOWNLOAD_TOOLTIP);\r\n\r\n        articles.addAll(dataProvider.getItems());\r\n    }\r\n\r\n    /**\r\n     * reload = list\r\n     */\r\n    /**\r\n     * The reload function is called by the presenter to update the view.\r\n     * It takes a list of ArticleBase objects as an argument and updates\r\n     * the grid with this data. The download button is also updated, so that it can be used to download\r\n     * a file containing all of these articles in Excel format. Finally, it updates the typeBox component, which allows users to filter articles by their type (e.g., &quot;Article&quot;, &quot;Bundle&quot;).\r\n     *\r\n     * @param List&lt;ArticleBase&gt; list Reload the grid with the new data\r\n     */\r\n    @Override\r\n    public void reload(List<ArticleBase> list) {\r\n        ui.access(() -> {\r\n            if (!list.isEmpty()) {\r\n                downloadBtn.reloadAsFile(\r\n                        () -> \"Removed_\" + Parse.getTimeStamp() + \".xlsx\", () -> ExcelUtils.writeExcelFileOfArticleListPlain(ctx, list, ASTConst.DEFAULT, \"Removed\"));\r\n            }\r\n\r\n            list.sort((o1, o2) -> o1.getArticleNr().compareTo(o2.getArticleNr()));\r\n            grid.setDataProvider(DataProvider.ofCollection(list));\r\n\r\n            List<String> types = getValidTypes(list);\r\n            typeBox.setItems(types);\r\n\r\n            Set<String> setOfTypes = new HashSet<String>();\r\n            types.forEach(type -> setOfTypes.add(type));\r\n            typeBox.setValue(setOfTypes);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The getValidTypes function takes a list of ArticleBase objects and returns a list of strings.\r\n     * The function iterates through the given list, and for each item in the given list, it iterates\r\n     * through all possible filter types (as defined by FilterType enum). If an article contains any one\r\n     * of these filter types in its comment field, then that type is added to a buffer map. This ensures that\r\n     * only unique values are added to the buffer map. Once all items have been checked against all possible\r\n     * filter types, we add everything from our buffer map into our result arraylist (which will be returned\r\n     *\r\n     * @param List&lt;ArticleBase&gt; list Get the valid types from\r\n     * @return A list of strings\r\n     */\r\n    private List<String> getValidTypes(List<ArticleBase> list) {\r\n        Map<String, String> buffer = new HashedMap<String, String>();\r\n        List<String> result = new ArrayList<String>();\r\n        List<String> types = new ArrayList<String>();\r\n\r\n        for (FilterType type : FilterType.values()) {\r\n            types.add(type.name());\r\n        }\r\n\r\n        list.forEach(item -> {\r\n            types.forEach(type -> {\r\n                if (item.getComment().contains(type)) {\r\n                    buffer.put(type, type);\r\n                }\r\n            });\r\n        });\r\n\r\n        result.addAll(buffer.keySet());\r\n\r\n        result.sort((o1, o2) -> o1.compareTo(o2));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * reload = clear\r\n     */\r\n    /**\r\n     * The reload function is used to update the list of articles in the feed.\r\n     * It does this by first downloading a new copy of the RSS feed, and then\r\n     * parsing it into a list of ArticleBase objects.  The old article list is\r\n     * replaced with this new one, and any observers are notified that there has been an update.\r\n     */\r\n    @Override\r\n    public void reload() {\r\n        downloader();\r\n        reload(new ArrayList<ArticleBase>());\r\n    }\r\n\r\n    /**\r\n     * The getGrid function returns the grid object.\r\n     *\r\n     * @return A grid\r\n     */\r\n    @Override\r\n    public Grid<ArticleBase> getGrid() {\r\n        return grid;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\FilterRemoveGrid.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\FilterStructureGrid.java =====\n```\npackage com.hom.ebmw.view.filter;\r\n\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.Structure;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.SettingUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\nimport com.hom.ebmw.utilities.interfaces.Command;\r\nimport com.hom.ebmw.view.filter.service.GridLoader;\r\nimport com.vaadin.flow.component.Composite;\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.combobox.ComboBox;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.grid.Grid.SelectionMode;\r\nimport com.vaadin.flow.component.icon.VaadinIcon;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.progressbar.ProgressBar;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.provider.DataProvider;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Objects;\r\nimport java.util.concurrent.Callable;\r\n\r\n@Slf4j\r\n@SuppressWarnings(\"serial\")\r\npublic class FilterStructureGrid\r\n        extends\r\n        Composite<VerticalLayout>\r\n        implements\r\n        GridLoader<Filterbase> {\r\n    private Grid<Filterbase> filterBaseGrid;\r\n    private final List<String> structures = new ArrayList<String>();\r\n    private ComboBox<String> structureCbx;\r\n    private Button reloadBtn;\r\n    private final TextField fieldTxt = new TextField();\r\n    private String structureName;\r\n\r\n    private final UI ui;\r\n    private final ProgressBar progress;\r\n    private Callable<List<Filterbase>> executer = null;\r\n    private final Context ctx;\r\n\r\n    /**\r\n     * The FilterStructureGrid function is a constructor for the FilterStructureGrid class.\r\n     * It takes in a Context, Locale, and an array of ints as parameters.\r\n     * The function initializes the structures ArrayList with all structure names from the database.\r\n     * It also initializes progress to be a new ProgressBar object and sets it to invisible by default.\r\n     *\r\n     * @param Context ctx Get the services\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Filter the data by status\r\n     * @return A grid with the structure classifications\r\n     */\r\n    public FilterStructureGrid(\r\n            Context ctx,\r\n            Locale locale,\r\n            int... status) {\r\n        this.ctx = ctx;\r\n\r\n        List<Structure> structureSetting = SettingUtils.getAllSettingParameterValuesByType(ctx, SettingType.STRUCTURE_CLASS);\r\n        structureSetting.forEach(item -> structures.add(item.getName()));\r\n\r\n        progress = new ProgressBar();\r\n        progress.setVisible(false);\r\n\r\n        executer = () -> ctx.getServices().getFilterBaseDBService().getArticleStructureClassification(ctx, structureName, locale, status);\r\n\r\n        initial(true);\r\n        ui = UI.getCurrent();\r\n    }\r\n\r\n    /**\r\n     * The FilterStructureGrid function is a constructor for the FilterStructureGrid class.\r\n     * It takes in a Context, Locale, and Callable&lt;List&lt;Filterbase&gt;&gt; as parameters.\r\n     * The function initializes the structures list with all of the structure settings from SettingUtils.getAllSettingParameterValuesByType().\r\n     * It then sets up progress to be an invisible ProgressBar object and sets executer equal to its parameter value.  Finally it calls initial(false) and ui = UI.getCurrent().\r\n     *\r\n     * @param Context                                ctx Get the structure settings from the database\r\n     * @param Locale                                 locale Set the locale of the filter grid\r\n     * @param Callable&lt;List&lt;Filterbase&gt;&gt; executer Execute the filter\r\n     * @return The grid\r\n     */\r\n    public FilterStructureGrid(\r\n            Context ctx,\r\n            Locale locale,\r\n            Callable<List<Filterbase>> executer) {\r\n        this.ctx = ctx;\r\n        List<Structure> structureSetting = SettingUtils.getAllSettingParameterValuesByType(ctx, SettingType.STRUCTURE_CLASS);\r\n        structureSetting.forEach(item -> structures.add(item.getName()));\r\n\r\n        progress = new ProgressBar();\r\n        progress.setVisible(false);\r\n\r\n        this.executer = executer;\r\n        initial(false);\r\n        ui = UI.getCurrent();\r\n    }\r\n\r\n    /**\r\n     * The setStructureSelection function is used to create a ComboBox that allows the user to select\r\n     * which structure they would like to view. The ComboBox is populated with all of the structures\r\n     * in the database, and when one is selected, it will be displayed on screen. A refresh button has\r\n     * also been added so that if any changes are made while viewing a structure, they can be reloaded\r\n     * without having to reselect them from the dropdown menu. This function also sets up an event listener\r\n     * for when a new value has been selected from the dropdown menu so that it can update what's being shown\r\n     */\r\n    public void setStructureSelection() {\r\n        structureCbx = new ComboBox<String>();\r\n        structureCbx.setClearButtonVisible(true);\r\n        structureCbx.setItems(structures);\r\n\r\n        reloadBtn = new Button(VaadinIcon.REFRESH.create());\r\n        reloadBtn.addClickListener(event -> {\r\n            if (Objects.nonNull(structureCbx.getValue()) && !structureCbx.getValue().isEmpty()) {\r\n                structureName = structureCbx.getValue();\r\n                runInProgress(() -> reload());\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The initial function is used to set up the grid and its components.\r\n     * It sets the header of the grid, adds a column for each field in Filterbase,\r\n     * and sets up a search bar with buttons to filter by name or reset filters.\r\n     *\r\n     * @param boolean showChildCounts Determine whether to show the child count column in the grid\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public void initial(boolean showChildCounts) {\r\n        getContent().removeAll();\r\n        filterBaseGrid = new Grid<Filterbase>();\r\n\r\n        filterBaseGrid.addColumn(Filterbase::getLabel)\r\n                .setHeader(getTranslation(TMS.FILTER_GRID_NAME, getLocale(), ctx))\r\n                .setResizable(true)\r\n                .setFlexGrow(4);\r\n        if (showChildCounts) {\r\n            filterBaseGrid.addColumn(Filterbase::getChildCount)\r\n                    .setHeader(getTranslation(TMS.FILTER_GRID_ARTICLE_COUNT, getLocale(), ctx))\r\n                    .setResizable(true)\r\n                    .setFlexGrow(1);\r\n        }\r\n        filterBaseGrid.setSelectionMode(SelectionMode.MULTI);\r\n\r\n        fieldTxt.setPlaceholder(getTranslation(TMS.FILTER_GRID_SEARCH_PLACEHOLDER, getLocale(), ctx));\r\n        fieldTxt.addValueChangeListener(event -> {\r\n            ListDataProvider<Filterbase> listProvider = (ListDataProvider<Filterbase>) filterBaseGrid.getDataProvider();\r\n            listProvider.setFilter(Filterbase::getLabel, name -> {\r\n                String nameLower = (name == null ? \"\" : name.toLowerCase(Locale.ENGLISH));\r\n                String filterLower = event.getValue().toLowerCase(Locale.ENGLISH);\r\n                return nameLower.contains(filterLower);\r\n            });\r\n            filterBaseGrid.setDataProvider(listProvider);\r\n        });\r\n\r\n        Button searchBtn = new Button(getTranslation(TMS.GLB_BUTTON_SEARCH, getLocale(), ctx));\r\n        searchBtn.addClickListener(event -> {\r\n            ListDataProvider<Filterbase> listProvider = (ListDataProvider<Filterbase>) filterBaseGrid.getDataProvider();\r\n            listProvider.setFilter(Filterbase::getLabel, name -> {\r\n                String nameLower = (name == null ? \"\" : name.toLowerCase(Locale.ENGLISH));\r\n                String filterLower = fieldTxt.getValue().toLowerCase(Locale.ENGLISH);\r\n                return nameLower.contains(filterLower);\r\n            });\r\n            filterBaseGrid.setDataProvider(listProvider);\r\n        });\r\n\r\n        Button resetFilterBtn = new Button(getTranslation(TMS.GLB_BUTTON_SEARCH_RESET, getLocale(), ctx));\r\n        resetFilterBtn.addClickListener(event -> {\r\n            fieldTxt.setValue(\"\");\r\n            ListDataProvider<Filterbase> listProvider = (ListDataProvider<Filterbase>) filterBaseGrid.getDataProvider();\r\n            listProvider.clearFilters();\r\n            listProvider.refreshAll();\r\n        });\r\n\r\n        setStructureSelection();\r\n\r\n        HorizontalLayout header1 = new HorizontalLayout();\r\n        header1.add(structureCbx, reloadBtn);\r\n\r\n        CompUtils.removeMSP(header1, \"MSP\");\r\n\r\n        HorizontalLayout header2 = new HorizontalLayout();\r\n        header2.add(fieldTxt, searchBtn, resetFilterBtn);\r\n        CompUtils.removeMSP(header2, \"MSP\");\r\n\r\n        getContent().add(header1, header2, progress, filterBaseGrid);\r\n        CompUtils.removeMSP(getContent(), \"MP\");\r\n        getContent().setSizeFull();\r\n    }\r\n\r\n    /**\r\n     * The runInProgress function is used to run a command in the background while displaying a progress bar.\r\n     * This function takes one parameter, which is the Command that you want to execute.\r\n     * The Command must be an object of type com.vaadin.ui.Command, and it must have an execute() method defined for it (which will be called by this function).\r\n     *\r\n     * @param Command com Execute the command in a new thread\r\n     */\r\n    public void runInProgress(Command com) {\r\n        progress.setIndeterminate(true);\r\n        final UI ui = UI.getCurrent();\r\n        ui.access(() -> {\r\n            progress.setVisible(true);\r\n            filterBaseGrid.setVisible(false);\r\n        });\r\n        new Thread(() -> {\r\n            try {\r\n                ui.access(() -> {\r\n                    com.execute();\r\n                });\r\n            } catch (Exception e) {\r\n                log.error(e.getLocalizedMessage());\r\n                log.debug(e.toString());\r\n            }\r\n            ui.access(() -> {\r\n                progress.setVisible(false);\r\n                filterBaseGrid.setVisible(true);\r\n            });\r\n        }).start();\r\n    }\r\n\r\n\r\n    /**\r\n     * The reload function is used to update the data in the grid.\r\n     *\r\n     * @param List&lt;Filterbase&gt; list Get the list of filters that are to be displayed in the grid\r\n     */\r\n    @Override\r\n    public void reload(List<Filterbase> list) {\r\n        if (Objects.nonNull(structureCbx.getValue()) && !structureCbx.getValue().isEmpty()) {\r\n            filterBaseGrid.setDataProvider(DataProvider.ofCollection(sortByLabel(list)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The sortByLabel function takes a list of Filterbase objects and sorts them by their label.\r\n     *\r\n     * @param List&lt;Filterbase&gt; list Pass in the list of filters to be sorted\r\n     * @return A sorted list of filterbase objects\r\n     */\r\n    private List<Filterbase> sortByLabel(List<Filterbase> list) {\r\n        list.sort((o1, o2) -> o1.getLabel().compareTo(o2.getLabel()));\r\n        return list;\r\n    }\r\n\r\n\r\n    /**\r\n     * The reload function is used to update the data in the table.\r\n     * It takes a list of objects and uses reflection to get their fields,\r\n     * which are then added as columns. The rows are then filled with the values of those fields.\r\n     */\r\n    @Override\r\n    public void reload() {\r\n        ui.access(() -> {\r\n            try {\r\n                reload(executer.call());\r\n            } catch (Exception e) {\r\n                log.error(\"Could not Run Call\");\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The getStructureName function returns the name of the structure.\r\n     *\r\n     * @return The name of the structure\r\n     */\r\n    public String getStructureName() {\r\n        return structureName;\r\n    }\r\n\r\n    /**\r\n     * The getGrid function is used to return the grid that was created in the\r\n     * createGrid function. This allows for other classes to access this grid and\r\n     * use it as they see fit.\r\n     *\r\n     * @return A grid&lt;filterbase&gt; object\r\n     */\r\n    @Override\r\n    public Grid<Filterbase> getGrid() {\r\n        return filterBaseGrid;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\FilterStructureGrid.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\FilterZinfoGrid.java =====\n```\npackage com.hom.ebmw.view.filter;\r\n\r\nimport com.hom.ebmw.exceptions.ZinfoToLongException;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Zinfo;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.ZinfoTypeDetail;\r\nimport com.hom.ebmw.utilities.*;\r\nimport com.hom.ebmw.utilities.constans.ASTConst;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\nimport com.hom.ebmw.view.components.DownloadButton;\r\nimport com.hom.ebmw.view.components.ImageButton;\r\nimport com.hom.ebmw.view.dialogs.CustomDialog;\r\nimport com.hom.ebmw.view.filter.service.GridLoader;\r\nimport com.hom.ebmw.view.sortment.dialogs.DeleteZinfo;\r\nimport com.hom.ebmw.view.sortment.dialogs.SaveZinfo;\r\nimport com.vaadin.flow.component.Composite;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.checkbox.Checkbox;\r\nimport com.vaadin.flow.component.combobox.ComboBox;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.gridpro.GridPro;\r\nimport com.vaadin.flow.component.html.Label;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.icon.VaadinIcon;\r\nimport com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.provider.DataProvider;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\n\r\nimport java.util.*;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class FilterZinfoGrid extends Composite<VerticalLayout> implements GridLoader<Zinfo> {\r\n    private GridPro<Zinfo> zinfoGrid;\r\n    private List<ZinfoTypeDetail> details = null;\r\n    private ComboBox<ZinfoTypeDetail> typeCbx;\r\n    private Button reloadBtn;\r\n    private String type;\r\n    private final Context ctx;\r\n    private Paragraph labelTxt;\r\n    private Paragraph description;\r\n    private ImageButton saveBtn;\r\n    private DownloadButton downloadBtn;\r\n    private Checkbox showtoLong; // NewComments Bigger than 250 Char\r\n    private final Assortment assortment;\r\n\r\n    /**\r\n     * The FilterZinfoGrid function is used to filter the ZinfoGrid by a given assortment.\r\n     *\r\n     * @param Context    ctx Get the context of the activity\r\n     * @param Assortment assortment Get the assortment object from the main activity\r\n     * @return A list of zinfogrid objects\r\n     */\r\n    public FilterZinfoGrid(Context ctx, Assortment assortment) {\r\n        this.ctx = ctx;\r\n        this.assortment = assortment;\r\n        initial();\r\n    }\r\n\r\n    /**\r\n     * The setStructureSelection function is used to set the structure of the selection section.\r\n     * The selection section contains a ComboBox, which allows users to select from a list of ZinfoTypeDetail objects.\r\n     * The ComboBox also has an associated ValueChangeListener, which updates the description Paragraph object with information about the selected ZinfoTypeDetail object.\r\n     * There is also a Button that reloads all data in this view when clicked on by users.\r\n     */\r\n    public void setStructureSelection() {\r\n        description = new Paragraph();\r\n        typeCbx = new ComboBox<>();\r\n        typeCbx.setClearButtonVisible(true);\r\n        typeCbx.setItems(details);\r\n        typeCbx.setItemLabelGenerator(ZinfoTypeDetail::getType);\r\n        typeCbx.addValueChangeListener(event -> {\r\n            if (Objects.nonNull(event.getValue())) {\r\n                description.setText(event.getValue().getDescription().replace(\".#CR#Tag:\", \"\").replace(\".CRTag:\", \"\"));\r\n            }\r\n        });\r\n\r\n        reloadBtn = new Button(VaadinIcon.REFRESH.create());\r\n        reloadBtn.addClickListener(event -> {\r\n            type = null;\r\n            saveBtn.setEnabled(false);\r\n            if (Objects.nonNull(typeCbx.getValue())) {\r\n                saveBtn.setEnabled(true);\r\n                type = typeCbx.getValue().getType();\r\n                reload();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The initial function is used to set up the grid and its components.\r\n     * It sets up the header, which contains a combobox for selecting a structure,\r\n     * a reload button for refreshing the data in the grid,\r\n     * a save button for saving changes made to zinfo elements in database tables,\r\n     * and delete button that deletes selected zinfo elements from database tables.\r\n     */\r\n    public void initial() {\r\n        details = getZinfoTypeDetails();\r\n        getContent().removeAll();\r\n        zinfoGrid = new GridPro<>();\r\n\r\n        zinfoGrid.addColumn(Zinfo::getArticleNr).setSortable(true).setResizable(true)\r\n                .setHeader(getTranslation(TMS.ZINFO_GRID_ARTICLE_NR, getLocale(), ctx));\r\n        zinfoGrid.addColumn(Zinfo::getArticleDescription).setSortable(true).setResizable(true)\r\n                .setHeader(getTranslation(TMS.ZINFO_GRID_ARTICLE_DESCRIPTION, getLocale(), ctx));\r\n        zinfoGrid.addColumn(Zinfo::getPreview_comment).setSortable(true).setResizable(true)\r\n                .setHeader(getTranslation(TMS.ZINFO_GRID_DATABASE, getLocale(), ctx));\r\n        zinfoGrid.addEditColumn(Zinfo::getComment).text((item, newValue) -> {\r\n            item.setComment(newValue);\r\n            setFillStatus(getListDataProvider().getItems());\r\n        }).setSortable(true).setResizable(true).setHeader(getTranslation(TMS.ZINFO_GRID_INFO, getLocale(), ctx));\r\n\r\n        saveBtn = new ImageButton(CompUtils.getSaveFloppy(ctx), CompUtils.getDisableSaveFloppy(ctx));\r\n        if (Objects.isNull(type))\r\n            saveBtn.setEnabled(false);\r\n        saveBtn.addClickListener(event -> {\r\n            try {\r\n                @SuppressWarnings(\"unchecked\")\r\n                ListDataProvider<Zinfo> dataProvider = (ListDataProvider<Zinfo>) zinfoGrid.getDataProvider();\r\n                FilterUtils.checkIfCommentToLong(dataProvider.getItems(), 250);\r\n                SaveZinfo dialog = new SaveZinfo(ctx, zinfoGrid);\r\n                dialog.open();\r\n                dialog.run();\r\n            } catch (ZinfoToLongException e) {\r\n                showtoLong.setValue(true);\r\n                setToLongFilter(true);\r\n                AstNotification notify = new AstNotification(ctx);\r\n                notify.errorMessage(getTranslation(TMS.ERROR_MSG_ZINFO_CONTAINS_TO_LONG_ELEMENTS, getLocale(), ctx)\r\n                        + \": \" + e.getMessage());\r\n\r\n            }\r\n        });\r\n        Button deleteBtn = new Button(VaadinIcon.CLOSE.create());\r\n        deleteBtn.addClickListener(event -> {\r\n            DeleteZinfo dialog = new DeleteZinfo(ctx, this);\r\n            dialog.open();\r\n            dialog.run();\r\n        });\r\n\r\n        downloader(null);\r\n\r\n        TextField fieldTxt = new TextField();\r\n        fieldTxt.setPlaceholder(getTranslation(TMS.ZINFO_GRID_SEARCH_PLACEHOLDER, getLocale(), ctx));\r\n        fieldTxt.addValueChangeListener(event -> {\r\n            ListDataProvider<Zinfo> provider = getListDataProvider();\r\n            provider.setFilter(Zinfo::getArticleNr, name -> {\r\n                String nameLower = (name == null ? \"\" : name.toLowerCase(Locale.ENGLISH));\r\n                String filterLower = fieldTxt.getValue().toLowerCase(Locale.ENGLISH);\r\n                return nameLower.contains(filterLower);\r\n            });\r\n            zinfoGrid.setDataProvider(provider);\r\n        });\r\n\r\n        labelTxt = new Paragraph();\r\n\r\n        showtoLong = new Checkbox(getTranslation(TMS.ZINFO_GRID_CHECK_LENGTH, getLocale(), ctx));\r\n        showtoLong.addValueChangeListener(event -> setToLongFilter(event.getValue()));\r\n\r\n        setStructureSelection();\r\n        HorizontalLayout header = new HorizontalLayout();\r\n        Label empty = new Label();\r\n        empty.setWidth(\"10px\");\r\n        downloadBtn = new DownloadButton(ctx, TMS.ZINFO_GRID_DOWNLOAD_TOOLTIP);\r\n        header.add(typeCbx, reloadBtn, saveBtn, deleteBtn, downloadBtn, fieldTxt, empty, labelTxt, showtoLong);\r\n\r\n        CompUtils.removeMSP(header, \"MSP\");\r\n        header.setDefaultVerticalComponentAlignment(Alignment.CENTER);\r\n\r\n        getContent().add(header, description, zinfoGrid);\r\n\r\n        CompUtils.removeMSP(getContent(), \"MSP\");\r\n        getContent().setSizeFull();\r\n    }\r\n\r\n    /**\r\n     * The getListDataProvider function returns the ListDataProvider of Zinfo objects that is used to populate the Grid.\r\n     *\r\n     * @return A listdataprovider\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    private ListDataProvider<Zinfo> getListDataProvider() {\r\n        return (ListDataProvider<Zinfo>) zinfoGrid.getDataProvider();\r\n    }\r\n\r\n    /**\r\n     * The getZinfoTypeDetails function returns a list of ZinfoTypeDetail objects.\r\n     * The function first calls the getAllSettingParameterValuesByType method from the SettingUtils class,\r\n     * passing in ctx and SettingType.ECAT_ZINFO_DESCRIPTION as parameters. This returns a List&lt;ZinfoTypeDetail&gt; object, which is assigned to result.\r\n     * Then for each item in result, if item's description is empty (i.e., it has no value), then set its description to be equal to:\r\n     * getTranslation(TMS + &quot;-&quot; + item's type converted to lowercase +\r\n     *\r\n     * @return A list of zinfotypedetail objects\r\n     */\r\n    private List<ZinfoTypeDetail> getZinfoTypeDetails() {\r\n        List<ZinfoTypeDetail> result = SettingUtils.getAllSettingParameterValuesByType(ctx,\r\n                SettingType.ECAT_ZINFO_DESCRIPTION);\r\n        result.forEach(item -> {\r\n            if (item.getDescription().isEmpty()) {\r\n                item.setDescription(getTranslation(TMS.ZINFO + \"-\" + item.getType().toLowerCase() + \"-description\",\r\n                        getLocale(), ctx));\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The downloader function is responsible for downloading the file from the server.\r\n     * It takes a type parameter, which can be either &quot;zinfo&quot; or &quot;zinfo_all&quot;.\r\n     * The function then builds a filename based on this type and assortment.\r\n     * Then it downloads the file as an Excel spreadsheet with .xlsx extension.\r\n     *\r\n     * @param String type Determine the file name\r\n     */\r\n    private void downloader(String type) {\r\n        if (Objects.nonNull(type)) {\r\n            String name = ExportFileUtils.buildZinfoFileName(ctx, type, assortment);\r\n            String fileName = name.replace(\"txt\", \"xlsx\");\r\n\r\n            downloadBtn.reloadAsFile(() -> fileName, () -> ExcelUtils.writeZinfoFile(ctx, ASTConst.DEFAULT));\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * The reload function is used to reload the data in the grid.\r\n     * It takes a list of Zinfo objects as an argument, and if that list is empty, it will load all zinfos from the database.\r\n     * If there are any zinfos in that list, they will be loaded into the grid instead of loading them from the database.\r\n     * The function then sorts those zinfos by their article number before setting them as data for this grid's DataProvider object.\r\n     *\r\n     * @param List&lt;Zinfo&gt; list Pass the list of zinfo objects to the reload function\r\n     */\r\n    @Override\r\n    public void reload(List<Zinfo> list) {\r\n        if (Objects.nonNull(type)) {\r\n            CustomDialog dialog = new CustomDialog(ctx);\r\n            dialog.setCom(() -> {\r\n                dialog.setLabel(TMS.SET_DIALOG_LOAD_ZINFO);\r\n                List<Zinfo> zinfos = new ArrayList<>();\r\n                if (list.isEmpty()) {\r\n                    zinfos.addAll(ctx.getServices().getZinfoCustomerSerivce().getZinfos(ctx, type, getLocale()));\r\n                } else {\r\n                    zinfos.addAll(list);\r\n                }\r\n                ctx.getUserSession().put(Params.ACTIVE_ZINFO_GRID, zinfoGrid);\r\n                zinfos.sort((o1, o2) -> o1.getArticleNr().compareTo(o2.getArticleNr()));\r\n                zinfoGrid.setDataProvider(DataProvider.ofCollection(zinfos));\r\n                downloader(type);\r\n                setFillStatus(zinfos);\r\n            });\r\n            dialog.open();\r\n            dialog.run();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The setFillStatus function is used to set the text of the labelTxt component.\r\n     * The function takes a Collection&lt;Zinfo&gt; list as an argument and uses it to calculate\r\n     * how many items in the collection have comments, and how many do not. It then sets\r\n     * labelTxt's text property using this information, along with a translation string from\r\n     * TMS.ZINFO_GRID_FILLER_FROM_TO (which is defined in messages/messages-en-US). This allows us to display\r\n     * something like &quot;You've filled out 3 of 5 fields&quot; on\r\n     *\r\n     * @param Collection&lt;Zinfo&gt; list Get the size of the list and to iterate over it\r\n     */\r\n    private void setFillStatus(Collection<Zinfo> list) {\r\n        String text = getTranslation(TMS.ZINFO_GRID_FILLER_FROM_TO, getLocale(), ctx);\r\n        Map<String, Integer> fillStatus = new HashMap<>();\r\n        fillStatus.put(\"FILLED\", 0);\r\n        fillStatus.put(\"ALL\", list.size());\r\n        list.forEach(item -> {\r\n            if (Objects.nonNull(item.getComment()) && !item.getComment().isEmpty()) {\r\n                int value = fillStatus.get(\"FILLED\");\r\n                value += 1;\r\n                fillStatus.put(\"FILLED\", value);\r\n            }\r\n        });\r\n        labelTxt.setText(String.format(text, fillStatus.get(\"FILLED\"), fillStatus.get(\"ALL\")));\r\n    }\r\n\r\n    /**\r\n     * The setToLongFilter function is used to filter out the Zinfo objects that have a comment\r\n     * longer than 250 characters. The function takes in a boolean value as an argument, which\r\n     * determines whether or not the filter should be applied. If valid is true, then the function\r\n     * will check if any of the Zinfo objects in items has a comment longer than 250 characters and\r\n     * add them to e's list of zinfos. Then it will apply this list as a filter for dataProvider so\r\n     * that only those zinfos with comments too long are displayed on screen. If valid is false, then\r\n     *\r\n     * @param boolean valid Check if the filter should be applied or not\r\n     */\r\n    private void setToLongFilter(boolean valid) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        ListDataProvider<Zinfo> dataProvider = (ListDataProvider<Zinfo>) zinfoGrid.getDataProvider();\r\n        List<Zinfo> items = new ArrayList<>();\r\n        items.addAll(dataProvider.getItems());\r\n        if (valid) {\r\n            try {\r\n                FilterUtils.checkIfCommentToLong(items, 250);\r\n            } catch (ZinfoToLongException e) {\r\n                dataProvider.addFilter(Zinfo::getArticleNr, e.getZinfos()::contains);\r\n            }\r\n        } else {\r\n            dataProvider.clearFilters();\r\n        }\r\n        zinfoGrid.setDataProvider(dataProvider);\r\n    }\r\n\r\n\r\n    /**\r\n     * The reload function is used to reload the plugin.\r\n     * It will first unload the plugin, then load it again.\r\n     * This function is useful for when you want to make changes to your code without having to restart your server.\r\n     */\r\n    @Override\r\n    public void reload() {\r\n        reload(new ArrayList<>());\r\n    }\r\n\r\n    /**\r\n     * The getGrid function is used to return the grid that was created in the constructor.\r\n     * This function is called by the superclass, and it returns a Grid object.\r\n     *\r\n     * @return A grid&lt;zinfo&gt; object, which is a grid of zinfo objects\r\n     */\r\n    @Override\r\n    public Grid<Zinfo> getGrid() {\r\n        return zinfoGrid;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\FilterZinfoGrid.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\service\\GridLoader.java =====\n```\npackage com.hom.ebmw.view.filter.service;\r\n\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport org.springframework.lang.Nullable;\r\n\r\nimport java.util.List;\r\n\r\npublic interface GridLoader<T> {\r\n    void reload(@Nullable List<T> list);\r\n\r\n    void reload();\r\n\r\n    Grid<T> getGrid();\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\service\\GridLoader.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\StructureTreeFilterGrid.java =====\n```\npackage com.hom.ebmw.view.filter;\r\n\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.view.filter.service.GridLoader;\r\nimport com.vaadin.flow.component.Composite;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.grid.Grid.SelectionMode;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.treegrid.TreeGrid;\r\nimport com.vaadin.flow.data.provider.hierarchy.TreeData;\r\nimport com.vaadin.flow.data.provider.hierarchy.TreeDataProvider;\r\nimport com.vaadin.flow.data.selection.MultiSelect;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n@Slf4j\r\n@SuppressWarnings(\"serial\")\r\npublic class StructureTreeFilterGrid extends Composite<VerticalLayout> implements GridLoader<Filterbase> {\r\n    private TreeGrid<Filterbase> filterBaseGrid;\r\n    private final Context ctx;\r\n    private boolean showChilds = true;\r\n\r\n    /**\r\n     * The StructureTreeFilterGrid function is a constructor for the StructureTreeFilterGrid class.\r\n     * It initializes the grid and sets up all of its components.\r\n     *\r\n     * @param Context ctx Get the context of the activity\r\n     * @return A structuretreefiltergrid object\r\n     */\r\n    public StructureTreeFilterGrid(Context ctx) {\r\n        this.ctx = ctx;\r\n        initial();\r\n    }\r\n\r\n    /**\r\n     * The StructureTreeFilterGrid function initializes the grid and sets up the\r\n     * onClickListener for each button.\r\n     *\r\n     * @param Context ctx Get the context of the activity that is calling this class\r\n     * @param boolean showChilds Determine whether to show the childs of a node or not\r\n     * @return A grid of the structure tree\r\n     */\r\n    public StructureTreeFilterGrid(Context ctx, boolean showChilds) {\r\n        this.ctx = ctx;\r\n        this.showChilds = showChilds;\r\n        initial();\r\n    }\r\n\r\n    /**\r\n     * The initial function is used to initialize the filterBaseGrid.\r\n     * It adds a hierarchy column, which displays the name of each Filterbase object.\r\n     * If showChilds is true, it also adds a column that displays how many child objects each Filterbase has.\r\n     * The selection mode of the grid is set to MULTI and an expand listener is added so that when an item in the grid expands, its children are loaded and displayed as well.\r\n     */\r\n    private void initial() {\r\n        filterBaseGrid = new TreeGrid<>();\r\n\r\n        filterBaseGrid.addHierarchyColumn(Filterbase::getLabel)\r\n                .setHeader(getTranslation(TMS.FILTER_GRID_NAME, getLocale(), ctx)).setFlexGrow(4).setResizable(true);\r\n\r\n\r\n        if (showChilds) {\r\n            filterBaseGrid.addColumn(Filterbase::getChildCount)\r\n                    .setHeader(getTranslation(TMS.FILTER_GRID_ARTICLE_COUNT, getLocale(), ctx)).setFlexGrow(1)\r\n                    .setResizable(true);\r\n        }\r\n        filterBaseGrid.setSelectionMode(SelectionMode.MULTI);\r\n        filterBaseGrid.addExpandListener(event -> {\r\n            for (Filterbase item : event.getItems()) {\r\n                item.setChilds(loadCount(item.getChilds()));\r\n                item.getChilds().removeIf(child -> child.getChildCount() == 0);\r\n            }\r\n        });\r\n\r\n        MultiSelect<Grid<Filterbase>, Filterbase> multiSelect = filterBaseGrid.asMultiSelect();\r\n        multiSelect.addValueChangeListener(event -> {\r\n            List<Filterbase> values = new ArrayList<>();\r\n            values.addAll(event.getOldValue());\r\n            event.getValue().forEach(values::remove);\r\n            if (!values.isEmpty()) {\r\n                Filterbase item = values.get(0);\r\n                List<Filterbase> toDeselect = event.getValue().stream().filter(newItem -> newItem.getIdentifier().startsWith(item.getIdentifier())).collect(Collectors.toList());\r\n                toDeselect.forEach(filterBaseGrid::deselect);\r\n            }\r\n\r\n        });\r\n        getContent().add(filterBaseGrid);\r\n\r\n        CompUtils.removeMSP(getContent(), \"MP\");\r\n        getContent().setSizeFull();\r\n    }\r\n\r\n\r\n    /**\r\n     * The reload function is used to reload the data in the grid.\r\n     *\r\n     *\r\n     * @param List&lt;Filterbase&gt; list Load the data into the grid\r\n     */\r\n    @Override\r\n    public void reload(List<Filterbase> list) {\r\n        TreeData<Filterbase> filterData = new TreeData<>();\r\n        loadCount(list);\r\n        filterData.addItems(list, Filterbase::getChilds);\r\n        TreeDataProvider<Filterbase> baseProvider = new TreeDataProvider<>(filterData);\r\n        filterBaseGrid.setDataProvider(baseProvider);\r\n        log.info(\"ListSize: \" + list.size());\r\n    }\r\n\r\n    /**\r\n     * The loadCount function is used to load the number of articles that are associated with each filterbase.\r\n     * This function is called by the getFilterBaseList function, and it's purpose is to determine whether or not\r\n     * a given filterbase has any articles associated with it. If there are no articles associated with a given\r\n     * filterbase, then that particular filterbase will be removed from the list of all available filters. The\r\n     * showChilds variable determines whether or not this functionality should be enabled (showChilds = true) or disabled (showChilds = false).\r\n     *\r\n     * @param Collection&lt;Filterbase&gt; list Pass the list of filterbase objects to be processed\r\n     */\r\n    private Collection<Filterbase> loadCount(Collection<Filterbase> list) {\r\n        if (showChilds) {\r\n            list.forEach(item -> {\r\n                if (item.getChildCount() == 0)\r\n                    item.setChildCount(ctx.getServices().getFilterBaseDBService().countArticle(ctx, item));\r\n            });\r\n            list.removeIf(item -> item.getChildCount() == 0);\r\n        }\r\n        return list;\r\n    }\r\n\r\n\r\n    /**\r\n     * The reload function is used to reload the plugin.\r\n     * It will first unload the plugin, then load it again.\r\n     * This function is useful for when you want to make changes to your code without having to restart your server.\r\n     */\r\n    @Override\r\n    public void reload() {\r\n        reload(new ArrayList<>());\r\n    }\r\n\r\n    /**\r\n     * The getGrid function is used to return the grid that was created in the\r\n     * createGrid function. This allows for other classes to access this grid and\r\n     * use it as they see fit. In this case, we are using it in our FilterBaseView class\r\n     * so that we can add a click listener to each row of the table, which will then\r\n     * open up a new window with more information about that specific filter base.\r\n     *\r\n     * @return A grid of type filterbase\r\n     */\r\n    @Override\r\n    public Grid<Filterbase> getGrid() {\r\n        return filterBaseGrid;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\filter\\StructureTreeFilterGrid.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\logout\\LogoutView.java =====\n```\npackage com.hom.ebmw.view.logout;\r\n\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.vaadin.flow.component.Composite;\r\nimport com.vaadin.flow.component.HasComponents;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.html.Div;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;\r\nimport com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.router.PageTitle;\r\nimport com.vaadin.flow.router.Route;\r\n\r\nimport java.util.Locale;\r\n\r\nimport static com.hom.ebmw.utilities.interfaces.PageConst.*;\r\n\r\n@SuppressWarnings(\"serial\")\r\n@Route(value = PAGE_LOGOUT)\r\n@PageTitle(TITLE_LOGOUT)\r\npublic class LogoutView extends Composite<VerticalLayout> implements HasComponents {\r\n\r\n\r\n    /**\r\n     * The LogoutView function is used to logout the user from the application.\r\n     * It closes all services and redirects to the login page.\r\n     *\r\n     * @param Services services Close the session and to get the property of the application\r\n     * @return A div with a paragraph and a button\r\n     */\r\n    public LogoutView(Services services) {\r\n        services.close();\r\n        String location = services.getProperty().getLogoutAdress() + \"/\" + PAGE_ROOT;\r\n\r\n        Div box = new Div();\r\n        Locale locale = getLocale();\r\n        if (!locale.equals(Locale.forLanguageTag(\"de-DE\"))) {\r\n            locale = Locale.ENGLISH;\r\n        }\r\n        Paragraph h2Text = new Paragraph(services.getTranslationService().getTranslation(TMS.LOGOUT_MESSAGE, locale));\r\n        Button relogin = new Button(\"Login\");\r\n        relogin.addClickListener(event -> getUI().ifPresent(ui -> ui.getPage().setLocation(location)));\r\n\r\n        box.add(h2Text, relogin);\r\n\r\n        getContent().add(box);\r\n        getContent().setHorizontalComponentAlignment(Alignment.CENTER, box);\r\n        getContent().setJustifyContentMode(JustifyContentMode.CENTER);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\logout\\LogoutView.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\MainView.java =====\n```\npackage com.hom.ebmw.view;\r\n\r\nimport com.hom.ebmw.configuration.ApplicationProperty;\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.configuration.security.SessionUtils;\r\nimport com.hom.ebmw.exceptions.AccessDeniedException;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.UserSession;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.SettingUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.CTXAttribute;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.utilities.enums.SessionParams;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\nimport com.hom.ebmw.utilities.interfaces.HasPermission;\r\nimport com.hom.ebmw.utilities.interfaces.PageConst;\r\nimport com.hom.ebmw.view.admin.AdminHeader;\r\nimport com.hom.ebmw.view.admin.AdminView;\r\nimport com.hom.ebmw.view.admin.export.AstFileExportView;\r\nimport com.hom.ebmw.view.admin.generation.GenerateView;\r\nimport com.hom.ebmw.view.admin.generation.TestView;\r\nimport com.hom.ebmw.view.admin.globalexclude.GlobalExcludeView;\r\nimport com.hom.ebmw.view.admin.setting.SettingView;\r\nimport com.hom.ebmw.view.admin.statistic.StatisticView;\r\nimport com.hom.ebmw.view.admin.translations.TranslationView;\r\nimport com.hom.ebmw.view.components.JiraIssueCollector;\r\nimport com.hom.ebmw.view.logout.LogoutView;\r\nimport com.hom.ebmw.view.sortment.SortmentHeader;\r\nimport com.hom.ebmw.view.sortment.ecat.ECatView;\r\nimport com.hom.ebmw.view.sortment.eshop.EShopView;\r\nimport com.hom.ebmw.view.sortment.profil.ProfilView;\r\nimport com.hom.ebmw.view.sortment.promotion.PromotionView;\r\nimport com.hom.ebmw.view.user.UserView;\r\nimport com.vaadin.flow.component.*;\r\nimport com.vaadin.flow.component.contextmenu.MenuItem;\r\nimport com.vaadin.flow.component.contextmenu.SubMenu;\r\nimport com.vaadin.flow.component.dependency.CssImport;\r\nimport com.vaadin.flow.component.dependency.JsModule;\r\nimport com.vaadin.flow.component.html.Anchor;\r\nimport com.vaadin.flow.component.html.Image;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.icon.VaadinIcon;\r\nimport com.vaadin.flow.component.menubar.MenuBar;\r\nimport com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;\r\nimport com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.page.Push;\r\nimport com.vaadin.flow.router.Route;\r\nimport com.vaadin.flow.router.RouteAlias;\r\nimport com.vaadin.flow.router.RouterLayout;\r\nimport com.vaadin.flow.router.RouterLink;\r\nimport com.vaadin.flow.server.PWA;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.util.Objects;\r\n\r\nimport static com.hom.ebmw.utilities.interfaces.PageConst.PAGE_ROOT_ALIAS;\r\n\r\n@Slf4j\r\n@SuppressWarnings(\"serial\")\r\n@Route\r\n@RouteAlias(PAGE_ROOT_ALIAS)\r\n@JsModule(value = \"./src/styles/shared-styles.js\")\r\n@CssImport(value = \"./styles/view/main-view.css\")\r\n@PWA(name = \"Assorttmenttool\", shortName = \"AST\", enableInstallPrompt = true, iconPath = \"icons/favicon.png\", offlinePath = \"offline.html\")\r\n@Push\r\npublic class MainView extends Composite<VerticalLayout> implements RouterLayout, PageConst, HasPermission {\r\n\r\n    private final VerticalLayout content = new VerticalLayout();\r\n    private final HorizontalLayout header = new HorizontalLayout();\r\n    private final Context ctx = new Context();\r\n    private User user = null;\r\n    private final ApplicationProperty property;\r\n\r\n\r\n    /**\r\n     * The MainView function is the main function of the application.\r\n     * It creates a new MainView object, which contains all other views and components.\r\n     * The MainView object is then added to the UI as a component.\r\n     *\r\n     * @param Services    services Get the services\r\n     * @param UserSession uSession Get the user object from the session\r\n     * @return A component\r\n     * @docauthor Trelent\r\n     */\r\n    public MainView(Services services, UserSession uSession) {\r\n        ctx.put(CTXAttribute.SESSION, new SessionUtils(services.getUserServices()));\r\n        ctx.put(CTXAttribute.SERVICES, services);\r\n        ctx.put(CTXAttribute.USER_SESSION, uSession);\r\n        ctx.put(CTXAttribute.HTTP_SESSION, ctx.getSession().getHttpSession());\r\n        ctx.putHttpAttribute(SessionParams.LOCALE, getLocale());\r\n        ctx.refreshLocale();\r\n\r\n        user = ctx.getSession().getCurrentUser(ctx);\r\n\r\n        property = ctx.getServices().getProperty();\r\n\r\n        HorizontalLayout menu = new HorizontalLayout();\r\n        MenuBar menuBar = new MenuBar();\r\n        setHeader();\r\n        try {\r\n\r\n            if (getPermission(user, services, SortmentHeader.class).isRead()) {\r\n                MenuItem build = menuBar.addItem(getTranslation(TMS.MENUE_BUILD, getLocale(), ctx));\r\n                SubMenu buildSubMenu = build.getSubMenu();\r\n                addSubMenu(buildSubMenu, VaadinIcon.BOOK, TMS.SUB_MENUE_BUILD_ECAT, ECatView.class);\r\n                addSubMenu(buildSubMenu, VaadinIcon.SHOP, TMS.SUB_MENUE_BUILD_ESHOP, EShopView.class);\r\n                addSubMenu(buildSubMenu, VaadinIcon.NEWSPAPER, TMS.SUB_MENUE_BUILD_PROMOTION, PromotionView.class);\r\n                addSubMenu(buildSubMenu, VaadinIcon.FILTER, TMS.SUB_MENUE_BUILD_PROFIL, ProfilView.class);\r\n\r\n            }\r\n        } catch (AccessDeniedException e) {\r\n            log.warn(\"[Permission.SortmentHeader] \" + e.getMessage());\r\n            log.debug(\"[Permission.SortmentHeader]\", e);\r\n            log.error(e.getLocalizedMessage(), e);\r\n        }\r\n\r\n        try {\r\n\r\n            if (getPermission(user, services, AdminHeader.class).isRead()) {\r\n                MenuItem admin = menuBar.addItem(getTranslation(TMS.MENUE_ADMIN, getLocale(), ctx));\r\n                SubMenu adminSubMenu = admin.getSubMenu();\r\n                addSubMenu(adminSubMenu, VaadinIcon.EXIT_O, TMS.SUB_MENUE_ADMIN_ADMIN, AdminView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.BOOK, TMS.SUB_MENUE_ADMIN_TRANSLATION, TranslationView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.PUZZLE_PIECE, TMS.SUB_MENUE_ADMIN_SETTING, SettingView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.COG_O, TMS.SUB_MENUE_ADMIN_GENERIC, GenerateView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.QUESTION, TMS.SUB_MENUE_ADMIN_TEST, TestView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.FILTER, TMS.SUB_MENUE_ADMIN_FILTER, GlobalExcludeView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.CHART, TMS.SUB_MENUE_ADMIN_STATISTIC, StatisticView.class);\r\n                addSubMenu(adminSubMenu, VaadinIcon.DOWNLOAD, TMS.SUB_MENUE_ADMIN_EXPORT, AstFileExportView.class);\r\n            }\r\n        } catch (AccessDeniedException e) {\r\n            log.warn(\"[Permission.AdminHeader] \" + e.getMessage());\r\n            log.debug(\"[Permission.AdminHeader]\", e);\r\n        }\r\n        try {\r\n            User user = ctx.getSession().getCurrentUser(ctx);\r\n            if (Objects.nonNull(user)) {\r\n                String loginAs = user.getSurName() + \", \" + user.getGivenName();\r\n                MenuItem name = menuBar.addItem(getTranslation(TMS.MENUE_WELCOME, getLocale(), ctx) + \" \" + loginAs);\r\n                SubMenu nameSubMenu = name.getSubMenu();\r\n                addSubMenu(nameSubMenu, VaadinIcon.USER_CARD, TMS.SUB_MENUE_WELCOME_USER, UserView.class);\r\n                name.setId(\"menu-user\");\r\n            }\r\n        } catch (AccessDeniedException e) {\r\n            log.warn(\"[Permission.welcome] \" + e.getMessage());\r\n            log.debug(\"[Permission.welcome]\", e);\r\n        }\r\n        menuBar.addItem(\r\n                createEntry(VaadinIcon.EXIT_O, getTranslation(TMS.MENUE_LOGOUT, getLocale(), ctx), LogoutView.class));\r\n        VerticalLayout navBox = new VerticalLayout();\r\n\r\n        navBox.getStyle().set(\"background\", property.getColorHeader());\r\n        navBox.setPadding(false);\r\n\r\n        menu.add(menuBar);\r\n        menu.getStyle().set(\"background\", property.getColorMenue());\r\n\r\n        navBox.add(header, menu);\r\n\r\n        JiraIssueCollector collector = new JiraIssueCollector();\r\n        collector.loadReport();\r\n\r\n        content.setSizeFull();\r\n        getContent().add(navBox, content);\r\n        getContent().setFlexGrow(1, navBox);\r\n        getContent().setFlexGrow(10, content);\r\n        getContent().setSizeFull();\r\n\r\n        CompUtils.removeMSP(content, \"MP\");\r\n        content.getStyle().set(\"margin-top\", \"0.5em\");\r\n        getContent().getStyle().set(\"padding\", \"0.1em 0.1em\");\r\n\r\n    }\r\n\r\n    /**\r\n     * The addSubMenu function is used to add a submenu item to the menu.\r\n     *\r\n     * @param SubMenu    subMenu Add the submenu to the main menu\r\n     * @param VaadinIcon icon Set the icon of the menu item\r\n     * @param String     title Get the translation of the title\r\n     * @param Class&lt;? extends Component&gt; viewClass Check if the user has permission to access the view\r\n     * @return A menuitem\r\n     */\r\n    private void addSubMenu(SubMenu subMenu, VaadinIcon icon, String title, Class<? extends Component> viewClass)\r\n            throws AccessDeniedException {\r\n        try {\r\n            if (getPermission(user, ctx.getServices(), viewClass).isRead()) {\r\n                subMenu.addItem(createEntry(icon, getTranslation(title, getLocale(), ctx), viewClass));\r\n            }\r\n        } catch (NullPointerException e) {\r\n            throw new AccessDeniedException(\"Access Denied | \" + viewClass.getSimpleName());\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * The createEntry function creates a new entry in the menu.\r\n     *\r\n     * @param VaadinIcon icon Set the icon of the link\r\n     *                   private component populatelink(routerlink routerlink, vaadinicon icon, string title) {\r\n     *                   routerlink\r\n     * @param String     title Set the text of the link\r\n     * @param Class&lt;? extends Component&gt; viewClass Create a new routerlink with the viewclass as its target\r\n     * @return A populated routerlink\r\n     */\r\n    private Component createEntry(VaadinIcon icon, String title, Class<? extends Component> viewClass) {\r\n        return populateLink(new RouterLink(null, viewClass), icon, title);\r\n    }\r\n\r\n    /**\r\n     * The populateLink function takes a Vaadin component that implements the HasComponents interface,\r\n     * and returns the same type of component. It adds an icon and title to the given component,\r\n     * which is assumed to be a link. The function uses generics so that it can work with any type of\r\n     * Vaadin Component that implements HasComponents (e.g., Anchor or Button). This allows us to use\r\n     * this function for both buttons and links in our application's UI code without having two separate functions.\r\n     *\r\n     * @param T          a Return the same type of object that is passed in\r\n     * @param VaadinIcon icon Create the icon for the link\r\n     *                   <p>\r\n     *                   public static &lt;t extends hascomponents&gt; t populatelink(t a, string title) {\r\n     *                   return populatelink(a, vaadinicon\r\n     * @param String     title Set the text of the link\r\n     * @return A value of type t\r\n     */\r\n    private static <T extends HasComponents> T populateLink(T a, VaadinIcon icon, String title) {\r\n        HorizontalLayout inRow = new HorizontalLayout();\r\n        inRow.add(icon.create());\r\n        inRow.add(title);\r\n        inRow.setSpacing(true);\r\n        inRow.setMargin(false);\r\n        a.add(inRow);\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * The setHeader function is used to set the header of the page.\r\n     * The header contains a logo and a version number.\r\n     */\r\n    private <T extends Component & HasStyle> void setHeader() {\r\n        String propVersion = ctx.getServices().getProperty().getVersion();\r\n        Paragraph version = new Paragraph(\"v.\" + propVersion);\r\n        version.setId(\"version\");\r\n        version.getStyle().set(\"color\", \"white\");\r\n\r\n        HorizontalLayout logoBox = new HorizontalLayout();\r\n        Image logo = CompUtils.getBannerImage(ctx);\r\n        logo.getStyle().set(\"width\", \"auto\");\r\n        logo.getStyle().set(\"height\", \"50px\");\r\n        logo.getStyle().set(\"margin-top\", \"10px\");\r\n        logo.getStyle().set(\"margin-left\", \"25px\");\r\n        logo.getStyle().set(\"margin-bottom\", \"-5px\");\r\n        logoBox.add(logo, version);\r\n        logoBox.setAlignSelf(Alignment.END, version);\r\n        logoBox.setWidth(\"100%\");\r\n        logoBox.setId(\"right-block\");\r\n        logoBox.setAlignSelf(Alignment.START, logo);\r\n        logoBox.setJustifyContentMode(JustifyContentMode.START);\r\n        header.add(logoBox);\r\n        Setting icon = SettingUtils.getSettingByType(ctx, SettingType.MAINTENANCE_MANUAL_LINK);\r\n\r\n\r\n        if (Objects.nonNull(icon) && !icon.getValue().isEmpty()) {\r\n            Anchor help = new Anchor(icon.getValue(), VaadinIcon.QUESTION_CIRCLE.create());\r\n            help.setTarget(\"_blank\");\r\n            help.getStyle().set(\"margin-top\", \"10px\");\r\n            help.getStyle().set(\"margin-right\", \"10px\");\r\n            help.getStyle().set(\"color\", \"white\");\r\n            header.add(help);\r\n        }\r\n\r\n        header.setWidth(\"100%\");\r\n        header.setJustifyContentMode(JustifyContentMode.BETWEEN);\r\n        header.setVerticalComponentAlignment(Alignment.CENTER, logoBox);\r\n    }\r\n\r\n    /**\r\n     * The showRouterLayoutContent function is used to display the content of a page.\r\n     * It takes in an argument of type HasElement, which is a class that contains an element.\r\n     * The function then checks if the user has permission to view this page, and if so it appends\r\n     * the element contained within HasElement to its own content div. If not, it logs an error message\r\n     *\r\n     * @param HasElement content Get the content that is to be displayed in the ui\r\n     * @return The content that is passed to it\r\n     * @docauthor Trelent\r\n     */\r\n    @Override\r\n    public void showRouterLayoutContent(HasElement content) {\r\n\r\n        if (getPermission(user, ctx.getServices(), content.getClass()).isRead()) {\r\n            ctx.getUserSession().remove(Params.ACTIVE_ASSORTMENT);\r\n            ctx.getUserSession().remove(Params.ACTIVE_FILTER);\r\n            ctx.refreshLocale();\r\n            this.content.getElement().appendChild(content.getElement());\r\n        } else {\r\n            log.error(\"[Permission-Content]Session not Valid\");\r\n        }\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\MainView.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\AddProfilFromAssortment.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.combobox.ComboBox;\r\nimport com.vaadin.flow.component.dialog.Dialog;\r\nimport com.vaadin.flow.component.formlayout.FormLayout;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.binder.Binder;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\nimport static com.hom.ebmw.utilities.constans.ASTConst.*;\r\n\r\npublic class AddProfilFromAssortment\r\n        extends\r\n        Dialog {\r\n\r\n    private static final long serialVersionUID = 7379686125907201599L;\r\n\r\n    private Filter select = null;\r\n    private Binder<Filter> binder = new Binder<Filter>();\r\n    private ComboBox<String> priorityBox;\r\n    private HorizontalLayout headValues;\r\n    private FormLayout form;\r\n    private final VerticalLayout box = new VerticalLayout();\r\n    private Button saveBtn = null;\r\n    private Button cancelBtn = null;\r\n    private Context ctx = null;\r\n\r\n    /**\r\n     * The AddProfilFromAssortment function adds a profile to the assortment.\r\n     *\r\n     * @param Context ctx Load the data from the database\r\n     * @return A value of type boolean\r\n     */\r\n    public AddProfilFromAssortment(\r\n            Context ctx) {\r\n        this.ctx = ctx;\r\n        load();\r\n    }\r\n\r\n    /**\r\n     * The getCtx function returns the context of the application.\r\n     *\r\n     * @return The context of the activity\r\n     */\r\n    public Context getCtx() {\r\n        return ctx;\r\n    }\r\n\r\n\r\n    /**\r\n     * The load function is used to load the form with the necessary fields and buttons.\r\n     * It also sets up a binder for validation purposes, as well as setting up a default filter.\r\n     */\r\n    private void load() {\r\n        binder = new Binder<Filter>();\r\n        Filter defaultFilter = new Filter();\r\n        defaultFilter.setPrefix(FILTER_TEAM, getCtx());\r\n        binder.setBean(defaultFilter);\r\n        Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        headValues = new HorizontalLayout();\r\n        TextField nameTxt = new TextField();\r\n        nameTxt.setRequired(true);\r\n\r\n        binder.forField(nameTxt)\r\n                .withValidator(item -> !item.isEmpty(), getTranslation(TMS.ERROR_VALIDATION_NOT_EMPTY, getLocale(), getCtx()))\r\n                .withValidator(item -> CompUtils.checkIfProfilNameExists(ctx, binder.getBean(), item), getTranslation(TMS.ERROR_VALIDATION_NAME_EXISTS, getLocale(), ctx))\r\n                .bind(Filter::getName, Filter::setName);\r\n\r\n        saveBtn = new Button(getTranslation(TMS.GLB_BUTTON_SAVE, getLocale(), getCtx()));\r\n        saveBtn.setEnabled(true);\r\n        saveBtn.addClickListener(event -> {\r\n            binder.validate();\r\n            if (binder.isValid()) {\r\n                User user = getCtx().getSession().getCurrentUser(getCtx());\r\n                select = binder.getBean();\r\n                select.setDate(user);\r\n\r\n                ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n\r\n                switch (type) {\r\n\r\n                    default:\r\n                    case ECAT:\r\n                        select.setSortType(ObjectType.ECAT);\r\n                        break;\r\n                    case IMPEX:\r\n                        select.setSortType(ObjectType.IMPEX);\r\n                        break;\r\n                }\r\n\r\n                // create Filter ID\r\n                select = getCtx().getServices().getFilterService().save(select);\r\n\r\n                List<Filterbase> filters = getCtx().getServices().getFilterBaseService().findAllByAssortment(assortment);\r\n                filters.removeIf(item -> item.getType().contains(FilterType.INDIVIDUAL.name()));\r\n                filters.forEach(item -> item.setId(0));\r\n                filters.forEach(item -> item.setAssortment(null));\r\n                filters.forEach(item -> item.setFilter(select));\r\n                getCtx().getServices().getFilterBaseCustomService().insertFilterBaseIn(filters);\r\n                close();\r\n            }\r\n        });\r\n        cancelBtn = new Button(getTranslation(TMS.GLB_BUTTON_CANCEL, getLocale(), getCtx()));\r\n        cancelBtn.addClickListener(event -> {\r\n            close();\r\n        });\r\n\r\n        setPrioritybox();\r\n        form = new FormLayout();\r\n        form.addFormItem(nameTxt, getTranslation(TMS.PROFIL_FORM_NAME, getLocale(), getCtx()));\r\n        form.addFormItem(priorityBox, getTranslation(TMS.PROFIL_FORM_VISIBLE_FOR, getLocale(), getCtx()));\r\n        form.setWidth(\"100%\");\r\n        box.add(form);\r\n\r\n        headValues.add(saveBtn, cancelBtn);\r\n        add(box, headValues);\r\n\r\n        setWidth(\"280px\");\r\n    }\r\n\r\n    /**\r\n     * The setPrioritybox function sets the priorityBox to a ComboBox&lt;String&gt;\r\n     * and then sets the clearButtonVisible to true. It then creates an activeRole variable\r\n     * that is set equal to getCtx().getHttpAttribute(SessionParams.ACTIVE_ROLE). If the\r\n     * activeRole's name equals &quot;admin&quot;, it will set items for FILTER_GLB, FILTER_TEAM, and\r\n     * FILTER_PRV in priorityBox. It will also make it readOnly as false and required as true.\r\n     * Otherwise, if not admin, it will only have items\r\n     */\r\n    private void setPrioritybox() {\r\n        priorityBox = new ComboBox<String>();\r\n        priorityBox.setClearButtonVisible(true);\r\n        Role activeRole = getCtx().getHttpAttribute(SessionParams.ACTIVE_ROLE);\r\n\r\n        if (activeRole.getName().equals(\"admin\")) {\r\n            priorityBox.setItems(FILTER_GLB, FILTER_TEAM, FILTER_PRV);\r\n            priorityBox.setReadOnly(false);\r\n            priorityBox.setRequired(true);\r\n        } else {\r\n            priorityBox.setItems(FILTER_TEAM);\r\n            priorityBox.setReadOnly(true);\r\n            priorityBox.setRequired(false);\r\n        }\r\n        priorityBox.setItemLabelGenerator(item -> item.replace(\"_\", \"\"));\r\n        priorityBox.setValue(FILTER_TEAM);\r\n        binder.forField(priorityBox)\r\n                .withValidator(item -> Objects.nonNull(item) && !item.isEmpty(), getTranslation(TMS.ERROR_VALIDATION_NOT_EMPTY, getLocale(), getCtx()))\r\n                .bind(item -> item.getPrefix(), (filter, value) -> {\r\n                    filter.setPrefix(value, getCtx());\r\n                });\r\n\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\AddProfilFromAssortment.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\AutoSortingDialog.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.exceptions.DoubleFoundException;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.AssortmentUtil;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.FilterRunUtils;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.hom.ebmw.utilities.interfaces.HasPermission;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\nimport com.vaadin.flow.component.Key;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.combobox.ComboBox;\r\nimport com.vaadin.flow.component.formlayout.FormLayout;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.html.Div;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.VerticalLayout;\r\nimport com.vaadin.flow.data.provider.DataProvider;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.Optional;\r\n\r\nimport static com.hom.ebmw.utilities.CompUtils.addLine;\r\n\r\npublic class AutoSortingDialog extends CrumbProgressDialog implements HasPermission {\r\n\r\n    private static final long serialVersionUID = 260894994068433538L;\r\n\r\n    private Button okBtn = null;\r\n    private final Assortment assortment;\r\n    private ComboBox<Filter> filterBox;\r\n    private List<Filter> filters;\r\n    private final Grid<Filterbase> filterBaseGrid = new Grid<>();\r\n    private final Div body = new Div();\r\n    private final Div formDetails = new Div();\r\n\r\n    /**\r\n     * The AutoSortingDialog function is a constructor for the AutoSortingDialog class.\r\n     * It creates an instance of the AutoSortingDialog class, which is used to create a dialog box that allows users to automatically sort their assortment by either price or name.\r\n     *\r\n     * @param Context ctx Get the current user session\r\n     * @return A dialog\r\n     */\r\n    public AutoSortingDialog(Context ctx) {\r\n        super(ctx);\r\n        setId(\"auto-sorter\");\r\n        this.assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the page is first loaded.\r\n     * It sets the progress bar to be invisible, checks for doubles in the database, and initializes a selection of roles based on what role was selected by the user.\r\n     */\r\n    @Override\r\n    protected void load() throws DoubleFoundException {\r\n        setProgressVisible(false);\r\n        FilterRunUtils.checkOfDoubles(getCtx(), null);\r\n        User user = getCtx().getSession().getCurrentUser(getCtx());\r\n        Role active = getCtx().getHttpAttribute(SessionParams.ACTIVE_ROLE);\r\n        initSelection(user, active);\r\n    }\r\n\r\n    /**\r\n     * The create function creates a new VerticalLayout and adds the following components to it:\r\n     * - A line containing the name of the user who created this filter, if any.\r\n     * - A line containing when this filter was created, if any.\r\n     * - A line containing the name of the user who last updated this filter, if any.\r\n     * - A line containing when this filter was last updated, if any.\r\n     *\r\n     * @param Filter filter Get the data from the database\r\n     * @return A verticallayout\r\n     */\r\n    private VerticalLayout create(Filter filter) {\r\n        VerticalLayout form = new VerticalLayout();\r\n        form.setSpacing(false);\r\n        form.setPadding(false);\r\n        User createUser = filter.getCreateBy();\r\n        if (Objects.nonNull(createUser)) {\r\n            form.add(addLine(getCtx(), TMS.PROFIL_CREATE_BY, createUser.getGivenName() + \", \" + createUser.getSurName()));\r\n            form.add(addLine(getCtx(), TMS.PROFIL_CREATE_ON, Parse.formatDateTime(filter.getCreateOn(), AstDateTimeFormat.GERMAN)));\r\n        }\r\n        User updateUser = filter.getUpdateBy();\r\n        if (Objects.nonNull(updateUser)) {\r\n            form.add(addLine(getCtx(), TMS.PROFIL_UPDATE_BY, updateUser.getGivenName() + \", \" + updateUser.getSurName()));\r\n            form.add(addLine(getCtx(), TMS.PROFIL_UPDATE_ON, Parse.formatDateTime(filter.getUpdateOn(), AstDateTimeFormat.GERMAN)));\r\n        }\r\n        return form;\r\n    }\r\n\r\n    // initial Selection\r\n\r\n    /**\r\n     * The initSelection function is used to initialize the selection of filters for the user.\r\n     *\r\n     * @param User user Get the user's role\r\n     * @param Role active Determine if the user is an admin or not\r\n     */\r\n    private void initSelection(User user, Role active) {\r\n\r\n        // LoadFilter\r\n        filters = new ArrayList<>();\r\n        filters.addAll(getCtx().getServices().getFilterService().findAll());\r\n        filters.removeIf(item -> Objects.nonNull(item.getDeleteBy()));\r\n        okBtn = new Button(getTranslation(TMS.GLB_BUTTON_ACCEPT, getCtx().getSession().getLocale(getCtx()), getCtx()));\r\n\r\n        ObjectType type = CompUtils.getParameter(getCtx(), FileParam.FILE_TYPE, assortment);\r\n        switch (type) {\r\n\r\n            default:\r\n\r\n            case ECAT:\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.IMPEX));\r\n                break;\r\n            case IMPEX:\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.ECAT));\r\n                break;\r\n        }\r\n\r\n        filters.removeIf(item -> Objects.nonNull(item.getDeleteBy()));\r\n\r\n        if (!active.getName().equals(\"admin\")) {\r\n            filters.removeIf(item -> Objects.nonNull(item.getTeam()) && item.getTeam().getId() != active.getId());\r\n            filters.removeIf(item -> Objects.nonNull(item.getPrivate()) && item.getPrivate().getId() != user.getId());\r\n        }\r\n\r\n        FormLayout form = new FormLayout();\r\n        filterBox = new ComboBox<>();\r\n        filterBox.setAllowCustomValue(false);\r\n        form.addFormItem(filterBox, getTranslation(TMS.PROFIL_SELECT_FILTER, getLocale(), getCtx()));\r\n\r\n        filters.sort((o1, o2) -> o1.getNameWithPrefix().compareTo(o2.getNameWithPrefix()));\r\n\r\n        filterBox.setItems(filters);\r\n        filterBox.setItemLabelGenerator(Filter::getNameWithPrefix);\r\n        filterBox.setAllowCustomValue(false);\r\n        filterBox.addValueChangeListener(event -> {\r\n            Filter select = event.getValue();\r\n            formDetails.removeAll();\r\n            List<Filterbase> resultSet = new ArrayList<>();\r\n\r\n            formDetails.add(create(select));\r\n            resultSet.addAll(getCtx().getServices().getFilterBaseService().findAllByFilterAndDelete(select, false));\r\n\r\n            resultSet.removeIf(item -> Objects.nonNull(item.getParent()));\r\n\r\n            okBtn.setEnabled(resultSet.stream().anyMatch(item -> item.getDirection() == 1));\r\n\r\n            resultSet.sort(this::compare);\r\n\r\n            filterBaseGrid.setDataProvider(DataProvider.ofCollection(resultSet));\r\n        });\r\n\r\n\r\n        Optional<Filter> optFilter = getCurrentCustomerFilter(assortment);\r\n        //optFilter.ifPresent(filterBox::setValue);\r\n        if (optFilter.isPresent()) {\r\n            filterBox.setValue(optFilter.get());\r\n        } else {\r\n            Optional<Setting> optSetting = getCtx().getServices().getSettingCustomServices().findBySettingType(getCtx(), SettingType.DEFAULT_AUTO_SORT_PROFIL);\r\n            optSetting.ifPresent(setting -> {\r\n                Optional<Filter> optSetFilter = getCtx().getServices().getFilterService().findById(Parse.toInt(setting.getValue()));\r\n                optSetFilter.ifPresent(filterBox::setValue);\r\n            });\r\n        }\r\n\r\n\r\n        filterBaseGrid.addComponentColumn(CompUtils::getDirection);\r\n        filterBaseGrid.addColumn(Filterbase::getLabel);\r\n        filterBaseGrid.addColumn(Filterbase::getType);\r\n        filterBaseGrid.setHeight(\"300px\");\r\n        filterBaseGrid.setWidthFull();\r\n\r\n        okBtn = new Button(getTranslation(TMS.GLB_BUTTON_ACCEPT, getCtx().getSession().getLocale(getCtx()), getCtx()));\r\n        okBtn.setId(TMS.GLB_BUTTON_ACCEPT);\r\n        okBtn.addClickListener(event -> {\r\n            Filter filter = filterBox.getValue();\r\n            if (filter.getId() != 0) {\r\n                FilterRunUtils.setFilterToAssortment(getCtx(), filter);\r\n            }\r\n            BuildAutoSortingDialog dialog = new BuildAutoSortingDialog(getCtx(), assortment);\r\n            dialog.getArticles().clear();\r\n            dialog.open();\r\n            dialog.run();\r\n            uiClose();\r\n        });\r\n        Button cancelBtn = new Button(getTranslation(TMS.GLB_BUTTON_CANCEL, getLocale(), getCtx()));\r\n        cancelBtn.addClickListener(event -> {\r\n            AssortmentUtil.delete(getCtx());\r\n            firstUIBreadCrumb();\r\n            uiClose();\r\n        });\r\n        cancelBtn.addClickShortcut(Key.ESCAPE);\r\n        HorizontalLayout buttons = new HorizontalLayout();\r\n        buttons.add(okBtn, cancelBtn);\r\n        HorizontalLayout headLine = new HorizontalLayout();\r\n        CompUtils.removeMSP(headLine, \"MSP\");\r\n        headLine.add(new Div(form, formDetails), filterBaseGrid);\r\n        body.add(headLine, new VerticalLayout(), buttons);\r\n        add(body);\r\n    }\r\n\r\n    /**\r\n     * The compare function is used to sort the list of filters.\r\n     * The first sorting criteria is direction, with ascending being sorted before descending.\r\n     * If two filters have the same direction, then they are sorted by type (numeric before string).\r\n     * If two filters have the same type and direction, then they are sorted alphabetically by label.\r\n     *\r\n     * @param Filterbase o1 Compare the direction of the filter\r\n     * @param Filterbase o2 Compare the o2 object with the o3 object\r\n     * @return -ve, 0 or +ve value\r\n     */\r\n    private int compare(Filterbase o1, Filterbase o2) {\r\n        int value = 0;\r\n        Integer int1 = o1.getDirection();\r\n        Integer int2 = o2.getDirection();\r\n        value = (-1) * int1.compareTo(int2);\r\n        if (value == 0) {\r\n            value = o1.getType().compareTo(o2.getType());\r\n        }\r\n        if (value == 0) {\r\n            value = o1.getLabel().compareTo(o2.getLabel());\r\n        }\r\n\r\n        return value;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\AutoSortingDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\BreakDialog.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.ArticleBaseQueueUtils;\r\nimport com.hom.ebmw.utilities.AssortmentUtil;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class BreakDialog\r\n        extends\r\n        CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * The BreakDialog function is a constructor for the BreakDialog class.\r\n     * It takes in a Context object as an argument and returns nothing.\r\n     *\r\n     * @param Context ctx Create a dialog box\r\n     * @return A dialog object\r\n     */\r\n    public BreakDialog(\r\n            Context ctx) {\r\n        super(ctx);\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the user clicks on a breadcrumb.\r\n     * It resets the queues, deletes the assortment and closes the UI.\r\n     */\r\n    @Override\r\n    protected void load() {\r\n        Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        if (Objects.nonNull(assortment)) {\r\n            ArticleBaseQueueUtils.resetUserQueues(getCtx());\r\n            AssortmentUtil.delete(getCtx());\r\n        }\r\n\r\n        firstUIBreadCrumb();\r\n        uiClose();\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\BreakDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\BuildAutoSortingDialog.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.exceptions.*;\r\nimport com.hom.ebmw.jpa.dao.impl.FilterBaseUpdateRepository;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.*;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.File;\r\nimport java.time.LocalDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.UUID;\r\nimport java.util.concurrent.ExecutionException;\r\n\r\n@Slf4j\r\npublic class BuildAutoSortingDialog extends CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private final boolean valid = false;\r\n    private final Assortment assortment;\r\n\r\n    /**\r\n     * The BuildAutoSortingDialog function creates a dialog box that allows the user to select\r\n     * which sorting algorithm they would like to use. The function also contains an onClickListener\r\n     * for each of the buttons in the dialog box, and calls their respective functions when clicked.\r\n     *\r\n     * @param Context    ctx Get the context of the activity that calls this dialog\r\n     * @param Assortment assortment Get the name of the assortment\r\n     * @return A dialog object\r\n     */\r\n    public BuildAutoSortingDialog(Context ctx, Assortment assortment) {\r\n        super(ctx);\r\n        this.assortment = assortment;\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the dialog is opened.\r\n     * It sets the label of the dialog to &quot;Add Data File&quot; and then calls autoWork() on assortment.\r\n     * If valid is true, it creates a new AstNotification object with getCtx(), and calls errorMessage() on it with a translation of TMS.ERROR_MSG_PRICE_FILE_IS_EMPTY in getLocale(). Then uiClose() is called to close this window.\r\n     */\r\n    @Override\r\n    protected void load() throws DoubleFoundException, ArticleBaseQueueException, ParameterException {\r\n        getCtx().getUserSession().put(Params.ACTIVE_ASSORTMENT, assortment);\r\n        setParameter(FileParam.LOCK, true, assortment);\r\n\r\n        setLabel(TMS.SET_DIALOG_ADD_DATAFILE);\r\n\r\n        try {\r\n            autoWork(assortment);\r\n        } catch (FileEmptyException | AstFileNotExistsException | InterruptedException | ExecutionException e) {\r\n            log.error(e.getLocalizedMessage());\r\n        }\r\n\r\n        if (valid) {\r\n            AstNotification notify = new AstNotification(getCtx());\r\n            notify.errorMessage(getTranslation(TMS.ERROR_MSG_PRICE_FILE_IS_EMPTY, getLocale(), getCtx()));\r\n            uiClose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The autoWork function is the main function of the AutoWork class. It takes an assortment as a parameter and performs\r\n     * several actions on it, including:\r\n     * - Assortment Upload (uploading all files associated with an assortment)\r\n     * - Clearing Cache (clearing all data from the cache)\r\n     * - Loading Files to Cache (loading files into cache for processing)\r\n     *\r\n     * @param Assortment assortment Save the assortment\r\n     */\r\n    private void autoWork(Assortment assortment) throws DoubleFoundException, ParameterException, FileEmptyException, ArticleBaseQueueException, AstFileNotExistsException, InterruptedException, ExecutionException {\r\n        setLabel(TMS.SET_DIALOG_IMPORT_ARTICLES);\r\n\r\n        // Assortment Upload\r\n        List<AssortmentDatafile> assortmentDataFile = getServices().getAssortmentDataFileService()\r\n                .findAllByAssortment(assortment);\r\n\r\n        setLabel(TMS.SET_DIALOG_CLEAR_CACHE);\r\n\r\n        ArticleBaseQueueUtils.resetUserQueues(getCtx());\r\n        // Manachmal ist er zu schnell bevor der Truncate abgeschlossen ist. Daher soll\r\n        // die funktion 1 sek ruhen.\r\n        InternalUtils.wait(1000);\r\n\r\n        setLabel(TMS.SET_DIALOG_LOAD_FILES_TO_CACHE);\r\n        for (AssortmentDatafile xrossFile : assortmentDataFile) {\r\n            AstFile dataFile = xrossFile.getAstFile();\r\n            ObjectType type = getParameter(FileParam.FILE_TYPE, dataFile);\r\n            if (type.getName().endsWith(\"INPUT\")) {\r\n                ArticleBaseQueueUtils.createArticleList(getCtx(), xrossFile, getArticles());\r\n            }\r\n\r\n            if (type.getName().endsWith(\"INPUT_POSITIV\")) {\r\n                ArticleBaseQueueUtils.createPositivList(getCtx(), xrossFile, getArticles());\r\n            }\r\n        }\r\n\r\n        assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        List<ArticleBase> articles = new ArrayList<>();\r\n        articles.addAll(getArticles());\r\n\r\n        final FilterBaseUpdateRepository updateService = getCtx().getServices().getFilterBaseUpdateService();\r\n\r\n        if (!articles.isEmpty()) {\r\n            // LIke TO ADD_CRUMB\r\n\r\n            boolean error = FilterRunUtils.runWork(getCtx(), assortment, this);\r\n\r\n            if (!error) {\r\n                // SET ADD FILTER\r\n                for (FilterType type : FilterType.values()) {\r\n                    if (FilterUtils.isValidProof(type)) {\r\n                        setLabel(TMS.SET_DIALOG_LOAD_ADD, TMS.setProof(type));\r\n                        updateService.addArticleByFilter(getCtx(), type, FilterStatus.ALL, FilterStatus.REMOVEBYFILTER);\r\n                    }\r\n                }\r\n\r\n                // SET REMOVE FILTER\r\n                for (FilterType type : FilterType.values()) {\r\n                    if (FilterUtils.isValidProof(type)) {\r\n                        setLabel(TMS.SET_DIALOG_LOAD_REMOVE, TMS.setProof(type));\r\n                        updateService.removeArticleByFilter(getCtx(), type, FilterStatus.ALL,\r\n                                FilterStatus.REMOVEBYFILTER);\r\n                    }\r\n                }\r\n\r\n                // For AutoSorting not Needed\r\n                /* START INDIVIDUAL */\r\n//\t\t\t\tsetLabel(TMS.SET_DIALOG_LOAD_ADD, TMS.setProof(FilterType.INDIVIDUAL));\r\n//\t\t\t\tupdateService.articleIndividuals(getCtx(), FilterStatus.REMOVEBYFILTER, FilterStatus.DEFAULT,\r\n//\t\t\t\t\t\tFilterbase.ADD_INDIVIDUAL);\r\n                /* END INDIVIDUAL */\r\n\r\n                /* START INDIVIDUAL */\r\n//\t\t\t\tsetLabel(TMS.SET_DIALOG_LOAD_REMOVE, TMS.setProof(FilterType.INDIVIDUAL));\r\n//\t\t\t\tupdateService.articleIndividuals(getCtx(), FilterStatus.ALL, FilterStatus.REMOVEBYFILTER,\r\n//\t\t\t\t\t\tFilterbase.REMOVE_INDIVIDUAL);\r\n                /* END INDIVIDUAL */\r\n\r\n                // save Assortment#\r\n                assortment = FilterRunUtils.saveAssortment(getCtx(), this);\r\n\r\n                if (Objects.nonNull(assortment)) {\r\n                    setParameter(FileParam.LOCK, Boolean.FALSE, assortment);\r\n                }\r\n\r\n                // TO uploadFile\r\n                try {\r\n\r\n                    setLabel(TMS.SET_DIALOG_COPY_TO_HOTFOLDER);\r\n                    File fiAssortment = new File(SettingUtils.getTempFolder(getCtx()) + UUID.randomUUID());\r\n                    Storage storage = getStorage(assortment);\r\n                    Blob.loadFromCompressedFile(storage.getFileblob(), fiAssortment);\r\n\r\n                    File dstFiAssortment = new File(SettingUtils.getAssortmentFolder(getCtx()) + assortment.getName());\r\n                    FileUtils.copyFileTo(fiAssortment, dstFiAssortment);\r\n\r\n                    setParameter(FileParam.UPLOAD_BY, getCtx().getSession().getCurrentUser(getCtx()), assortment);\r\n                    setParameter(FileParam.UPLOAD_ON, LocalDateTime.now(), assortment);\r\n\r\n                    getServices().getAssortmentService().save(assortment);\r\n                    reloadDetails();\r\n                    showUploadSuccess();\r\n\r\n                } catch (Exception e) {\r\n                    log.error(e.getLocalizedMessage());\r\n                }\r\n\r\n                firstUIBreadCrumb();\r\n                reloadDetails();\r\n                firstUIBreadCrumb();\r\n                uiClose();\r\n            }\r\n        } else {\r\n            if (Objects.nonNull(assortment)) {\r\n                ArticleBaseQueueUtils.resetUserQueues(getCtx());\r\n            }\r\n\r\n            AssortmentUtil.delete(getCtx());\r\n            firstUIBreadCrumb();\r\n            uiClose();\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\BuildAutoSortingDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\CloseDialog.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.ArticleBaseQueueUtils;\r\nimport com.hom.ebmw.utilities.enums.FileParam;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class CloseDialog\r\n        extends\r\n        CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * The CloseDialog function is a constructor for the CloseDialog class.\r\n     * It creates a dialog box that asks the user if they want to exit the application.\r\n     * If yes, then it closes all activities and exits out of the application.\r\n     *\r\n     * @param Context ctx Create a new alertdialog\r\n     * @return A boolean value\r\n     */\r\n    public CloseDialog(\r\n            Context ctx) {\r\n        super(ctx);\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the page is loaded.\r\n     * It sets the active assortment to null, and resets all user queues.\r\n     */\r\n    @Override\r\n    protected void load() {\r\n        Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        if (Objects.nonNull(assortment)) {\r\n            setParameter(FileParam.LOCK, Boolean.FALSE, assortment);\r\n            ArticleBaseQueueUtils.resetUserQueues(getCtx());\r\n        }\r\n\r\n        firstUIBreadCrumb();\r\n        uiClose();\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\CloseDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\CloseQuickDialog.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\n\r\npublic class CloseQuickDialog\r\n        extends\r\n        CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * The CloseQuickDialog function is a constructor for the CloseQuickDialog class.\r\n     * It takes in one parameter, a Context object, and returns nothing.\r\n     *\r\n     * @param Context ctx Create a new instance of the dialog class\r\n     * @return A Dialog\r\n     */\r\n    public CloseQuickDialog(\r\n            Context ctx) {\r\n        super(ctx);\r\n    }\r\n\r\n    /**\r\n     * The load function is used to load the first UI breadcrumb, and then close it.\r\n     */\r\n    @Override\r\n    protected void load() {\r\n        firstUIBreadCrumb();\r\n        uiClose();\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\CloseQuickDialog.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\CloseWithOption.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.ArticleBaseQueueUtils;\r\nimport com.hom.ebmw.utilities.AssortmentUtil;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.utilities.interfaces.Command;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class CloseWithOption\r\n        extends\r\n        CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n    private Command com = null;\r\n\r\n\r\n    /**\r\n     * The CloseWithOption function closes the current window, but gives the user\r\n     * a choice of whether to save changes first.  The function takes two arguments:\r\n     * &lt;ul&gt;\r\n     * &lt;li&gt;&lt;code&gt;saveChanges&lt;/code&gt;: A boolean value indicating whether or not to save changes.&lt;/li&gt;\r\n     * &lt;li&gt;&lt;code&gt;closeAll&lt;/code&gt;: A boolean value indicating whether or not to close all windows.&lt;/li&gt;&lt;/ul&gt;\r\n     *\r\n     * @param Context ctx Get the context of the application\r\n     * @return A closeoption value\r\n     */\r\n    public CloseWithOption(\r\n            Context ctx) {\r\n        super(ctx);\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the user clicks on the &quot;Load&quot; button.\r\n     * It first resets all of the queues in ArticleBaseQueueUtils, then deletes\r\n     * any existing assortment data from AssortmentUtil. If there is a command to be executed, it executes that command.\r\n     */\r\n    @Override\r\n    protected void load() {\r\n        setLabel(TMS.LOADER_DIALOG_LOADING);\r\n        Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        if (Objects.nonNull(assortment)) {\r\n            ArticleBaseQueueUtils.resetUserQueues(getCtx());\r\n            AssortmentUtil.delete(getCtx());\r\n        }\r\n        if (Objects.nonNull(com))\r\n            com.execute();\r\n\r\n        firstUIBreadCrumb();\r\n        uiClose();\r\n    }\r\n\r\n    /**\r\n     * The setCom function sets the Command object for this class.\r\n     *\r\n     * @param Command com Set the command that will be executed\r\n     */\r\n    public void setCom(Command com) {\r\n        this.com = com;\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\CloseWithOption.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\DeleteZinfo.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.jpa.model.Zinfo;\r\nimport com.hom.ebmw.jpa.model.ZinfoFile;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\nimport com.hom.ebmw.view.filter.FilterZinfoGrid;\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\npublic class DeleteZinfo extends CrumbProgressDialog {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private final FilterZinfoGrid zinfoGrid;\r\n\r\n    /**\r\n     * The DeleteZinfo function deletes a Zinfo from the database.\r\n     *\r\n     * @param Context         ctx Create a new instance of the databasehelper class\r\n     * @param FilterZinfoGrid zinfoGrid Get the selected rows from the grid\r\n     * @return A Dialog\r\n     */\r\n    public DeleteZinfo(Context ctx, FilterZinfoGrid zinfoGrid) {\r\n        super(ctx);\r\n        this.zinfoGrid = zinfoGrid;\r\n    }\r\n\r\n    /**\r\n     * The load function is used to load the current list of Zinfo objects into the grid.\r\n     * The function first checks if there are any Zinfo objects in the grid, and if so, it\r\n     * deletes them all. It then creates a new ListDataProvider object from the data in\r\n     * zinfos (which is a list of all Zinfo objects currently stored in memory). Finally,\r\n     * it adds each item from zinfos to this new ListDataProvider object and reloads the\r\n     * grid with these items. This allows for multiple lists of items to be loaded into\r\n     * memory at once\r\n     */\r\n    @Override\r\n    protected void load() {\r\n        if (Objects.nonNull(zinfoGrid)) {\r\n            setLabel(TMS.ZINFO_DIALOG_LOAD_CURRENT_LIST);\r\n            List<Zinfo> zinfos = new ArrayList<Zinfo>();\r\n            @SuppressWarnings(\"unchecked\")\r\n            ListDataProvider<Zinfo> dataProvider = (ListDataProvider<Zinfo>) zinfoGrid.getGrid().getDataProvider();\r\n            zinfos.addAll(dataProvider.getItems());\r\n\r\n            if (!zinfos.isEmpty()) {\r\n                setLabel(TMS.ZINFO_DIALOG_DELETE_CURRENT_LIST);\r\n                ZinfoFile item = zinfos.get(0).getZinfoFile();\r\n                item.setDeleteBy(getCtx().getSession().getCurrentUser(getCtx()));\r\n                item.setDeleteOn(LocalDateTime.now());\r\n                getCtx().getServices().getZinfoFileService().save(item);\r\n\r\n                UI ui = UI.getCurrent();\r\n                if (Objects.isNull(ui))\r\n                    ui = getCtx().getUserSession().get(Params.ACTIVE_UI);\r\n                ui.access(() -> {\r\n                    zinfoGrid.reload();\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\DeleteZinfo.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\DnDIndividualDialogAddAsPositiv.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.exceptions.ArticleBaseQueueException;\r\nimport com.hom.ebmw.exceptions.DoubleFoundException;\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.AssortmentUtil;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.FilterRunUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.confirmdialog.ConfirmDialog;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\n\r\nimport java.util.*;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class DnDIndividualDialogAddAsPositiv extends CrumbProgressDialog {\r\n\r\n    private Button cancelBtn = null;\r\n    private List<ArticleBase> selected = null;\r\n    private TextField comment = null;\r\n    private Button acceptInnerBtn = null;\r\n    private final HorizontalLayout bay = new HorizontalLayout();\r\n    private String errorMessageNotAllowed = \"\";\r\n    private String errorMessageNotAllowedTitle = \"\";\r\n    private String errorMessageArticleNotFound = \"\";\r\n    private String errorMessageArticleNotFoundTitle = \"\";\r\n    private String acceptTMS = \"\";\r\n    private String cancelTMS = \"\";\r\n\r\n    /**\r\n     * The DnDIndividualDialogAddAsPositiv function is a constructor for the DnDIndividualDialogAddAsPositiv class.\r\n     * It takes in a Context, ctx, and a List of ArticleBase objects called selected.\r\n     * The function then sets the acceptTMS variable to be equal to the translation of TMS.GLB_BUTTON_ACCEPT using getTranslation().\r\n     * The function then sets cancelTMS to be equal to the translation of TMS.GLB_BUTTON_CANCEL using getTranslation().\r\n     * The function then sets errorMessageArticleNotFound to be equal to the translation of TMS.ERROR_M\r\n     *\r\n     * @param Context                 ctx Get the translations for the dialog\r\n     * @param List&lt;ArticleBase&gt; selected Get the selected articles from the dndindividualdialogaddaspositiv function\r\n     * @return A dialog\r\n     */\r\n    public DnDIndividualDialogAddAsPositiv(Context ctx, List<ArticleBase> selected) {\r\n        super(ctx);\r\n        acceptTMS = getTranslation(TMS.GLB_BUTTON_ACCEPT, getLocale(), getCtx());\r\n        cancelTMS = getTranslation(TMS.GLB_BUTTON_CANCEL, getLocale(), getCtx());\r\n        errorMessageArticleNotFound = getTranslation(TMS.ERROR_MSG_ARTICLE_NOT_FOUND_IN_NEGATIV, getLocale(), getCtx());\r\n        errorMessageArticleNotFoundTitle = getTranslation(TMS.ERROR_MSG_ARTICLE_NOT_FOUND_IN_NEGATIV_TITLE, getLocale(),\r\n                getCtx());\r\n        errorMessageNotAllowed = getTranslation(TMS.ERROR_MSG_NOT_ALLOWED_TO_REMOVE_FROM_FILTER, getLocale(), getCtx());\r\n        errorMessageNotAllowedTitle = getTranslation(TMS.ERROR_MSG_NOT_ALLOWED_TO_REMOVE_FROM_FILTER_TITLE, getLocale(),\r\n                getCtx());\r\n        this.selected = selected;\r\n        cancelBtn = new Button();\r\n        cancelBtn.setText(getTranslation(TMS.GLB_BUTTON_CANCEL, getLocale(), getCtx()));\r\n        cancelBtn.addClickListener(evCancel -> uiClose());\r\n    }\r\n\r\n    /**\r\n     * The load function is responsible for loading the data into the dialog.\r\n     * It also sets up all of the buttons and their listeners, as well as any other UI elements that are needed.\r\n     */\r\n    @Override\r\n    protected void load() throws DoubleFoundException, ArticleBaseQueueException {\r\n\r\n        setLabel(TMS.DND_DIALOG_GET_REASON);\r\n        deActiveIndeterminate();\r\n\r\n        String acceptTMS = getTranslation(TMS.GLB_BUTTON_ACCEPT, getLocale(), getCtx());\r\n        String cancelTMS = getTranslation(TMS.GLB_BUTTON_CANCEL, getLocale(), getCtx());\r\n        comment = new TextField(getTranslation(TMS.DND_TEXT_SET_INDIVIDUAL_COMMENT, getLocale(), getCtx()));\r\n        acceptInnerBtn = new Button(acceptTMS);\r\n        CompUtils.removeMSP(bay, \"MP\");\r\n        bay.add(acceptInnerBtn, cancelBtn);\r\n        add(comment, bay);\r\n        acceptInnerBtn.addClickListener(innerEvent -> {\r\n            new Thread(() -> {\r\n                setLabel(TMS.DND_DIALOG_ADD_VARIOUS_ARTICLE);\r\n                getDialogUI().access(() -> remove(comment, bay));\r\n                activeIndeterminate();\r\n\r\n                // Check before\r\n                List<ArticleBase> articles = getCtx().getServices().getArticleBaseService().findAll(getCtx());\r\n\r\n                List<ArticleBase> scan = new ArrayList<>();\r\n                scan.addAll(articles);\r\n                scan.removeIf(item -> item.getComment().isEmpty());\r\n\r\n                scan = filterArticle(selected, scan);\r\n                if (scan.isEmpty()) {\r\n\r\n                    List<ArticleBase> validList = filterArticle(selected, articles);\r\n                    if (scan.isEmpty()) {\r\n                        ConfirmDialog dialog = new ConfirmDialog(errorMessageArticleNotFoundTitle, errorMessageArticleNotFound,\r\n                                cancelTMS, cancel -> uiClose(), acceptTMS, accept -> {\r\n                            confirm(validList);\r\n                        });\r\n                        getDialogUI().access(() -> dialog.open());\r\n                    }\r\n                } else {\r\n                    confirm(scan);\r\n                }\r\n\r\n            }).start();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The confirm function is called when the user clicks on the &quot;Confirm&quot; button.\r\n     * It checks if all articles in the list are valid, and if so, adds them to\r\n     * a positive assortment list. If not, it removes any invalid articles from\r\n     * the list and displays a dialog box asking whether or not to add only those\r\n     * that are valid. If yes is clicked on this dialog box, then only those that\r\n     * are valid will be added to a positive assortment list; otherwise nothing will be added.\r\n     *\r\n     * @param List&lt;ArticleBase&gt; validList Pass the list of articles to be added\r\n     */\r\n    private void confirm(List<ArticleBase> validList) {\r\n\r\n        if (AssortmentUtil.isValid(getCtx(), validList)) {\r\n            addAsPositivList(validList);\r\n            reloadCrumb();\r\n            uiClose();\r\n        } else {\r\n            List<ArticleBase> filtered = AssortmentUtil.removeUnwantedFromList(getCtx(), validList);\r\n            if (filtered.isEmpty()) {\r\n                ConfirmDialog dialog = new ConfirmDialog(errorMessageNotAllowedTitle, errorMessageNotAllowed, cancelTMS,\r\n                        cancel -> uiClose());\r\n                getDialogUI().access(() -> dialog.open());\r\n            } else {\r\n                ConfirmDialog dialog = new ConfirmDialog(errorMessageNotAllowedTitle, errorMessageNotAllowed, cancelTMS,\r\n                        cancel -> uiClose(), acceptTMS, accept -> {\r\n                    addAsPositivList(filtered);\r\n                    reloadDetails();\r\n                    uiClose();\r\n                });\r\n                getDialogUI().access(() -> dialog.open());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterArticle function takes two lists of ArticleBase objects as input.\r\n     * The first list is a list of selected articles, and the second is a list of all available articles.\r\n     * The function returns a new List&lt;ArticleBase&gt; object that contains only those items from the second input parameter (all available articles) that are also present in the first input parameter (selected).\r\n     *\r\n     * @param List&lt;ArticleBase&gt; selected Compare the articles to be selected\r\n     * @param List&lt;ArticleBase&gt; articles Filter the list&lt;articlebase&gt; selected parameter\r\n     * @return A list of articles that are valid\r\n     */\r\n    private List<ArticleBase> filterArticle(List<ArticleBase> selected, List<ArticleBase> articles) {\r\n        Map<String, ArticleBase> compare = new HashMap<String, ArticleBase>();\r\n        // create template\r\n        selected.forEach(item -> compare.put(item.getArticleNr(), null));\r\n        // fill Template with valid Articles\r\n        articles.forEach(item -> {\r\n            if (compare.containsKey(item.getArticleNr()))\r\n                compare.put(item.getArticleNr(), item);\r\n        });\r\n        // remove not Valid Articles\r\n        List<ArticleBase> validList = new ArrayList<ArticleBase>();\r\n        compare.forEach((k, v) -> {\r\n            if (Objects.nonNull(v)) {\r\n                validList.add(v);\r\n            }\r\n        });\r\n        return validList;\r\n    }\r\n\r\n    /**\r\n     * The addAsPositivList function adds the selected articles to a new individual filter.\r\n     *\r\n     * @param Collection&lt;ArticleBase&gt; validArticles Add the articles to the assortment\r\n     */\r\n    private void addAsPositivList(Collection<ArticleBase> validArticles) {\r\n        List<ArticleBase> articles = new ArrayList<ArticleBase>();\r\n        articles.addAll(validArticles);\r\n        Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        // Create Parent\r\n        Filterbase cFilterbase = new Filterbase();\r\n        cFilterbase.setDirection(Filterbase.ADD_INDIVIDUAL);\r\n        cFilterbase.setType(FilterType.INDIVIDUAL);\r\n        cFilterbase.setIdentifier(FilterType.INDIVIDUAL.name());\r\n        String value = comment.getValue();\r\n        if (value.isEmpty())\r\n            value = \"VARIOUS ARTICLE\";\r\n        cFilterbase.setLabel(value);\r\n        cFilterbase.setEntityIdentifier(\r\n                value.replace(\" \", \"-\") + \"#\" + Filterbase.ADD_INDIVIDUAL + \"#\" + assortment.getId());\r\n        cFilterbase.setAssortment(assortment);\r\n        Filterbase parent = getCtx().getServices().getFilterBaseService().save(cFilterbase);\r\n        // Save Childs\r\n        getCtx().getServices().getFilterBaseCustomService().insertArticleInFilterBase(articles, parent);\r\n        // use Filter\r\n        FilterRunUtils.reloadIndividualFilter(getCtx(), this);\r\n        reloadCrumb();\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\DnDIndividualDialogAddAsPositiv.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\DnDIndividualDialogAddAsRemove.java =====\n```\npackage com.hom.ebmw.view.sortment.dialogs;\r\n\r\nimport com.hom.ebmw.exceptions.ArticleBaseQueueException;\r\nimport com.hom.ebmw.exceptions.DoubleFoundException;\r\nimport com.hom.ebmw.jpa.dao.impl.FilterBaseCustomRepository;\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.AssortmentUtil;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.FilterRunUtils;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\nimport com.vaadin.flow.component.button.Button;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class DnDIndividualDialogAddAsRemove\r\n        extends\r\n        CrumbProgressDialog {\r\n\r\n    private Button cancelBtn = null;\r\n    private List<ArticleBase> selected = null;\r\n    private TextField comment = null;\r\n    private Button acceptInnerBtn = null;\r\n    private final HorizontalLayout bay = new HorizontalLayout();\r\n\r\n    /**\r\n     * The DnDIndividualDialogAddAsRemove function is a constructor for the DnDIndividualDialogAddAsRemove class.\r\n     * It takes in a Context, and a List of ArticleBase objects as parameters.\r\n     * The function sets the selected parameter to be equal to the list of ArticleBase objects passed into it.\r\n     * It then creates an instance of Button called cancelBtn, and sets its text to be equal to &quot;Cancel&quot; in whatever language is set by getTranslation().\r\n     *\r\n     * @param Context                 ctx Create the dialog window\r\n     * @param List&lt;ArticleBase&gt; selected Pass the selected articles to the dialog\r\n     * @return A dialog\r\n     */\r\n    public DnDIndividualDialogAddAsRemove(\r\n            Context ctx,\r\n            List<ArticleBase> selected) {\r\n        super(ctx);\r\n        this.selected = selected;\r\n        cancelBtn = new Button();\r\n        cancelBtn.setText(getTranslation(TMS.GLB_BUTTON_CANCEL, getLocale(), getCtx()));\r\n        cancelBtn.addClickListener(evCancel -> uiClose());\r\n    }\r\n\r\n    /**\r\n     * The load function is called when the dialog is opened.\r\n     * It loads all of the components into the dialog and sets up their functionality.\r\n     */\r\n    @Override\r\n    protected void load() throws DoubleFoundException, ArticleBaseQueueException {\r\n        final FilterBaseCustomRepository customService = getCtx().getServices().getFilterBaseCustomService();\r\n\r\n        setLabel(TMS.DND_DIALOG_GET_REASON);\r\n        deActiveIndeterminate();\r\n\r\n        comment = new TextField(getTranslation(TMS.DND_TEXT_SET_INDIVIDUAL_COMMENT, getLocale(), getCtx()));\r\n        acceptInnerBtn = new Button(getTranslation(TMS.GLB_BUTTON_ACCEPT, getLocale(), getCtx()));\r\n\r\n        CompUtils.removeMSP(bay, \"MP\");\r\n        bay.add(acceptInnerBtn, cancelBtn);\r\n        add(comment, bay);\r\n\r\n        acceptInnerBtn.addClickListener(innerEvent -> {\r\n            new Thread(() -> {\r\n                setLabel(TMS.DND_DIALOG_REMOVE_VARIOUS_ARTICLE);\r\n                getDialogUI().access(() -> remove(comment, bay));\r\n                activeIndeterminate();\r\n\r\n                // Check before\r\n                List<ArticleBase> articles = getCtx().getServices().getArticleBaseService().findAll(getCtx());\r\n                articles.removeIf(item -> item.getComment().isEmpty());\r\n                Map<String, ArticleBase> compare = new HashMap<String, ArticleBase>();\r\n                selected.forEach(item -> compare.put(item.getArticleNr(), null));\r\n                articles.forEach(item -> {\r\n                    if (Objects.nonNull(compare.get(item.getArticleNr()))) {\r\n                        compare.put(item.getArticleNr(), item);\r\n                    }\r\n                });\r\n                if (AssortmentUtil.isValid(getCtx(), compare.values())) {\r\n                    Assortment assortment = getCtx().getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n                    Filterbase cFilterbase = new Filterbase();\r\n                    cFilterbase.setDirection(Filterbase.REMOVE_INDIVIDUAL);\r\n                    cFilterbase.setType(FilterType.INDIVIDUAL);\r\n                    cFilterbase.setIdentifier(FilterType.INDIVIDUAL.name());\r\n                    String value = comment.getValue();\r\n                    if (value.isEmpty())\r\n                        value = \"VARIOUS ARTICLE\";\r\n                    cFilterbase.setLabel(value);\r\n                    cFilterbase.setEntityIdentifier(value.replace(\" \", \"-\") + \"#\" + Filterbase.REMOVE_INDIVIDUAL + \"#\" + assortment.getId());\r\n                    cFilterbase.setAssortment(assortment);\r\n                    Filterbase parent = getCtx().getServices().getFilterBaseService().save(cFilterbase);\r\n                    // Save Childs\r\n                    customService.insertArticleInFilterBase(selected, parent);\r\n                    FilterRunUtils.reloadIndividualFilter(getCtx(), null);\r\n                    reloadCrumb();\r\n                    uiClose();\r\n                }\r\n            }).start();\r\n        });\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\view\\sortment\\dialogs\\DnDIndividualDialogAddAsRemove.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-M5PVWW7WwO1CHrCmztBzdtiFPV9HCGmp",
    "created" : 1762171573,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"multiple\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential ClassCastException / NPE in FilterRemoveGrid when casting Grid data provider to ListDataProvider\",\n      \"justification\": \"setSearchFld and setMulitBox assume the grid's DataProvider is a ListDataProvider; if the grid is initialized without a ListDataProvider (e.g., after reload()), the cast will fail and cause a runtime exception, breaking UI interaction.\",\n      \"action\": \"Initialize the grid with a ListDataProvider by default or add instanceof checks before casting; fallback to a generic DataProvider if not a ListDataProvider. Add unit tests covering grid initialization and search/filter actions.\",\n      \"source\": \"FilterRemoveGrid.setSearchFld(), FilterRemoveGrid.setMulitBox(), line 57-78\",\n      \"component\": \"filter-remove-grid\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"Cast to ListDataProvider without validation\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Downloader in FilterRemoveGrid does not populate the download button with actual data\",\n      \"justification\": \"downloadBtn is created but the list of articles is never passed to the button's reloadAsFile lambda, resulting in empty downloads and a confusing user experience.\",\n      \"action\": \"Pass the collected 'articles' list to the download button's supplier (e.g., downloadBtn.reloadAsFile(() -> fileName, () -> ExcelUtils.writeExcelFileOfArticleListPlain(ctx, articles, ...)); Add a test verifying that the downloaded file contains expected rows.\",\n      \"source\": \"FilterRemoveGrid.downloader(), lines 102-108\",\n      \"component\": \"filter-remove-grid\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"articles list never used\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"ConcurrentModification risk in FilterStructureGrid.loadCount when removing items while iterating\",\n      \"justification\": \"loadCount uses list.forEach to modify the same collection (removeIf), which can cause ConcurrentModificationException depending on the underlying collection implementation.\",\n      \"action\": \"Replace forEach with an iterator loop or collect items to remove in a separate list and then call removeAll; add tests for large datasets to ensure no exceptions.\",\n      \"source\": \"FilterStructureGrid.loadCount(), lines 210-222\",\n      \"component\": \"filter-structure-grid\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"list.forEach with list.removeIf\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"StructureTreeFilterGrid.reload modifies the input list while building TreeData\",\n      \"justification\": \"loadCount(list) mutates the provided list (removes items) before TreeData.addItems uses it, potentially breaking parentchild relationships and causing missing nodes in the tree view.\",\n      \"action\": \"Create a copy of the list before calling loadCount or make loadCount return a new filtered collection; verify tree integrity with integration tests.\",\n      \"source\": \"StructureTreeFilterGrid.reload(), lines 165-176\",\n      \"component\": \"structure-tree-filter-grid\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"TreeData.addItems(list, ...)\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"addSubMenu catches NullPointerException and masks other errors\",\n      \"justification\": \"Swallowing NullPointerException hides real permission or configuration problems, making debugging harder and potentially granting access unintentionally.\",\n      \"action\": \"Catch specific exceptions (e.g., AccessDeniedException) only; rethrow or log unexpected NullPointerException with stack trace; add unit tests for permission failures.\",\n      \"source\": \"MainView.addSubMenu(), lines 260-269\",\n      \"component\": \"main-view\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"catch (NullPointerException e)\"\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"BuildAutoSortingDialog.valid flag is immutable and never updated\",\n      \"justification\": \"The 'valid' boolean is always false, making the error handling block unreachable and potentially hiding validation failures during autosorting.\",\n      \"action\": \"Change 'valid' to a mutable field, set it based on actual validation results, and adjust the conditional logic; add tests that trigger the error path.\",\n      \"source\": \"BuildAutoSortingDialog.valid field and load() method, lines 56-73\",\n      \"component\": \"build-auto-sorting-dialog\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"private final boolean valid = false;\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"FilterZinfoGrid.setToLongFilter adds filter on article number instead of comment length\",\n      \"justification\": \"The filter uses Zinfo::getArticleNr to filter items based on comment length, which is semantically incorrect and may produce unexpected results when toggling the 'showtoLong' checkbox.\",\n      \"action\": \"Replace Zinfo::getArticleNr with Zinfo::getComment in dataProvider.addFilter; add unit tests confirming that only long comments are filtered.\",\n      \"source\": \"FilterZinfoGrid.setToLongFilter(), lines 306-322\",\n      \"component\": \"filter-zinfo-grid\",\n      \"impact_scope\": \"low\",\n      \"relations\": null,\n      \"evidence\": \"dataProvider.addFilter(Zinfo::getArticleNr, ...)\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"LogoutView builds redirect URL from property without validation (open redirect risk)\",\n      \"justification\": \"If the logout address is configurable, an attacker could inject a malicious URL, leading to an open redirect vulnerability.\",\n      \"action\": \"Validate the logout address against a whitelist of allowed domains or enforce sameorigin; add security test for URL manipulation.\",\n      \"source\": \"LogoutView constructor, lines 33-38\",\n      \"component\": \"logout-view\",\n      \"impact_scope\": \"securitycritical\",\n      \"relations\": null,\n      \"evidence\": \"String location = services.getProperty().getLogoutAdress() + \\\"/\\\" + PAGE_ROOT;\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"AutoSortingDialog creates duplicate okBtn instances\",\n      \"justification\": \"An okBtn is instantiated earlier and then reinstantiated later, wasting resources and possibly causing event listeners to be attached twice.\",\n      \"action\": \"Instantiate okBtn once, configure it, and reuse; remove the second new Button call. Add a test ensuring only one listener is present.\",\n      \"source\": \"AutoSortingDialog.create(), lines 140-150 and later lines 191-197\",\n      \"component\": \"auto-sorting-dialog\",\n      \"impact_scope\": \"low\",\n      \"relations\": null,\n      \"evidence\": \"okBtn = new Button(...); later okBtn = new Button(...);\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"FilterZinfoGrid.setFillStatus uses mutable HashMap without synchronization\",\n      \"justification\": \"Although UI updates are performed on the UI thread, concurrent accesses from background threads could cause race conditions.\",\n      \"action\": \"Replace mutable map with immutable data class or synchronize access; add concurrency test for UI updates.\",\n      \"source\": \"FilterZinfoGrid.setFillStatus(), lines 260-274\",\n      \"component\": \"filter-zinfo-grid\",\n      \"impact_scope\": \"low\",\n      \"relations\": null,\n      \"evidence\": \"Map<String, Integer> fillStatus = new HashMap<>();\"\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Add safe type checks and default ListDataProvider initialization in FilterRemoveGrid to prevent ClassCastException.\",\n      \"Fix the immutable 'valid' flag in BuildAutoSortingDialog and ensure proper error handling.\",\n      \"Prevent concurrent modification in FilterStructureGrid.loadCount and StructureTreeFilterGrid.reload.\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to output JSON for each file? The prompt: \"You are a senior code reviewer. Analyze each code chunk.\" Probably need to produce one JSON per file? The schema has \"file\" field. Could combine multiple files? Probably separate entries? The instruction says \"max 10 issues per file/chunk\". Might produce a JSON with multiple top-level objects? But schema expects single object with file and issues. Might need separate JSON per file. However the response must be a single JSON object. Maybe we should combine all into one with file indicating multiple? Could list issues across all files, but file path ambiguous. Might choose to output for each file separately? But rule: respond always as a single JSON object exactly in this structure. So maybe we need to output one object for each file sequentially? Not allowed. Must be single JSON. Could include multiple entries in \"issues\" referencing different files, but file field is per object. Could set file as \"multiple\" and list issues with source lines referencing each file.\n\nWe'll produce aggregated issues across all files, file set to \"multiple\". Provide up to 10 issues total across all files (max 10). Need to prioritize biggest issues.\n\nIdentify issues:\n\n1. FilterRemoveGrid: downloader() creates dataProvider from grid before grid initialized? In constructor, initial() called before grid set? In initial() setGrid then downloader uses grid.getDataProvider, but grid not yet has items, may be null DataProvider causing ClassCastException. Also downloadBtn not added if downloadBtn null? Actually downloader sets downloadBtn but never sets its dataProvider items because dataProvider empty. Also reload uses downloadBtn.reloadAsFile with lambda using ExcelUtils.writeExcelFileOfArticleListPlain but doesn't pass list; might be okay.\n\nPotential NPE: In setSearchFld listener, listProvider cast may fail if dataProvider not ListDataProvider.\n\nAlso in setMulitBox filter logic: values list may be empty leading to filter that returns true when comments empty? Might be okay.\n\n2. FilterStructureGrid: reload(List) does loadCount(list) modifies list then adds to TreeData. loadCount modifies collection while iterating? It iterates list.forEach and then removes items later; safe? Might cause ConcurrentModification if same list used later.\n\nAlso in initial(boolean) method, they call filterBaseGrid.addExpandListener that modifies item.getChilds() and removes if childCount==0; but may cause infinite recursion? fine.\n\n3. FilterZinfoGrid: downloader(String type) only runs if type non-null; in reload(list) they call downloader(type) after setting dataProvider. But type variable is set when reload triggered via typeCbx selection; if type null initially, downloadBtn never configured leading to NPE when clicking downloadBtn (null). downloadBtn initialized earlier but reload may not set downloadBtn.reloadAsFile; downloadBtn may be null? Actually downloader(null) called in initial, which does nothing. downloadBtn is instantiated earlier with new DownloadButton(ctx,...). So fine.\n\nPotential issue: setFillStatus uses fillStatus map but not thread-safe.\n\n4. GridLoader interface: no issues.\n\n5. StructureTreeFilterGrid: In reload(List) they call loadCount(list); loadCount modifies list (removes items) then they pass original list to TreeData.addItems which expects hierarchical structure. Removing items may break parent-child relationships.\n\nAlso loadCount uses ctx.getServices().getFilterBaseDBService().countArticle which may be heavy on UI thread.\n\n6. LogoutView: constructor takes Services, closes services, then constructs UI components. Potential security: logout URL built from property, might be open redirect if property malicious.\n\n7. MainView: many issues: use of getTranslation with ctx and locale; but not null checks. UI thread safety? In constructor, they use UI components directly; okay.\n\nPotential issue: In addSubMenu method, catches NullPointerException and rethrows AccessDeniedException, but swallowing other exceptions.\n\nPotential memory leak: storing UI reference in field ui? In MainView they have no UI field.\n\n8. AddProfilFromAssortment: binder.validate called but result not used; they set saveBtn enabled true always; validation may not stop save. Also binder.validate may produce errors but they ignore; they still proceed if binder.isValid true; ok.\n\nPotential security: No CSRF, but Vaadin handles.\n\n9. AutoSortingDialog: uses UI current in okBtn listener but UI field not defined; they call uiClose() method from superclass.\n\nPotential issue: In load, they call setProgressVisible(false) before super maybe fine.\n\n10. BuildAutoSortingDialog: valid field is final boolean set to false, never changed, so if(valid) always false; maybe bug. Also variable valid never set, logic flawed.\n\nAlso many try-catch swallow exceptions without handling.\n\nThus choose top issues: 1) FilterRemoveGrid potential NPE with data provider casting; 2) FilterRemoveGrid downloader not populating articles list for download button; 3) FilterStructureGrid loadCount modifies collection while iterating leading to ConcurrentModification; 4) StructureTreeFilterGrid reload modifies list during processing leading to inconsistent tree; 5) MainView addSubMenu catches NullPointerException generic, masks errors; 6) BuildAutoSortingDialog valid flag never updated leading to unreachable error handling; 7) FilterZinfoGrid setToLongFilter uses dataProvider.addFilter incorrectly may cause unexpected behavior; 8) LogoutView potential open redirect; 9) AutoSortingDialog creates new okBtn twice; duplication; 10) FilterZinfoGrid reload may cause UI thread issues calling ctx.getUserSession().put inside UI thread? Acceptable.\n\nWe'll produce 10 issues.\n\nNow construct JSON."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 2923,
      "prompt_tokens" : 26352,
      "total_tokens" : 29275
    },
    "timings" : {
      "cache_n" : 527,
      "prompt_n" : 25825,
      "prompt_ms" : 19507.856,
      "prompt_per_token_ms" : 0.7553864859632139,
      "prompt_per_second" : 1323.825642346345,
      "predicted_n" : 2923,
      "predicted_ms" : 35395.447,
      "predicted_per_token_ms" : 12.109287375983579,
      "predicted_per_second" : 82.58124272311069
    }
  }
}