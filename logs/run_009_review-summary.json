{
  "timestamp" : "2025-11-03T12:58:31.1533693",
  "index" : 9,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FileParam.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum FileParam {\r\n\r\n\r\n    LOCK(\"LOCK\"),\r\n    CURRENCY(\"CURRENCY\"),\r\n    TERRITORY(\"TERRITORY\"),\r\n    VALID_FROM(\"VALID_FROM\"),\r\n    VALID_TO(\"VALID_TO\"),\r\n    CUSTOMER_TYPE(\"CUSTOMER_TYPE\"),\r\n    CUSTOMER_ID(\"CUSTOMER_ID\"),\r\n    KATALOG_VERSION(\"KATALOG_VERSION\"),\r\n    BASE_ASSORTMENT(\"BASE_ASSORTMENT\"),\r\n    PARTNER_SHORT(\"PARTNER_SHORT\"),\r\n    LANGUAGE(\"LANGUAGE\"),\r\n    FILE_TYPE(\"TYPE\"),\r\n    UPLOAD_BY(\"UPLOAD_BY\"),\r\n    UPLOAD_ON(\"UPLOAD_ON\"),\r\n    ZINFO_TYPE(\"ZINFO_TYPE\"),\r\n    INITIAL(\"INITIAL\"),\r\n    E_CMS(\"E_CMS\"),\r\n    S3_CATALOG(\"S3_CATALOG\"),\r\n    ARTICLE_SIZE(\"ARTICLE_SIZE\"),\r\n    HAS_PRICE(\"HAS_PRIZE\"),\r\n    QUEUE_ON(\"QUEUE_ON\"),\r\n    QUEUE_BY(\"QUEUE_BY\"),\r\n    //Promotion\r\n    AW_NUMBER(\"AW_NUMBER\"),\r\n    NEWSPIC(\"NEWS_PIC\"),\r\n    TITLE_MAP(\"TITLE_MAP\"),\r\n\r\n    ;\r\n    private final String name;\r\n\r\n    FileParam(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FileParam.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FileType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum FileType {\r\n\r\n    XLSX(\"XLSX\"),\r\n    CSV(\"CSV\"),\r\n    TXT(\"TXT\"),\r\n    DAT(\"DAT\"),\r\n    NULL(\"_UNKOWN_\");\r\n\r\n    private final String name;\r\n\r\n    FileType(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FileType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FilterStatus.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic enum FilterStatus {\r\n\r\n    ALL(-1),\r\n    DEFAULT(0),\r\n    NOTPIM(1),\r\n    NOTAPPROVAL(2),\r\n    COUNTRYLOCK(3),\r\n    REMOVEBYFILTER(4),\r\n    VTL_STATUS(5),\r\n    REMOVEBYFILTER_NOTFOUNDINPOSITIV(41),\r\n    REMOVEBYFILTER_REMOVEDBYPOSITIV(42),\r\n    BUFFER(99);\r\n\r\n\r\n    private final int id;\r\n\r\n    FilterStatus(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public static FilterStatus getById(int id) {\r\n        List<FilterStatus> status = Arrays.asList(FilterStatus.values());\r\n        return status.parallelStream()\r\n                .filter(state -> state.getId() == id)\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FilterStatus.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FilterType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum FilterType {\r\n\r\n    GHS_CODES,\r\n    NOTFREE,\r\n    NOTAPPROVAL,\r\n    NOTINPIM,\r\n    NOPRICE,\r\n    BRANDS,\r\n    NOTFOUNDINPOSITIV,\r\n    REMOVEBYPOSTIV,\r\n    CONFIG, /* konfigurierbare Materialien */\r\n    /**\r\n     * STRUCTURE + # + &lt;Structure&gt;\r\n     */\r\n    STRUCTURE,\r\n    STRUCTURE_ARTICLE,\r\n    BASIC_ASSORTMENT,\r\n    INTRASTAT,\r\n    ZUORDNUNG_MATERIAL,\r\n    ARTIKELKLASSE,\r\n    INFOTYPE,\r\n    VTL_STATUS,\r\n    S3_CATALOGS,\r\n    /**\r\n     * COUNTRY_LOCK + # + &lt;Territory&gt;\r\n     */\r\n    COUNTRY_LOCK,\r\n    /**\r\n     * INDIVIDUAL + # + &lt;Individual&gt;\r\n     */\r\n    INDIVIDUAL,\r\n    INDIVIDUAL_ADM\r\n\r\n}\r\n\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\FilterType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\IconImage.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum IconImage {\r\n\r\n    FLOPPY(\"icons/floppy.jpg\", \"floppy\"),\r\n    FLOPPY_DISABLE(\"icons/floppy-disable.jpg\", \"floppy-disable\"),\r\n    HOM_LOGO(\"img/Hoffmann_Logo_2020.png\", \"logo\"),\r\n    HOM_BANNER(\"tmp/banner\", \"banner\"),\r\n    HOM_MAN(\"img/Mann_Rad_2020.gif\", \"progress\"),\r\n    HOM_CUSTOM(\"tmp/progress\", \"progress\"),\r\n    HOM_CUSTOM_FLOPPY(\"tmp/floppy\", \"floppy\"),\r\n    HOM_CUSTOM_FLOPPY_DISABLE(\"tmp/floppy-disable\", \"floppy-disable\"),\r\n    HOM_CUSTOM_BANNER(\"tmp/banner\", \"banner\");\r\n\r\n    private final String path;\r\n    private final String name;\r\n\r\n    IconImage(\r\n            String path,\r\n            String name) {\r\n        this.path = path;\r\n        this.name = name;\r\n    }\r\n\r\n    public String getPath() {\r\n        return path;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\IconImage.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\ImportFile.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum ImportFile {\r\n    PRICEFILE_EXCEL(\"PRICEFILE_EXCEL\"),\r\n    PRICEFILE_TXT(\"PRICEFILE_TXT\"),\r\n    PRICEFILE_DAT(\"PRICEFILE_DAT\"),\r\n    PRICEFILE_CSV(\"PRICEFILE_CSV\"),\r\n    PRICEFILE_MANUAL(\"PRICEFILE_MANUAL\"),\r\n\r\n    ARTICLEFILE_EXCEL(\"ARTICLEFILE_EXCEL\"),\r\n    ARTICLEFILE_DAT(\"ARTICLEFILE_DAT\"),\r\n    ARTICLEFILE_TXT(\"ARTICLEFILE_TXT\"),\r\n    ARTICLEFILE_CSV(\"ARTICLEFILE_CSV\"),\r\n    ARTICLEFILE_MANUAL(\"ARTICLEFILE_MANUAL\");\r\n\r\n    private String name = \"\";\r\n\r\n    ImportFile(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\ImportFile.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\Interval.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum Interval {\r\n    SECOND(2),\r\n    MINUTE(4),\r\n    HOUR(8),\r\n    DAY(16),\r\n    MONTH(32),\r\n    CUSTOM(64);\r\n\r\n    private final int value;\r\n\r\n    Interval(int value) {\r\n        this.value = value;\r\n    }\r\n\r\n    public int getValue() {\r\n        return value;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\Interval.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\ObjectType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum ObjectType {\r\n    IMPEX(\"IMPEX\"),\r\n    IMPEX_INPUT(\"IMPEX_INPUT\"),\r\n    IMPEX_IMPORT(\"IMPEX_IMPORT\"),\r\n    PROMOTION(\"PROMOTION\"),\r\n    PROMOTION_INPUT(\"PROMOTION_INPUT\"),\r\n    PROMOTION_IMPORT(\"PROMOTION_IMPORT\"),\r\n    ECAT(\"ECAT\"),\r\n    ECAT_INPUT(\"ECAT_INPUT\"),\r\n    ECAT_INPUT_POSITIV(\"ECAT_INPUT_POSITIV\"),\r\n    ECAT_IMPORT(\"ECAT_IMPORT\"),\r\n    LA_INPUT(\"LA_INPUT\"),\r\n    LA(\"LA\"),\r\n    INVALID(\"INVALID\"),\r\n    XMLFILE(\"XMLFILE\"),\r\n    BATCHFILES(\"BATCHFILES\"),\r\n    ZINFO(\"ZINFO\"),\r\n    CUSTOMER(\"CUSTOMER\"),\r\n    EMPTY(\"\"),\r\n    BOTH(\"OldVersion\");\r\n    private final String name;\r\n\r\n    ObjectType(final String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\ObjectType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\Params.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum Params {\r\n    ACTIVE_UI(\"ACTIVE_UI\"),\r\n    ACTIVE_TOOL_TIP(\"ACTIVE_TOOL_TIP\"),\r\n    ACTIVE_CUSTOMER(\"LOCALCUSTOMER\"),\r\n    ACTIVE_ASSORTMENT(\"ACTIVE_ASSORTMENT\"),\r\n    ACTIVE_S3_CATALOG(\"ACTIVE_S3_CATALOG\"),\r\n    ACTIVE_DATAFILE(\"ACTIVE_DATAFILE\"),\r\n    ACTIVE_FILTER(\"ACTIV_FILTER\"),\r\n    ACTIVE_BREADBOX(\"ACTIVE_BREADBOX\"),\r\n    ACTIVE_LOCALE(\"ACTIVE_LOCALE\"),\r\n    ACTIVE_ARTICLES(\"ACTIVE_ARTILCES\"),\r\n    ACTIVE_ARTICLE_BASE_TABLE(\"ACTIVE_ARTICLE_BASE_TABLE\"),\r\n    ACTIVE_INDIVIDUAL_PROVIDER(\"ACTIVE_INDIVIDUAL_PROVIDER\"),\r\n    ACTIVE_INDIVIDUAL_DOWNLOAD(\"ACTIVE_INDIVIDUAL_DOWNLOAD\"),\r\n    ACTIVE_INDIVIDUAL_FILTER(\"ACTIVE_INDIVIDUAL_FILTER\"),\r\n    ACTIVE_IMPORT_PROVIDER(\"ACTIVE_IMPORT_PROVIDER\"),\r\n    ACTIVE_ZINFO_GRID(\"ACTIVE_ZINFO_GRID\"),\r\n    ACTIVE_INFO_BOX(\"ACTIVE_INFO_BOX\"),\r\n    ACTIVE_DIS(\"ACTIVE_DIS\"),\r\n    ACTIVE_TYPE(\"ACTIVE_TYPE\"),\r\n    ACTIVE_PAGE_PARAMETERS(\"ACTIVE_PAGE_PARAMETERS\"),\r\n    SETTING_LAYOUT(\"SETTING_LAYOUT\"),\r\n    HAS_NOTAPPROVAL(\"HAS_APPROVAL\"),\r\n    HAS_NOTINPIM(\"HAS_NOTINPIM\"),\r\n    HAS_NOTFOUND(\"HAS_NOTFOUND\"),\r\n    HAS_NOTPOSITIV(\"HAS_NOTPOSITIV\"),\r\n    HAS_INVALID_VTL_STATUS(\"HAS_INVALID_VTL_STATUS\");\r\n\r\n    private final String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    Params(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\Params.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\PlannedType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum PlannedType {\r\n\r\n    LAGERSTATUS(1),\r\n    INFOTYPE(2),\r\n    ARTIKELKLASSE(3),\r\n    ZUORDNUNG_MATERIAL(4),\r\n    SAP_VTL_STATUS(5);\r\n\r\n    private final int value;\r\n\r\n    public int getValue() {\r\n        return value;\r\n    }\r\n\r\n    PlannedType(int value) {\r\n        this.value = value;\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\PlannedType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\ProjectType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum ProjectType {\r\n    ECAT,\r\n    IMPEX,\r\n    FACETTE\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\ProjectType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SectionVisible.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\nimport lombok.Getter;\r\n\r\npublic enum SectionVisible {\r\n    LEFT_MIDDLE(true, true, false), MIDDLE(false, true, false), LEFT_MIDDLE_RIGHT(true, true, true),\r\n    MIDDLE_RIGHT(false, true, true);\r\n\r\n    private final @Getter boolean left;\r\n    private final @Getter boolean middle;\r\n    private final @Getter boolean right;\r\n\r\n    SectionVisible(boolean left, boolean middle, boolean right) {\r\n        this.left = left;\r\n        this.middle = middle;\r\n        this.right = right;\r\n    }\r\n\r\n    public static SectionVisible valueOf(boolean left, boolean right) {\r\n        SectionVisible result = null;\r\n        for (SectionVisible visible : SectionVisible.values()) {\r\n            if (visible.isLeft() == left && visible.isRight() == right) {\r\n                result = visible;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SectionVisible.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SessionParams.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum SessionParams {\r\n    ACTIVE_ROLE(\"ACTIVE_ROLE\"),\r\n    ACTIVE_PROJECT(\"ACTIVE_PROJECT\"),\r\n    ACTIVE_PROJECT_ROLE(\"ACTIVE_PROJECT_ROLE\"),\r\n    ACTIVE_CUSTOMER(\"LOCALCUSTOMER\"),\r\n    LOCALE(\"LOCALE\"),\r\n    VAADINSESSION(\"com.vaadin.flow.server.VaadinSession.springServlet\"),\r\n    SPRINGLOCK(\"springServlet.lock\"),\r\n    AUTHORIZATION_REQUEST(\"org.springframework.security.oauth2.client.web.HttpSessionOAuth2AuthorizationRequestRepository.AUTHORIZATION_REQUEST\"),\r\n    AUTHORIZED_CLIENTS(\"com.azure.spring.aad.JacksonHttpSessionOAuth2AuthorizedClientRepository.AUTHORIZED_CLIENTS\"),\r\n    SPRING_SECURITY_CONTEXT(\"SPRING_SECURITY_CONTEXT\");\r\n\r\n    private final String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    SessionParams(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SessionParams.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SettingDataType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum SettingDataType {\r\n    DATE,\r\n    DATE_TIME,\r\n    TEXT,\r\n    AREA,\r\n    PATH,\r\n    BOOLEAN,\r\n    PROFIL,\r\n    KATALOGVERSION,\r\n    PARTNERSHORT,\r\n    STRUCTURE,\r\n    STRUCTURE_TREE,\r\n    CUSTOMER_PREFIX,\r\n    ZINFO,\r\n    CUSTOMER_LANGUAGE,\r\n    LANGUAGE,\r\n    S3_CATALOG,\r\n    HOLD_ON\r\n    /*,TEMPLATE */\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SettingDataType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SettingType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum SettingType {\r\n    UPLOAD_FOLDER_CUSTOMER(\"UPLOAD_FOLDER_CUSTOMER\", \"\", SettingDataType.TEXT),\r\n    UPLOAD_FOLDER_ASSORTMENT(\"UPLOAD_FOLDER_ASSORTMENT\", \"\", SettingDataType.TEXT),\r\n    UPLOAD_FOLDER_TEMP(\"UPLOAD_FOLDER_TEMP\", \"\", SettingDataType.TEXT),\r\n    UPLOAD_FOLDER_SETTINGS(\"UPLOAD_FOLDER_SETTINGS\", \"\", SettingDataType.TEXT),\r\n    MAINTENANCE_LOGIN(\"MAINTENANCE_LOGIN\", \"\", SettingDataType.TEXT),\r\n    MAINTENANCE_MESSAGE(\"MAINTENANCE_MESSAGE\", \"\", SettingDataType.TEXT),\r\n    MAINTENANCE_END_DATE(\"MAINTENANCE_END_DATE\", \"\", SettingDataType.DATE),\r\n    MAINTENANCE_SET_DATE(\"MAINTENANCE_SET_DATE\", \"\", SettingDataType.DATE),\r\n    MAINTENANCE_PROGRESS_IMAGE(\"MAINTENANCE_PROGRESS_IMAGE\", \"\", SettingDataType.PATH),\r\n    MAINTENANCE_SAVE_IMAGE(\"MAINTENANCE_SAVE_IMAGE\", \"\", SettingDataType.PATH),\r\n    MAINTENANCE_SAVE_DISABLED_IMAGE(\"MAINTENANCE_SAVE_DISABLED_IMAGE\", \"\", SettingDataType.PATH),\r\n    MAINTENANCE_BANNER_IMAGE(\"MAINTENANCE_BANNER_IMAGE\", \"\", SettingDataType.PATH),\r\n    MAINTENANCE_MANUAL_LINK(\"MAINTENANCE_MANUAL_LINK\", \"\", SettingDataType.TEXT),\r\n    DEFAULT_CATALOGVERSION(\"DEFAULT_CATALOGVERSION\", \"\", SettingDataType.KATALOGVERSION),\r\n    DEFAULT_ECAT_STRUCUTURE_NAME(\"DEFAULT_ECAT_STRUCUTURE_NAME\", \"ecat\", SettingDataType.STRUCTURE_TREE),\r\n    DEFAULT_IMPEX_STRUCUTURE_NAME(\"DEFAULT_IMPEX_STRUCUTURE_NAME\", \"eshop\", SettingDataType.STRUCTURE_TREE),\r\n    DEFAULT_CUSTOMER_PREFIX(\"DEFAULT_CUSTOMER_PREFIX\", \"\", SettingDataType.TEXT),\r\n    DEFAULT_AUTO_SORT_PROFIL(\"DEFAULT_AUTO_SORT_PROFIL\", \"\", SettingDataType.PROFIL),\r\n    IMPEX_PARTNER_SHORT(\"IMPEX_PARTNER_SHORT\", \"\", SettingDataType.PARTNERSHORT),\r\n    ECAT_ZINFO_DESCRIPTION(\"ECAT_ZINFO_DESCRIPTION\", \"\", SettingDataType.ZINFO),\r\n    STRUCTURE_CLASS(\"STRUCTURE_CLASS\", \"\", SettingDataType.STRUCTURE),\r\n    S3_CATALOG_DEFINITION(\"S3_CATALOG_DEFINITION\", \"\", SettingDataType.S3_CATALOG),\r\n    ARTICLE_BASE_TIME_OUT(\"ARTICLE_BASE_TIME_OUT\", \"\", SettingDataType.TEXT),\r\n    CUSTOMER_LANGUAGE(\"CUSTOMER_LANGUAGE\", \"\", SettingDataType.LANGUAGE),\r\n    CUSTOMER_LANGUAGE_DEFAULT(\"CUSTOMER_LANGUAGE_DEFAULT\", \"\", SettingDataType.TEXT),\r\n    UPLOAD_SCHEDULER(\"UPLOAD_SCHEDULER\", \"\", SettingDataType.TEXT);\r\n\r\n    private final String value;\r\n    private final String optional;\r\n    private final SettingDataType dataType;\r\n\r\n    SettingType(String value, String optional, SettingDataType dataType) {\r\n        this.value = value;\r\n        this.optional = optional;\r\n        this.dataType = dataType;\r\n    }\r\n\r\n    public String create() {\r\n        return value;\r\n    }\r\n\r\n    public String getOptional() {\r\n        return optional;\r\n    }\r\n\r\n    public SettingDataType getDataType() {\r\n        return dataType;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\SettingType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\UserParameterType.java =====\n```\npackage com.hom.ebmw.utilities.enums;\r\n\r\npublic enum UserParameterType {\r\n    CUSTOMER_PREFIX,\r\n    CUSTOMER_EDITABLE,\r\n    CUSTOMER_WRITE,\r\n    CUSTOMER_DELETE\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\enums\\UserParameterType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ExcelUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.jpa.model.Zinfo;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.vaadin.flow.component.gridpro.GridPro;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\nimport com.vaadin.flow.i18n.I18NProvider;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.openxml4j.exceptions.InvalidFormatException;\r\nimport org.apache.poi.ss.usermodel.*;\r\nimport org.apache.poi.xssf.streaming.SXSSFSheet;\r\nimport org.apache.poi.xssf.streaming.SXSSFWorkbook;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.sql.Date;\r\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class ExcelUtils {\r\n\r\n    private ExcelUtils() {\r\n        log.debug(\"init ExcelUtils\");\r\n    }\r\n\r\n    /**\r\n     * The readExcelFile function reads an Excel file and returns a List of Maps.\r\n     * Each Map represents a row in the Excel file, with the key being the column number (starting at 0) and\r\n     * value being the cell contents. The function will return an empty list if there is no data to read or\r\n     * if there is any error reading from disk. If you want to know what went wrong, check your logs!\r\n     *\r\n     * @param File inputFile Read the file\r\n     * @return A list of maps\r\n     */\r\n    public static List<Map<Integer, String>> readExcelFile(File inputFile) throws InvalidFormatException {\r\n\r\n        List<Map<Integer, String>> table = new ArrayList<>();\r\n\r\n        if (Objects.nonNull(inputFile)) {\r\n            try (Workbook book = WorkbookFactory.create(inputFile)) {\r\n                Sheet validSheet = null;\r\n                Iterator<Sheet> iterator = book.sheetIterator();\r\n                while (iterator.hasNext()) {\r\n                    validSheet = iterator.next();\r\n                    if (validSheet.iterator().hasNext()) {\r\n                        break;\r\n                    }\r\n                }\r\n                for (int i = 0; i <= validSheet.getLastRowNum(); i++) {\r\n                    Row row = validSheet.getRow(i);\r\n\r\n                    Map<Integer, String> tableRow = new HashMap<>();\r\n                    for (int colNum = 0; colNum < row.getLastCellNum(); colNum++) {\r\n                        try {\r\n                            Cell cell = row.getCell(colNum, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);\r\n                            tableRow.put(colNum, getCellType(cell));\r\n                        } catch (Exception e) {\r\n                            log.error(\"could not read (\" + e.getClass().getCanonicalName() + \") row [\" + i + \"] | col  [\" + colNum + \"]\");\r\n                        }\r\n\r\n\r\n                    }\r\n                    table.add(tableRow);\r\n                }\r\n\r\n                // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            } catch (FileNotFoundException fe) {\r\n                log.error(\"File:\" + inputFile.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n            } catch (Exception ie) {\r\n                log.error(\"File:\" + inputFile.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n            }\r\n        } else {\r\n            log.error(\"Could not read File\");\r\n        }\r\n        return table;\r\n    }\r\n\r\n    /**\r\n     * The readfirstLineOfExcelFile function reads the first line of an Excel file and returns a list of strings.\r\n     *\r\n     * @param File inputFile Get the file name and path\r\n     * @return A list&lt;list&lt;string&gt;&gt;\r\n     */\r\n    public static List<List<String>> readfirstLineOfExcelFile(File inputFile) throws InvalidFormatException {\r\n        List<List<String>> table = new ArrayList<>();\r\n        try (Workbook book = WorkbookFactory.create(inputFile)) {\r\n            Sheet validSheet = null;\r\n            Iterator<Sheet> iterator = book.sheetIterator();\r\n            while (iterator.hasNext()) {\r\n                validSheet = iterator.next();\r\n                if (validSheet.iterator().hasNext()) {\r\n                    break;\r\n                }\r\n            }\r\n            Row row = validSheet.getRow(0);\r\n            List<String> tableRow = new ArrayList<>();\r\n            for (int colNum = 0; colNum < row.getLastCellNum(); colNum++) {\r\n                Cell cell = row.getCell(colNum, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);\r\n                tableRow.add(getCellType(cell));\r\n            }\r\n            table.add(tableRow);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + inputFile.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (Exception ie) {\r\n            log.error(\"File:\" + inputFile.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return table;\r\n    }\r\n\r\n    /**\r\n     * The getCellType function takes a cell as an argument and returns the type of data contained in that cell.\r\n     *\r\n     * @param Cell cell Get the cell type of a particular cell\r\n     * @return The cell value as a string\r\n     */\r\n    public static String getCellType(Cell cell) {\r\n        String sResult = \"\";\r\n        CellType type = cell.getCellType();\r\n        switch (type) {\r\n            case STRING:\r\n                sResult = cell.getStringCellValue();\r\n                break;\r\n            case BOOLEAN:\r\n                sResult = String.valueOf(cell.getBooleanCellValue());\r\n                break;\r\n            case NUMERIC:\r\n                if (DateUtil.isCellDateFormatted(cell)) {\r\n                    DateFormat formatter = new SimpleDateFormat(\"dd.MM.YYYY\");\r\n                    sResult = formatter.format(cell.getDateCellValue());\r\n                } else {\r\n                    DataFormatter format = new DataFormatter();\r\n                    sResult = format.formatCellValue(cell);\r\n                }\r\n                break;\r\n            case FORMULA:\r\n                sResult = cell.getRichStringCellValue().getString();\r\n                break;\r\n            case BLANK:\r\n            case _NONE:\r\n            default:\r\n                sResult = \"\";\r\n                break;\r\n        }\r\n        return sResult;\r\n    }\r\n\r\n    /**\r\n     * The addCell function creates a new cell in the given row and column,\r\n     * then sets its value to the given string.\r\n     *\r\n     * @param Row     row Create a new cell in the row\r\n     * @param int     col Specify the column number of the cell\r\n     * @param boolean value Set the value of the cell\r\n     */\r\n    public static void addCell(Row row, int col, boolean value) {\r\n        Cell cell = row.createCell(col);\r\n        cell.setCellValue(value);\r\n    }\r\n\r\n    /**\r\n     * The addCell function creates a new cell in the given row and column,\r\n     * then sets its value to the given value.\r\n     *\r\n     * @param Row  row Create a new cell in the row\r\n     * @param int  col Specify the column number in which to create a cell\r\n     * @param Date value Set the value of a cell\r\n     */\r\n    public static void addCell(Row row, int col, Date value) {\r\n        Cell cell = row.createCell(col);\r\n        cell.setCellValue(value);\r\n    }\r\n\r\n    /**\r\n     * The addCell function creates a new cell in the given row and column,\r\n     * then sets its value to the given string.\r\n     *\r\n     * @param Row    row Create a new row in the excel sheet\r\n     * @param int    col Specify the column number\r\n     * @param String value Set the value of a cell\r\n     */\r\n    public static void addCell(Row row, int col, String value) {\r\n        Cell cell = row.createCell(col);\r\n        cell.setCellValue(value);\r\n    }\r\n\r\n    /**\r\n     * The addCell function creates a new cell in the given row and column,\r\n     * then sets its value to the given integer.\r\n     *\r\n     * @param Row row Create a new cell in the row\r\n     * @param int col Specify the column number of the cell\r\n     * @param int value Set the value of the cell\r\n     */\r\n    public static void addCell(Row row, int col, int value) {\r\n        Cell cell = row.createCell(col);\r\n        cell.setCellValue(value);\r\n    }\r\n\r\n    /**\r\n     * The addCell function creates a new cell in the given row and column,\r\n     * then sets its value to the given float.\r\n     *\r\n     * @param Row   row Specify the row in which to create the cell\r\n     * @param int   col Specify which column the cell is being added to\r\n     * @param float value Set the value of the cell\r\n     */\r\n    public static void addCell(Row row, int col, float value) {\r\n        Cell cell = row.createCell(col);\r\n        cell.setCellValue(value);\r\n    }\r\n\r\n    /**\r\n     * The addCell function creates a new cell in the given row and column,\r\n     * then sets its value to the given double.\r\n     *\r\n     * @param Row    row Create a new cell in the row\r\n     * @param int    col Determine which column the cell will be placed in\r\n     * @param double value Set the value of the cell\r\n     */\r\n    public static void addCell(Row row, int col, double value) {\r\n        Cell cell = row.createCell(col);\r\n        cell.setCellValue(value);\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfArticleList4IMPEX function is used to write an Excel file of the article list for IMPEX.\r\n     *\r\n     * @param Context                 ctx Get the session locale and to get the translation service\r\n     * @param List&lt;ArticleBase&gt; table Store the list of articles that will be written to the excel file\r\n     * @param String                  xPath Create a temporary file\r\n     * @param String                  firstSheet Set the name of the first sheet in the excel file\r\n     * @return A file\r\n     */\r\n    public static File writeExcelFileOfArticleList4IMPEX(Context ctx, List<ArticleBase> table, String xPath,\r\n                                                         String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try {\r\n            output = new File(xPath);\r\n\r\n            SXSSFWorkbook book = new SXSSFWorkbook();\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_IMPEX_ARTICLE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_IMPEX_PRODUCT_NAME, locale, ctx));\r\n\r\n            // Data\r\n            for (ArticleBase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n\r\n                addCell(row, iCol++, tableRow.getArticleNr());\r\n                addCell(row, iCol++, tableRow.getProductName());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            book.close();\r\n            outputStream.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfArticleList4ECAT function creates an Excel file with the following columns:\r\n     * Customer Article Number, Article Number, Product Name, Price First (Price 1), Price Scale (Price X), Scale Limit and Comment.\r\n     *\r\n     * @param Context                 ctx Get the translation service and locale\r\n     * @param List&lt;ArticleBase&gt; table Store the data that is going to be written in the excel file\r\n     * @param String                  xPath Create a temporary file\r\n     * @param String                  firstSheet Name the first sheet in the excel file\r\n     * @return A file object\r\n     */\r\n    public static File writeExcelFileOfArticleList4ECAT(Context ctx, List<ArticleBase> table, String xPath,\r\n                                                        String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try {\r\n            output = new File(xPath);\r\n\r\n            SXSSFWorkbook book = new SXSSFWorkbook();\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_CUSTOMER_ARTICLE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_ARTICLE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_PRODUCT_NAME, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_PRICE_FIRST, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_PRICE_SCALE, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_SCALE_LIMIT, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_COMMENT, locale, ctx));\r\n\r\n            // Data\r\n            for (ArticleBase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n\r\n                addCell(row, iCol++, tableRow.getCustomerArticleNr());\r\n                addCell(row, iCol++, tableRow.getArticleNr());\r\n                addCell(row, iCol++, tableRow.getProductName());\r\n                addCell(row, iCol++, tableRow.getPriceFirst());\r\n                addCell(row, iCol++, tableRow.getPriceX());\r\n                addCell(row, iCol++, tableRow.getScalelimit());\r\n                addCell(row, iCol++, tableRow.getComment());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            book.close();\r\n            outputStream.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfArticleListPlain function is used to write a list of articles into an Excel file.\r\n     *\r\n     * @param Context                 ctx Get the translation service and locale\r\n     * @param List&lt;ArticleBase&gt; table Pass in the list of articles that are to be written into the excel file\r\n     * @param String                  xPath Define the path of the file to be created\r\n     * @param String                  firstSheet Name the first sheet in the excel file\r\n     * @return A file\r\n     */\r\n    public static File writeExcelFileOfArticleListPlain(Context ctx, List<ArticleBase> table, String xPath,\r\n                                                        String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try {\r\n            output = new File(xPath);\r\n\r\n            SXSSFWorkbook book = new SXSSFWorkbook();\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_CUSTOMER_ARTICLE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_ARTICLE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_PRICE_FIRST, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_PRICE_SCALE, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_SCALE_LIMIT, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_COMMENT, locale, ctx));\r\n\r\n            // Data\r\n            for (ArticleBase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n\r\n                addCell(row, iCol++, tableRow.getCustomerArticleNr());\r\n                addCell(row, iCol++, tableRow.getArticleNr());\r\n                addCell(row, iCol++, tableRow.getPriceFirst());\r\n                addCell(row, iCol++, tableRow.getPriceX());\r\n                addCell(row, iCol++, tableRow.getScalelimit());\r\n                addCell(row, iCol++, tableRow.getComment());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            book.close();\r\n            outputStream.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfFilterbasePlain function is used to write a list of Filterbase objects into an Excel file.\r\n     *\r\n     * @param Context                ctx Get the translation service and the locale\r\n     * @param List&lt;Filterbase&gt; table Create a table of the filterbase type\r\n     * @param String                 xPath Create a temporary file\r\n     * @param String                 firstSheet Name the first sheet in the excel file\r\n     * @return A file object\r\n     */\r\n    public static File writeExcelFileOfFilterbasePlain(Context ctx, List<Filterbase> table, String xPath,\r\n                                                       String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try {\r\n            output = new File(xPath);\r\n\r\n            SXSSFWorkbook book = new SXSSFWorkbook();\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_ARTICLE_NR, locale, ctx));\r\n\r\n            // Data\r\n            for (Filterbase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n\r\n                addCell(row, iCol++, tableRow.getLabel());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            book.close();\r\n            outputStream.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfFilterbaseExclude function writes the Filterbase table to an Excel file.\r\n     *\r\n     * @param Context                ctx Get the session locale and translation service\r\n     * @param List&lt;Filterbase&gt; table Get the data from the table\r\n     * @param String                 xPath Create a temp file for the excel sheet\r\n     * @param String                 firstSheet Name the first sheet in the excel file\r\n     * @return A file object\r\n     */\r\n    public static File writeExcelFileOfFilterbaseExclude(Context ctx, List<Filterbase> table, String xPath,\r\n                                                         String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try {\r\n            output = new File(xPath);\r\n\r\n            SXSSFWorkbook book = new SXSSFWorkbook();\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ECAT_ARTICLE_NR, locale, ctx));\r\n\r\n            // Data\r\n            for (Filterbase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n\r\n                addCell(row, iCol++, tableRow.getIdentifier());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            book.close();\r\n            outputStream.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfZinfoList function writes a list of Zinfo objects to an Excel file.\r\n     *\r\n     * @param Context           ctx Get the session locale and translation service\r\n     * @param List&lt;Zinfo&gt; table Create a list of zinfo objects\r\n     * @param String            xPath Create a temporary file\r\n     * @param String            firstSheet Name the first sheet in the excel file\r\n     * @return A file object\r\n     */\r\n    public static File writeExcelFileOfZinfoList(Context ctx, List<Zinfo> table, String xPath, String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        File output = null;\r\n\r\n        try (SXSSFWorkbook book = new SXSSFWorkbook()) {\r\n            output = new File(xPath);\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ZINFO_ARTICLE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ZINFO_ARTICLE_DESCRIPTION, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(\"previewComment\", locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_ZINFO_COMMENT, locale, ctx));\r\n\r\n            // Data\r\n            for (Zinfo tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n\r\n                addCell(row, iCol++, tableRow.getArticleNr());\r\n                addCell(row, iCol++, tableRow.getArticleDescription());\r\n                addCell(row, iCol++, tableRow.getPreview_comment());\r\n                addCell(row, iCol++, tableRow.getComment());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            /* Close workbook, OutputStream and Excel file to prevent leak os.close(); */\r\n            outputStream.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeZinfoFile function takes a context and an xPath as parameters.\r\n     * It creates a temporary file using the SettingUtils class, then it gets the active Zinfo grid from the user session.\r\n     * It then creates a ListDataProvider of type Zinfo and adds all items to it.\r\n     * Then it creates an empty list of type Zinfo called data, which is populated with all items in dataProvider.\r\n     * Finally, writeZinfoFile returns writeExcelFileOfZInfoList(ctx,data,xPath) where ctx is passed through as-is but xPath has been replaced by data's\r\n     *\r\n     * @param Context ctx Get the usersession\r\n     * @param String  xPath Create a temporary file\r\n     * @return A file object\r\n     */\r\n    public static File writeZinfoFile(Context ctx, String xPath) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n\r\n        GridPro<Zinfo> zinfoGrid = ctx.getUserSession().get(Params.ACTIVE_ZINFO_GRID);\r\n        @SuppressWarnings(\"unchecked\")\r\n        ListDataProvider<Zinfo> dataProvider = (ListDataProvider<Zinfo>) zinfoGrid.getDataProvider();\r\n\r\n        List<Zinfo> data = new ArrayList<>();\r\n        data.addAll(dataProvider.getItems());\r\n\r\n        return writeExcelFileOfZinfoList(ctx, data, xPath, data.get(0).getType());\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileAsMap function takes a list of maps and writes them to an Excel file.\r\n     *\r\n     * @param Context               ctx Create the temporary file\r\n     * @param List&lt;Map&lt;String Create a table of values\r\n     * @param Object&gt;&gt;        table Create a table in the excel file\r\n     * @param String                xPath Create a temporary file\r\n     * @param String                firstSheet Create a sheet in the excel file\r\n     * @return A file\r\n     */\r\n    public static File writeExcelFileAsMap(Context ctx, List<Map<String, Object>> table, String xPath,\r\n                                           String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n        try (SXSSFWorkbook book = new SXSSFWorkbook()) {\r\n            output = new File(xPath);\r\n\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(\r\n                    firstSheet.replaceAll(\"[\\\\[]\", \"(\").replaceAll(\"[\\\\]]\", \")\").replaceAll(\"[/\\\\\\\\&:?! ]\", \"_\"));\r\n            int iRow = 0;\r\n            for (Map<String, Object> tableRow : table) {\r\n                Row row = sheet.createRow(iRow++);\r\n                int iCol = 0;\r\n                for (String tableCell : tableRow.keySet()) {\r\n                    addCell(row, iCol++, String.valueOf(tableRow.get(tableCell)));\r\n                }\r\n            }\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            outputStream.close();\r\n            book.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileAsList function takes a list of lists and writes it to an Excel file.\r\n     *\r\n     * @param Context                        ctx Create a temporary file\r\n     * @param List&lt;List&lt;String&gt;&gt; table Store the data that will be written to the excel file\r\n     * @param String                         xPath Create a temporary file\r\n     * @param String                         firstSheet Name the first sheet in the excel file\r\n     * @return A file object\r\n     */\r\n    public static File writeExcelFileAsList(Context ctx, List<List<String>> table, String xPath, String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n        try (SXSSFWorkbook book = new SXSSFWorkbook()) {\r\n            output = new File(xPath);\r\n\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int iRow = 0;\r\n            for (List<String> tableRow : table) {\r\n                Row row = sheet.createRow(iRow++);\r\n                int iCol = 0;\r\n                for (String tableCell : tableRow) {\r\n                    addCell(row, iCol++, tableCell);\r\n                }\r\n            }\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            outputStream.close();\r\n            book.close();\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFile function takes a Map of Maps as an argument. The outer map is keyed by the row number, and the inner map is keyed by column number.\r\n     * The value in each cell is stored as a String in the innermost Map.\r\n     * This function creates an Excel file with one sheet, and writes all of these values to that sheet.\r\n     *\r\n     * @param Context        ctx Create a temporary file\r\n     * @param Map&lt;Integer Store the row number and the map&lt;integer, string&gt; is used to store\r\n     *                       the column number and value\r\n     * @param Map&lt;Integer Store the row number and column number of each cell in the excel file\r\n     * @param String&gt;&gt; table Create a table in the excel file\r\n     * @param String         xPath Create a temporary file\r\n     * @param String         firstSheet Name the first sheet in the excel file\r\n     * @return A file object\r\n     */\r\n    public static File writeExcelFile(Context ctx, Map<Integer, Map<Integer, String>> table, String xPath,\r\n                                      String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        try (SXSSFWorkbook book = new SXSSFWorkbook()) {\r\n            output = new File(xPath);\r\n\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n            int rowLine = 0;\r\n            for (int rowNum : table.keySet()) {\r\n                Row row = sheet.createRow(rowLine++);\r\n                for (int column : table.get(rowNum).keySet()) {\r\n                    addCell(row, column, table.get(rowNum).get(column));\r\n                }\r\n            }\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n            outputStream.close();\r\n\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfArticleNrAndComment function takes a list of ArticleBase objects and writes them to an Excel file.\r\n     * The function is called by the writeExcelFileOfArticleNrAndComment function in the ExportService class.\r\n     *\r\n     * @param Context                 ctx Get the current session and locale\r\n     * @param List&lt;ArticleBase&gt; table Write the data to the excel file\r\n     *                                public static file writeexcelfileofarticlenrandcomment(context ctx, list&lt;articlebase&gt; table, string xpath) {\r\n     *                                return writeexcelfileofarticlenrandcomment(ctx, table, xpath, &quot;sheet 1&quot;);\r\n     *                                }\r\n     * @param String                  xPath Create a temporary file\r\n     * @param String                  firstSheet Name the first sheet in the excel file\r\n     * @return The file\r\n     */\r\n    public static File writeExcelFileOfArticleNrAndComment(Context ctx, List<ArticleBase> table, String xPath,\r\n                                                           String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try (SXSSFWorkbook book = new SXSSFWorkbook()) {\r\n            output = new File(xPath);\r\n\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_FILTER_ARTILCE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_FILTER_COMMENT, locale, ctx));\r\n\r\n            // Data\r\n            for (ArticleBase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n                addCell(row, iCol++, tableRow.getArticleNr());\r\n                addCell(row, iCol++, tableRow.getComment());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            // Close workbook, OutputStream and Excel file to prevent leak os.close();\r\n            book.close();\r\n            outputStream.close();\r\n\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * The writeExcelFileOfArticleNrAndDescription function takes a list of ArticleBase objects and writes them to an Excel file.\r\n     * The function is called by the writeExcelFileOfArticleNrAndDescription function in the ExportService class.\r\n     *\r\n     * @param Context                 ctx Get the session locale\r\n     * @param List&lt;ArticleBase&gt; table Get the data from the table\r\n     * @param String                  xPath Create a temporary file\r\n     * @param String                  firstSheet Create the name of the first sheet in the excel file\r\n     * @return A file\r\n     */\r\n    public static File writeExcelFileOfArticleNrAndDescription(Context ctx, List<ArticleBase> table, String xPath,\r\n                                                               String firstSheet) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File output = null;\r\n\r\n        I18NProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        try (SXSSFWorkbook book = new SXSSFWorkbook()) {\r\n            output = new File(xPath);\r\n\r\n            book.setCompressTempFiles(true);\r\n            SXSSFSheet sheet = book.createSheet(firstSheet);\r\n\r\n            int iRow = 0;\r\n            int iCol = 0;\r\n\r\n            // Header\r\n            Row row = sheet.createRow(iRow++);\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_FILTER_ARTILCE_NR, locale, ctx));\r\n            addCell(row, iCol++, i18n.getTranslation(TMS.EXCEL_GRID_FILTER_DESCRIPTION, locale, ctx));\r\n\r\n            // Data\r\n            for (ArticleBase tableRow : table) {\r\n                row = sheet.createRow(iRow++);\r\n                iCol = 0;\r\n                addCell(row, iCol++, tableRow.getArticleNr());\r\n                addCell(row, iCol++, tableRow.getComment());\r\n            }\r\n\r\n            FileOutputStream outputStream = new FileOutputStream(output);\r\n            book.write(outputStream);\r\n\r\n            outputStream.close();\r\n\r\n        } catch (FileNotFoundException fe) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + fe.getLocalizedMessage(), fe);\r\n        } catch (IOException ie) {\r\n            log.error(\"File:\" + output.getName() + \" with error: \" + ie.getLocalizedMessage(), ie);\r\n        }\r\n        return output;\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ExcelUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ExportFileUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.exceptions.ConvertException;\r\nimport com.hom.ebmw.exceptions.FileCouldNotFoundException;\r\nimport com.hom.ebmw.ipim.model.Currency;\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.model.Territory;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.*;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.*;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class ExportFileUtils {\r\n\r\n    private static final String KEY = \"S2P\";\r\n\r\n    /**\r\n     * The convertCustomerNumber function takes a String as an argument and returns a String.\r\n     * The function removes the first four characters of the input string if they contain an underscore,\r\n     * otherwise it returns the original string.  This is used to convert customer numbers from their raw form in\r\n     * our database to their display form on our website.\r\n     *\r\n     * @param String customerNumber Pass the customer number to the function\r\n     * @return The customer number without the start\r\n     */\r\n    private static String convertCustomerNumber(String customerNumber) {\r\n        String result = \"\";\r\n        String start = customerNumber.substring(0, 4);\r\n        if (start.contains(\"_\")) {\r\n            result = customerNumber.replace(start, \"\");\r\n        } else {\r\n            result = customerNumber;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The buildPositivFileName function builds a file name for the Positivliste.\r\n     * The file name is built in the following format:\r\n     * #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION##TIMESTAMP##FILEEXTENSION.txt\r\n     * where:\r\n     * - #PRAEFIX is either &quot;ECAT&quot; or &quot;CUSTOMER&quot;, depending on whether it's an ECat or Customer list, respectively; and, if it's a customer list, then which customer (i.\r\n     *\r\n     * @param Context ctx Get the active customer and the katalog version\r\n     * @param AstFile file Get the katalogversion\r\n     * @return positivFileName\r\n     */\r\n    public static String buildPositivFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer)) {\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n            ctx.getUserSession().put(Params.ACTIVE_CUSTOMER, customer);\r\n        }\r\n        String customerNr = customer.getCustomerId();\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n\r\n        return getPrefix(ctx, customer, \"ECAT\") + \"_Positivliste_\" + customerNr + \"_\" + katalog.getVersion() + \"_\"\r\n                + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n    }\r\n\r\n    /**\r\n     * The buildPriceFileName function is used to create a filename for the price file.\r\n     * The name of the file is created by concatenating several strings together, including:\r\n     * - A prefix (which can be set in the configuration)\r\n     * - The type of list (in this case &quot;DEBKON&quot;)\r\n     * - The customer ID number from SAP Business One. This number must be unique for each customer. It's also used as part of their login credentials when they log into eCatalog Manager.\r\n     * - The version number of the catalog that was exported to them, which will always match their current catalog\r\n     *\r\n     * @param Context ctx Access the session and other parameters\r\n     * @param AstFile file Get the katalogversion, language, currency and territory\r\n     * @return priceFileName\r\n     */\r\n    public static String buildPriceFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n\r\n        String name = \"\";\r\n        if (Objects.nonNull(currency) && Objects.nonNull(lang) && Objects.nonNull(territory))\r\n            name = getPrefix(ctx, customer, \"ECAT\") + \"_\" + KEY + \"_DEBKON_-_\" + customer.getCustomerId() + \"_\"\r\n                    + katalog.getVersion() + \"_\" + lang.getLabel().split(\"-\")[0] + \"-\" + territory.getKey() + \"_\"\r\n                    + currency.getKey() + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        else\r\n            name = getPrefix(ctx, customer, \"ECAT\") + \"_\" + KEY + \"_DEBKON_-_\" + customer.getCustomerId() + \"_\"\r\n                    + katalog.getVersion() + \"_\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * The buildImpexFileName function is used to create a file name for the impex file.\r\n     * The function takes in a context and an AstFile as parameters.\r\n     * It then creates LocalCustomer, KatalogVersion, Language, Currency and Territory objects from the context and AstFile.\r\n     * If all of these objects are not null it will set the name variable to be equal to:\r\n     * getPrefix(ctx, customer,&quot;IMPEX&quot;) + &quot;_&quot; + KEY + &quot;_IMPEX_-_&quot; + customer.getCustomerId()\r\n     * + &quot;_&quot;+ katalog.getVersion() + &quot;_&quot;+ lang\r\n     *\r\n     * @param Context ctx Retrieve the active customer and the catalog version\r\n     * @param AstFile file Get the catalog version\r\n     * @return The file name of the impex file\r\n     */\r\n    public static String buildImpexFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n\r\n        String name = \"\";\r\n        if (Objects.nonNull(currency) && Objects.nonNull(lang) && Objects.nonNull(territory))\r\n            name = getPrefix(ctx, customer, \"IMPEX\") + \"_\" + KEY + \"_IMPEX_-_\" + customer.getCustomerId() + \"_\"\r\n                    + katalog.getVersion() + \"_\" + lang.getLabel().split(\"-\")[0] + \"-\" + territory.getKey() + \"_\"\r\n                    + currency.getKey() + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        else\r\n            name = getPrefix(ctx, customer, \"IMPEX\") + \"_\" + KEY + \"_IMPEX_-_\" + customer.getCustomerId() + \"_\"\r\n                    + katalog.getVersion() + \"_\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * The buildPromotionFileName function is used to create a file name for the promotion file.\r\n     * The function takes in a context and an AstFile as parameters, and returns a String that contains the filename.\r\n     *\r\n     * @param Context ctx Get the parameters from the file\r\n     * @param AstFile file Get the parameters for the file name\r\n     * @return The file name of the promotion file\r\n     */\r\n    public static String buildPromotionFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n        String awnr = CompUtils.getParameter(ctx, FileParam.AW_NUMBER, file);\r\n        if (Objects.isNull(awnr)) awnr = \"IMPORT\";\r\n\r\n        String name = \"\";\r\n        if (Objects.nonNull(currency) && Objects.nonNull(lang) && Objects.nonNull(territory))\r\n            name = \"HOH_\" + KEY + \"_PROMODEBKON_\" + awnr + \"_\"\r\n                    + lang.getLabel().split(\"-\")[0] + \"-\" + territory.getKey() + \"_\" + currency.getKey() + \"xx\"\r\n                    + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        else\r\n            name = \"HOH_\" + KEY + \"_PROMODEBKON_\" + awnr + \"_\"\r\n                    + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * The buildPromotionTitleFileName function builds a file name for the promotion title file.\r\n     *\r\n     * @param Context ctx Get the aw number from the file\r\n     * @param AstFile file Get the aw number from the file\r\n     * @return A file name that is used to create a promotion title file\r\n     */\r\n    public static String buildPromotionTitleFileName(Context ctx, AstFile file) {\r\n        String awnr = CompUtils.getParameter(ctx, FileParam.AW_NUMBER, file);\r\n\r\n        return \"HOH_S2P_PROMOTITLES_\" + awnr + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n    }\r\n\r\n    /**\r\n     * The buildImpexPriceFileName function is used to build the name of the file that will be generated.\r\n     * The function takes in a context and an AstFile as parameters, and returns a String.\r\n     *\r\n     * @param Context ctx Get the active customer and the katalog version\r\n     * @param AstFile file Get the katalogversion katalog\r\n     * @return ImpexFileName\r\n     */\r\n    public static String buildImpexPriceFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n\r\n        String name = \"\";\r\n        if (Objects.nonNull(currency) && Objects.nonNull(lang) && Objects.nonNull(territory))\r\n            name = getPrefix(ctx, customer, \"IMPEX\") + \"_\" + KEY + \"_IMPEXDEBKON_-_\" + customer.getCustomerId() + \"_\"\r\n                    + katalog.getVersion() + \"_\" + lang.getLabel().split(\"-\")[0] + \"-\" + territory.getKey() + \"_\"\r\n                    + currency.getKey() + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        else\r\n            name = getPrefix(ctx, customer, \"IMPEX\") + \"_\" + KEY + \"_IMPEX_-_\" + customer.getCustomerId() + \"_\"\r\n                    + katalog.getVersion() + \"_\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * The buildIMPEXParameterFileName function is used to create a file name for the IMPEX parameter file.\r\n     * The function takes in a context and an AstFile as parameters, and returns the filename as a String.\r\n     *\r\n     * @param Context ctx Get the active customer, language, currency and territory\r\n     * @param AstFile file Get the catalog version\r\n     * @return ImpexParameterFileName\r\n     */\r\n    public static String buildIMPEXParameterFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n\r\n        return getPrefix(ctx, customer, \"IMPEX\") + \"_eC2P_IMPSTRUCTURE_\" + \"-\"\r\n                // Replaced CustomerName (Names for Chinese could not be displayed)\r\n                + \"_\" + customer.getCustomerId() + \"_\" + katalog.getVersion() + \"_\" + lang.getLabel().split(\"-\")[0]\r\n                + \"-\" + territory.getKey() + \"_\" + currency.getKey() + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\")\r\n                + \".txt\";\r\n    }\r\n\r\n    /**\r\n     * The buildECATParameterFileName function builds a filename for the ECAT parameter file.\r\n     * The function takes in a Context object and an AstFile object as parameters.\r\n     * The function returns a String that is the name of the ECAT parameter file.\r\n     *\r\n     * @param Context ctx Get the current user session and to get the active customer\r\n     * @param AstFile file Get the katalogversion, language, currency and territory\r\n     * @return The name of the file to be created\r\n     */\r\n    public static String buildECATParameterFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n\r\n        return getPrefix(ctx, customer, \"ECAT\") + \"_eC2P_STRUCTURE_\"\r\n                // Replaced CustomerName (Names for Chinese could not be displayed)\r\n                + customer.getCustomerId() + \"_\" + katalog.getVersion() + \"_\" + lang.getLabel().split(\"-\")[0] + \"-\"\r\n                + territory.getKey() + \"_\" + currency.getKey() + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\")\r\n                + \".txt\";\r\n    }\r\n\r\n    /**\r\n     * The buildZinfoFileName function is used to create a filename for the ZINFO file.\r\n     * The function takes in a Context, an infoType (which is either &quot;ZINFO&quot; or &quot;ZINFOD&quot;),\r\n     * and an AstFile as parameters. It then creates a LocalCustomer object from the ACTIVE_CUSTOMER parameter of the context,\r\n     * and if that fails it tries to get it from the SessionParams instead. Next, it gets KatalogVersion katalog by calling CompUtils' getKatalogVersion function with ctx and file as parameters;\r\n     * Language lang by calling Comp\r\n     *\r\n     * @param Context ctx Get the session parameters\r\n     * @param String  infoType Determine the type of information to be written in the file\r\n     * @param AstFile file Get the parameters for the file name\r\n     * @return ZinfoFileName\r\n     */\r\n    public static String buildZinfoFileName(Context ctx, String infoType, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n        Language lang = CompUtils.getParameter(ctx, FileParam.LANGUAGE, file);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, file);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, file);\r\n\r\n        return getPrefix(ctx, customer) + \"_ZINFO_\" + infoType + \"_-_\" + customer.getCustomerId() + \"_\"\r\n                + katalog.getVersion() + \"_\" + lang.getLabel().split(\"-\")[0] + \"-\" + territory.getKey() + \"_\"\r\n                + currency.getKey() + \"xx\" + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n    }\r\n\r\n    /**\r\n     * The buildZIPFileName function is used to create a file name for the ZIP file that will be created.\r\n     * The function takes in a Context object and an AstFile object as parameters.\r\n     * It then creates a LocalCustomer object from the ACTIVE_CUSTOMER parameter of the user session, or if it doesn't exist,\r\n     * it creates one from the HTTP attribute SessionParams.ACTIVE_CUSTOMER and puts it into Params.ACTIVE_CUSTOMER of\r\n     * user session so that we can use this customer later on in our code without having to recreate them every time we need them\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @param AstFile file Get the katalogversion from the file\r\n     * @return ZipFileName\r\n     */\r\n    public static String buildZIPFileName(Context ctx, AstFile file) {\r\n        // #PRAEFIX#_#LISTENTYP#_#KUNDENNUMMER#_#KATALOGVERSION#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer)) {\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n            ctx.getUserSession().put(Params.ACTIVE_CUSTOMER, customer);\r\n        }\r\n        String customerNr = customer.getCustomerId();\r\n        KatalogVersion katalog = CompUtils.getKatalogVersion(ctx, file);\r\n\r\n        return getPrefix(ctx, customer) + \"_\" + convertCustomerNumber(customerNr) + \"_\" + katalog.getVersion() + \"_\"\r\n                + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".zip\";\r\n    }\r\n\r\n    /**\r\n     * The buildCustomerFileName function is used to create a file name for the customer's data.\r\n     * The function takes in a Context object as an argument, and returns a String that contains the file name.\r\n     * The function first gets the active customer from either the user session or HTTP attribute, depending on which one exists.\r\n     * It then gets their ID number and stores it in a variable called &quot;customerNumber&quot;.\r\n     * Next, it creates another variable called &quot;role&quot; that stores what role they are logged into (either admin or employee).\r\n     * Finally, it uses these variables to build up its return string using Parse's\r\n     *\r\n     * @param Context ctx Get the active customer and role from the session\r\n     * @return CustomerFileName\r\n     */\r\n    public static String buildCustomerFileName(Context ctx) {\r\n        // #PRAEFIX#_S2P_DEBITOR_#KUNDENNUMMER#_#TIMESTAMP#.txt\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        Role role = ctx.getSession().get(SessionParams.ACTIVE_ROLE);\r\n        if (Objects.isNull(customer)) {\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n            ctx.getUserSession().put(Params.ACTIVE_CUSTOMER, customer);\r\n        }\r\n        String customerNumber = customer.getCustomerId();\r\n\r\n        return role.getName() + \"_\" + KEY + \"_DEBITOR_-_\" + customerNumber + \"_\"\r\n                + Parse.getTimeStamp(\"yyyy-MM-dd_hh-mm-ss\") + \".txt\";\r\n    }\r\n\r\n    /**\r\n     * The buildPriceFile function takes a collection of ArticleBase objects, and creates a file with the following format:\r\n     * <p>\r\n     * Kundenartikelnummer\tStrukturzuweisung\tArtikelnummer\tWhrung\tPreis (ab 1) Preis (ab x) Staffelgrenze Gltig ab Gltig bis Kunde Preistyp Sprache KatalogVersion\r\n     *\r\n     * @param Context                       ctx Get the user session\r\n     * @param Collection&lt;ArticleBase&gt; articles Get the list of articles that need to be exported\r\n     * @param String                        xPath Create a temporary file\r\n     * @param AstFile                       astFile Get the parameters from the file\r\n     * @return A file\r\n     */\r\n    public static File buildPriceFile(Context ctx, Collection<ArticleBase> articles, String xPath, AstFile astFile) {\r\n        File file = null;\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        file = new File(xPath);\r\n        FileWriter fw = null;\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n\r\n        List<ArticleBase> articleList = new ArrayList<>();\r\n        articleList.addAll(articles);\r\n\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, astFile);\r\n        Language language = CompUtils.getParameter(ctx, FileParam.LANGUAGE, astFile);\r\n        LocalDate validFrom = CompUtils.getParameter(ctx, FileParam.VALID_FROM, astFile);\r\n        LocalDate validTo = CompUtils.getParameter(ctx, FileParam.VALID_TO, astFile);\r\n        KatalogVersion katalog = CompUtils.getParameter(ctx, FileParam.KATALOG_VERSION, astFile);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, astFile);\r\n\r\n        try {\r\n            log.info(\"buildPriceFile: PricesListSize: \" + articleList.size());\r\n\r\n            String content = \"\";\r\n            fw = new FileWriter(file);\r\n//\t\t\t\tcontent = \"Kundenartikelnummer\\tSprache\\tGltigkeitsgebiet\\tArtikelnummer\\tWhrung\\tPreis (ab1)\\tPreis (ab x)\\tStaffelgrenze\\tGltig ab\\tGltig bis\\tKunde\\tKatalogversion\\tPreistyp\\n\";\r\n            content = \"Kundenartikelnummer\\tStrukturzuweisung\\tArtikelnummer\\tWhrung\\tPreis (ab1)\\tPreis (ab x)\\tStaffelgrenze\\tGltig ab\\tGltig bis\\tKunde\\tPreistyp\\tSprache\\tKatalogversion\\n\";\r\n\r\n            fw.write(content);\r\n            content = String.format(\"\\t%s\\t999999 Dummy4Delete\\t%s\\t0\\t\\t\\t%s\\t%s\\t%s\\t%s\\n\",\r\n                    InternalUtils.placeIfNull(Objects.isNull(territory) ? \"\" : territory.getKey()),\r\n                    InternalUtils.placeIfNull(Objects.isNull(currency) ? \"\" : currency.getKey()),\r\n                    InternalUtils\r\n                            .placeIfNull(Objects.isNull(validFrom) ? \"\" : Parse.formatDate(validFrom, AstDateFormat.GERMAN)),\r\n                    InternalUtils.placeIfNull(Objects.isNull(validTo) ? \"\" : Parse.formatDate(validTo, AstDateFormat.GERMAN)),\r\n                    customer.getCustomerId(), \"3\");\r\n            fw.write(content);\r\n            for (ArticleBase price : articleList) {\r\n                content = String.format(\"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\",\r\n                        InternalUtils.placeIfNull(price.getCustomerArticleNr()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(territory) ? \"\" : territory.getKey()),\r\n                        InternalUtils.placeIfNull(price.getArticleNr()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(currency) ? \"\" : currency.getKey()),\r\n                        Parse.formatToPrice(price.getPriceFirst()), Parse.formatToPrice(price.getPriceX()),\r\n                        InternalUtils.placeIfNull(price.getScalelimit()),\r\n                        InternalUtils\r\n                                .placeIfNull(Objects.isNull(validFrom) ? \"\" : Parse.formatDate(validFrom, AstDateFormat.FLAT)),\r\n                        InternalUtils.placeIfNull(Objects.isNull(validTo) ? \"\" : Parse.formatDate(validTo, AstDateFormat.FLAT)),\r\n                        customer.getCustomerId(), \"\",\r\n                        InternalUtils.placeIfNull(Objects.isNull(language) ? \"\" : language.getLabel()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(katalog) ? \"\" : katalog.getVersion()));\r\n                fw.write(content);\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (Exception e) {\r\n            log.error(\"buildPriceFile: with error \" + e.getLocalizedMessage());\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The buildPromotionTitleFile function creates a file with the following format:\r\n     * StructureGruppe\tVaterKennung\tWerbeTitel\tSprache\r\n     * AW_NUMBER_LANGUAGE-TERRITORY  YEAR   TITLE    LANGUAGE-TERRITORY\r\n     *\r\n     * @param Context ctx Get the file path from the settings\r\n     * @param String  xPath Create a temporary file\r\n     * @param AstFile astFile Get the parameters from the file\r\n     * @return A file containing the title of a promotion\r\n     */\r\n    public static File buildPromotionTitleFile(Context ctx, String xPath,\r\n                                               AstFile astFile) {\r\n        File file = null;\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        file = new File(xPath);\r\n        FileWriter fw = null;\r\n\r\n        LocalDate validFrom = CompUtils.getParameter(ctx, FileParam.VALID_FROM, astFile);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, astFile);\r\n        Language language = CompUtils.getParameter(ctx, FileParam.LANGUAGE, astFile);\r\n        List<MultiLanguage> multiMap = CompUtils.getParameter(ctx, FileParam.TITLE_MAP, astFile);\r\n        String awNumber = CompUtils.getParameter(ctx, FileParam.AW_NUMBER, astFile);\r\n        try {\r\n            log.info(\"buildPriceFile: PricesListSize: \" + multiMap.size());\r\n\r\n            String content = \"\";\r\n            fw = new FileWriter(file);\r\n            content = \"StructureGruppe\\tVaterKennung\\tWerbeTitel\\tSprache\\n\";\r\n\r\n            fw.write(content);\r\n            for (MultiLanguage lang : multiMap) {\r\n                content = String.format(\"%s\\t%s\\t%s\\t%s\\n\",\r\n                        awNumber + \"_\" + language.getKey().split(\"-\")[0] + territory.getKey(), String.valueOf(validFrom.getYear()),\r\n                        lang.getValue(), lang.getKey().getKey());\r\n                fw.write(content);\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (Exception e) {\r\n            log.error(\"buildPriceFile: with error \" + e.getLocalizedMessage(), e);\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The buildPromotionFile function is used to create a file containing the promotion prices for articles.\r\n     *\r\n     * @param Context                       ctx Get the customer\r\n     * @param Collection&lt;ArticleBase&gt; articles Pass in a list of articles to the function\r\n     * @param String                        xPath Create a temporary file\r\n     * @param AstFile                       astFile Get the parameters for the file\r\n     * @return A file that contains the promotion data\r\n     */\r\n    public static File buildPromotionFile(Context ctx, Collection<ArticleBase> articles, String xPath,\r\n                                          AstFile astFile) {\r\n        File file = null;\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        file = new File(xPath);\r\n        FileWriter fw = null;\r\n\r\n        List<ArticleBase> articleList = new ArrayList<ArticleBase>();\r\n        articleList.addAll(articles);\r\n\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, astFile);\r\n        LocalDate validFrom = CompUtils.getParameter(ctx, FileParam.VALID_FROM, astFile);\r\n        LocalDate validTo = CompUtils.getParameter(ctx, FileParam.VALID_TO, astFile);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, astFile);\r\n        String awNumber = CompUtils.getParameter(ctx, FileParam.AW_NUMBER, astFile);\r\n\r\n        try {\r\n            log.info(\"buildPriceFile: PricesListSize: \" + articleList.size());\r\n\r\n            String content = \"\";\r\n            fw = new FileWriter(file);\r\n            content = \"Kundenartikelnummer\\tStrukturzuweisung\\tArtikelnummer\\tWhrung\\tPreis (ab1)\\tPreis (ab x)\\tStaffelgrenze\\tGltig ab\\tGltig bis\\tKunde\\tPreistyp\\tAW-Nummer\\n\";\r\n\r\n            fw.write(content);\r\n            for (ArticleBase price : articleList) {\r\n                content = String.format(\"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\",\r\n                        InternalUtils.placeIfNull(price.getCustomerArticleNr()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(territory) ? \"\" : territory.getKey()),\r\n                        InternalUtils.placeIfNull(price.getArticleNr()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(currency) ? \"\" : currency.getKey()),\r\n                        Parse.formatToPrice(price.getPriceFirst()), Parse.formatToPrice(price.getPriceX()),\r\n                        InternalUtils.placeIfNull(price.getScalelimit()),\r\n                        InternalUtils\r\n                                .placeIfNull(Objects.isNull(validFrom) ? \"\" : Parse.formatDate(validFrom, AstDateFormat.FLAT)),\r\n                        InternalUtils.placeIfNull(Objects.isNull(validTo) ? \"\" : Parse.formatDate(validTo, AstDateFormat.FLAT)),\r\n                        \"<ffentlich>\", \"Werbepreis (Netto)\",\r\n                        InternalUtils.placeIfNull(Objects.isNull(awNumber) ? \"\" : awNumber));\r\n                fw.write(content);\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (Exception e) {\r\n            log.error(\"buildPriceFile: with error \" + e.getLocalizedMessage(), e);\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The buildImpexFile function is used to create a file that contains the data for all of the articles in a given collection.\r\n     * The function takes in three parameters:\r\n     *\r\n     * @param Context                       ctx Get the current session\r\n     * @param Collection&lt;ArticleBase&gt; articles Create a list of articles to be used in the impex file\r\n     * @param String                        xPath Create a temporary file\r\n     * @param AstFile                       astFile Get the parameters for the impex file\r\n     * @return A file\r\n     */\r\n    public static File buildImpexFile(Context ctx, Collection<ArticleBase> articles, String xPath, AstFile astFile) {\r\n        File file = null;\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        file = new File(xPath);\r\n        FileWriter fw = null;\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n\r\n        List<ArticleBase> articleList = new ArrayList<ArticleBase>();\r\n        articleList.addAll(articles);\r\n\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, astFile);\r\n        Language language = CompUtils.getParameter(ctx, FileParam.LANGUAGE, astFile);\r\n        LocalDate validFrom = CompUtils.getParameter(ctx, FileParam.VALID_FROM, astFile);\r\n        LocalDate validTo = CompUtils.getParameter(ctx, FileParam.VALID_TO, astFile);\r\n        KatalogVersion katalog = CompUtils.getParameter(ctx, FileParam.KATALOG_VERSION, astFile);\r\n        Currency currency = CompUtils.getParameter(ctx, FileParam.CURRENCY, astFile);\r\n        PartnerShort shorty = CompUtils.getParameter(ctx, FileParam.PARTNER_SHORT, astFile);\r\n        CustomerType cType = CompUtils.getParameter(ctx, FileParam.CUSTOMER_TYPE, astFile);\r\n\r\n        try {\r\n            log.info(\"buildPriceFile: PricesListSize: \" + articleList.size());\r\n\r\n            String content = \"\";\r\n            fw = new FileWriter(file);\r\n            content = \"Artikelnummer|Kunde|Krzel|Sprache|Gltigkeitsgebiet|Whrung|Partnerkrzel|Kundentyp|Gltig ab|Gltig bis|Katalogversion\\n\";\r\n            fw.write(content);\r\n            if (ctx.getUserSession().exists(Params.ACTIVE_S3_CATALOG)) {\r\n                content = String.format(\"999999 Dummy4Delete|%s|S3||\\n\", customer.getCustomerId());\r\n            } else {\r\n                content = String.format(\"999999 Dummy4Delete|%s|||\\n\", customer.getCustomerId());\r\n            }\r\n\r\n            fw.write(content);\r\n            for (ArticleBase price : articleList) {\r\n                content = String.format(\"%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s\\n\",\r\n                        InternalUtils.placeIfNull(price.getArticleNr()), customer.getCustomerId(),\r\n                        price.isS3Catalog() ? \"S3\" : \"\",\r\n                        InternalUtils.placeIfNull(Objects.isNull(language) ? \"\" : language.getLabel().split(\"-\")[0]),\r\n                        InternalUtils.placeIfNull(Objects.isNull(territory) ? \"\" : territory.getKey()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(currency) ? \"\" : currency.getKey()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(shorty) ? \"\" : shorty.getId()),\r\n                        InternalUtils.placeIfNull(Objects.isNull(cType) ? \"\" : cType.name()),\r\n                        InternalUtils\r\n                                .placeIfNull(Objects.isNull(validFrom) ? \"\" : Parse.formatDate(validFrom, AstDateFormat.FLAT)),\r\n                        InternalUtils.placeIfNull(Objects.isNull(validTo) ? \"\" : Parse.formatDate(validTo, AstDateFormat.FLAT)),\r\n                        InternalUtils.placeIfNull(Objects.isNull(katalog) ? \"\" : katalog.getVersion()));\r\n                fw.write(content);\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (Exception e) {\r\n            log.error(\"buildPriceFile: with error \" + e.getLocalizedMessage());\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The reCreateFileTillLine function takes in a file and creates a new file with the same name as the input file, but only up to a certain line.\r\n     *\r\n     * @param Context ctx Create a temporary file\r\n     * @param File    fileInput Specify the file that will be read from\r\n     * @param String  newFileName Create a new file with the name of the parameter\r\n     * @param int     stopLine Determine how many lines of the fileinput will be written to the new file\r\n     * @return A file with the specified number of lines\r\n     */\r\n    public static File reCreateFileTillLine(Context ctx, File fileInput, String newFileName, int stopLine)\r\n            throws FileCouldNotFoundException, ConvertException {\r\n        String xPath = SettingUtils.createTempFile(ctx, newFileName);\r\n        File fi = new File(xPath);\r\n\r\n        FileWriter fw = null;\r\n        try (BufferedReader br = new BufferedReader(new FileReader(fileInput))) {\r\n            fw = new FileWriter(fi);\r\n\r\n            if (stopLine < 0)\r\n                stopLine = stopLine * -1;\r\n\r\n            for (int i = 0; i < stopLine; i++) {\r\n                fw.write((i != 0 ? \"\\n\" : \"\") + br.readLine());\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (FileNotFoundException e) {\r\n            throw new FileCouldNotFoundException(e.getLocalizedMessage());\r\n        } catch (IOException e) {\r\n            throw new ConvertException(e.getLocalizedMessage());\r\n        } catch (Exception e) {\r\n            throw new ConvertException(e.getLocalizedMessage());\r\n        }\r\n\r\n        return fi;\r\n    }\r\n\r\n    /**\r\n     * The buildZinfoFile function takes a Context, an xPath, a List of Zinfo objects and a String type as parameters.\r\n     * It creates the file at the given xPath location and writes to it using FileWriter.\r\n     * The content written is in CSV format with each line containing information about one article:\r\n     * Article number|Customer Number|Type (Zusatzinfo)|Comment (Zusatzinfo)\r\n     *\r\n     * @param Context           ctx Get the current user session\r\n     * @param String            xPath Create a temporary file\r\n     * @param List&lt;Zinfo&gt; zInfos Get the comment from the zinfo object\r\n     * @param String            type Determine the type of zinfo\r\n     * @return A file\r\n     */\r\n    public static File buildZinfoFile(Context ctx, String xPath, List<Zinfo> zInfos, String type) {\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        File file = new File(xPath);\r\n\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer)) {\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n        }\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        String customerNumber = customer.getCustomerId();\r\n        try {\r\n            String content = \"\";\r\n            FileWriter fw = new FileWriter(file);\r\n            content = \"Artikelnummer|Kunde|Krzel|Zusatzinfo|\\n\";\r\n            fw.write(content);\r\n            content = String.format(\"##Erstellt von:%s|am:%s|mit Datenbasis vom:%s||\\n\",\r\n                    user.getSurName() + \", \" + user.getSurName(), Parse.getDate(),\r\n                    Parse.getTimeStamp(\"yyyy-MM-dd_hh:mm:ss\"));\r\n            fw.write(content);\r\n            content = String.format(\"999999 Dummy4Delete|%s|%s||\\n\", customerNumber, type);\r\n            fw.write(content);\r\n            for (Zinfo zinfo : zInfos) {\r\n                if (Objects.nonNull(zinfo.getComment()) && !zinfo.getComment().isEmpty()) {\r\n                    content = String.format(\"%s|%s|%s|%s|\\n\", zinfo.getArticleNr(), customerNumber, type,\r\n                            zinfo.getComment());\r\n                    fw.write(content);\r\n                }\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (Exception e) {\r\n            log.error(\"buildZinfoFile: with error \" + e.getLocalizedMessage());\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The buildCustomFile function takes a Context, an xPath, a List of Lists of Strings (table), and a delimiter as parameters.\r\n     * It creates the file at the given xPath with the contents of table separated by delimiter.\r\n     *\r\n     * @param Context                        ctx Get the application context\r\n     * @param String                         xPath Create a temporary file\r\n     * @param List&lt;List&lt;String&gt;&gt; table Create a table of data\r\n     * @param String                         delimiter Separate the columns in the table\r\n     * @return A file object\r\n     */\r\n    public static File buildCustomFile(Context ctx, String xPath, List<List<String>> table, String delimiter) {\r\n        File file = null;\r\n\r\n        if (!table.isEmpty()) {\r\n            xPath = SettingUtils.createTempFile(ctx, xPath);\r\n            file = new File(xPath);\r\n            try {\r\n                final FileWriter fw = new FileWriter(file);\r\n                String content = \"\";\r\n                for (List<String> row : table) {\r\n                    String rowValue = \"\";\r\n                    for (String col : row) {\r\n                        rowValue += (rowValue.isEmpty() ? \"\" : delimiter) + col;\r\n                    }\r\n                    content += (content.isEmpty() ? \"\" : \"\\n\") + rowValue;\r\n                }\r\n                fw.write(content);\r\n\r\n                fw.flush();\r\n                fw.close();\r\n            } catch (Exception e) {\r\n                log.error(\"buildPositivFile: with error \" + e.getLocalizedMessage());\r\n            }\r\n        } else {\r\n            log.error(\"buildPositivFile: with error no articles found\");\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The buildPositivFile function takes a list of articles and creates a file with the article numbers.\r\n     *\r\n     * @param Context                 ctx Get the active customer from the session\r\n     * @param List&lt;ArticleBase&gt; articleList Create a list of articles\r\n     * @param String                  xPath Create a temporary file\r\n     * @return A file\r\n     */\r\n    public static File buildPositivFile(Context ctx, List<ArticleBase> articleList, String xPath) {\r\n        File file = null;\r\n\r\n        xPath = SettingUtils.createTempFile(ctx, xPath);\r\n        file = new File(xPath);\r\n        FileWriter fw = null;\r\n\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        if (Objects.isNull(customer))\r\n            customer = ctx.getHttpAttribute(SessionParams.ACTIVE_CUSTOMER);\r\n\r\n        try {\r\n            String content = \"\";\r\n            fw = new FileWriter(file);\r\n            content = \"Artikelnummer|Kunde|Krzel|Zusatzinfo|\\n\";\r\n            fw.write(content);\r\n            customer.getCustomerId();\r\n            for (ArticleBase price : articleList) {\r\n                content = String.format(\"%s|%s|99||\\n\", price.getArticleNr(), customer.getCustomerId());\r\n                fw.write(content);\r\n            }\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (Exception e) {\r\n            log.error(\"buildPositivFile: with error \" + e.getLocalizedMessage());\r\n        }\r\n        return file;\r\n    }\r\n\r\n    /**\r\n     * The getPrefix function is used to get the prefix for a given customer.\r\n     * The function takes in two parameters: a Context object and a LocalCustomer object.\r\n     * It returns the prefix as a StringBuilder object, which can be converted into an actual string by calling .toString() on it.\r\n     *\r\n     * @param Context       ctx Get the setting from the database\r\n     * @param LocalCustomer customer Get the customer prefix from the database\r\n     * @param String        ecatImpex Determine which prefix to use\r\n     * @return The prefix for the customer\r\n     */\r\n    private static String getPrefix(Context ctx, LocalCustomer customer, String ecatImpex) {\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        List<CustomerPrefix> customerPrefixs = SettingUtils.getAllSettingParameterValuesByType(ctx,\r\n                SettingType.DEFAULT_CUSTOMER_PREFIX);\r\n\r\n        Optional<CustomerPrefix> optParam = customerPrefixs.stream()\r\n                .filter(item -> item.getCustomer().getCustomerId().equalsIgnoreCase(customer.getCustomerId()))\r\n                .findFirst();\r\n        optParam.ifPresent(item -> {\r\n            switch (ecatImpex) {\r\n                default:\r\n                case \"ECAT\":\r\n                    sb.append(item.getEcat());\r\n                    break;\r\n                case \"IMPEX\":\r\n                    sb.append(item.getImpex());\r\n                    break;\r\n                case \"PROMOTION\":\r\n                    sb.append(item.getPromotion());\r\n                    break;\r\n            }\r\n        });\r\n        if (sb.length() == 0) {\r\n            Setting settingPrefix = SettingUtils.getSettingByType(ctx, SettingType.DEFAULT_CUSTOMER_PREFIX);\r\n            sb.append(settingPrefix.getValue());\r\n        }\r\n\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * The getPrefix function returns a String that is the prefix for the customer's name.\r\n     * The prefix is either &quot;Mr.&quot; or &quot;Mrs.&quot; depending on whether the customer is male or female.\r\n     * If no gender has been specified, then an empty string will be returned.\r\n     *\r\n     * @param Context       ctx Get the default prefix from the settings\r\n     * @param LocalCustomer customer Get the customer's name and use it to generate a unique prefix\r\n     * @return The value of the default_customer_prefix setting\r\n     * @docauthor Trelent\r\n     */\r\n    private static String getPrefix(Context ctx, LocalCustomer customer) {\r\n        String result = \"\";\r\n\r\n        if (result.isEmpty()) {\r\n            Setting settingPrefix = SettingUtils.getSettingByType(ctx, SettingType.DEFAULT_CUSTOMER_PREFIX);\r\n            result = settingPrefix.getValue();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The saveContentAsFile function takes a file name and content as parameters.\r\n     * It creates a new File object with the given fileName, then writes the content to that file.\r\n     * The function returns the newly created File object.\r\n     *\r\n     * @param String fileName Name the file that will be created\r\n     * @param String content Write the content to a file\r\n     * @return A file object that represents the file created\r\n     */\r\n    public static File saveContentAsFile(String fileName, String content) {\r\n        File file = new File(fileName);\r\n        FileWriter fw = null;\r\n        try {\r\n            fw = new FileWriter(file);\r\n            fw.write(content);\r\n            fw.flush();\r\n            fw.close();\r\n        } catch (NullPointerException e) {\r\n            log.error(\"saveContentAsFile: with error \" + e.getLocalizedMessage());\r\n        } catch (Exception e) {\r\n            log.error(\"saveContentAsFile: with error \" + e.getLocalizedMessage());\r\n        }\r\n        return file;\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ExportFileUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FileTranslatorRepository.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.configuration.ApplicationProperty;\r\nimport com.hom.ebmw.pojo.Translation;\r\nimport com.vaadin.flow.spring.annotation.SpringComponent;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport java.io.*;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.*;\r\nimport java.util.function.Supplier;\r\nimport java.util.stream.Collectors;\r\n\r\n\r\n@Slf4j\r\n@SpringComponent\r\npublic class FileTranslatorRepository {\r\n\r\n\r\n    private final ApplicationProperty prop;\r\n\r\n    @Autowired\r\n    public FileTranslatorRepository(ApplicationProperty prop) {\r\n        this.prop = prop;\r\n    }\r\n\r\n    /**\r\n     * The getTranslator function is used to retrieve the translated value of a given key.\r\n     *\r\n     * @param String key Get the value of a property in the properties file\r\n     * @param Locale locale Determine which language to use\r\n     * @return The value of the key\r\n     */\r\n    public String getTranslator(String key, Locale locale) {\r\n        File translate = new File(prop.getTranslationPath() + File.separator + locale.toLanguageTag() + \".prop\");\r\n        String value = \"\";\r\n\r\n        if (translate.exists()) {\r\n            Reader reader = null;\r\n            try {\r\n                reader = new InputStreamReader(new FileInputStream(translate), StandardCharsets.UTF_8);\r\n                Properties prop = new Properties();\r\n                prop.load(reader);\r\n                value = prop.getProperty(key);\r\n                if (value == null || value.length() == 0) {\r\n                    setTranslator(key, key, locale);\r\n                    value = key;\r\n                }\r\n\r\n            } catch (FileNotFoundException e) {\r\n                log.error(\"ErrorMessage[FileNotExists]: \" + e.getLocalizedMessage());\r\n            } catch (IOException e) {\r\n                log.error(\"ErrorMessage[FileIO]: \" + e.getLocalizedMessage());\r\n            } finally {\r\n                try {\r\n                    reader.close();\r\n                } catch (Exception e) {\r\n                    log.error(\"ErrorMessage[Reader]: \" + e.getLocalizedMessage());\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                translate.createNewFile();\r\n            } catch (IOException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * The getAllTranslations function is used to retrieve all translations from the translation files.\r\n     *\r\n     * @return A list of translation objects\r\n     */\r\n    public List<Translation> getAllTranslations() {\r\n        List<Translation> translations = new ArrayList<Translation>();\r\n        List<Locale> locales = new ArrayList<Locale>();\r\n        Arrays.asList(prop.getTranslationLang().split(\",\")).forEach(langTag -> {\r\n            for (Locale locale : Locale.getAvailableLocales()) {\r\n                if (locale.toLanguageTag().equals(langTag)) {\r\n                    locales.add(locale);\r\n                }\r\n            }\r\n        });\r\n\r\n        File translate = new File(prop.getTranslationPath() + File.separator + locales.get(0).toLanguageTag() + \".prop\");\r\n        if (translate.exists()) {\r\n            Reader reader = null;\r\n            try {\r\n                reader = new InputStreamReader(new FileInputStream(translate), StandardCharsets.UTF_8);\r\n                Properties prop = new Properties();\r\n                prop.load(reader);\r\n                prop.keySet().forEach(propKey -> {\r\n                    Translation translation = new Translation();\r\n                    translation.setKey((String) propKey);\r\n                    translation.setTranslations(new HashMap<String, String>());\r\n                    locales.forEach(local -> {\r\n                        String value = getTranslator(translation.getKey(), local);\r\n                        translation.getTranslations().put(local.toLanguageTag(), value);\r\n                    });\r\n                    translations.add(translation);\r\n                });\r\n            } catch (FileNotFoundException e) {\r\n                log.error(\"ErrorMessage[FileNotExists]: \" + e.getLocalizedMessage());\r\n            } catch (IOException e) {\r\n                log.error(\"ErrorMessage[FileIO]: \" + e.getLocalizedMessage());\r\n            } finally {\r\n                try {\r\n                    reader.close();\r\n                } catch (Exception e) {\r\n                    log.error(\"ErrorMessage[Reader]: \" + e.getLocalizedMessage());\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                translate.createNewFile();\r\n            } catch (IOException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n\r\n    /**\r\n     * The setTranslator function takes in a Translation object and sets the translator to that translation.\r\n     *\r\n     * @param Translation translation Get the translations from the translation class\r\n     */\r\n    public void setTranslator(Translation translation) {\r\n        translation.getTranslations().forEach((key, value) -> {\r\n            setTranslator(translation.getKey(), value, key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The setTranslator function takes in a key, value, and locale.\r\n     * It then creates a new file with the name of the locale's language tag.\r\n     * If that file already exists it will load all of its properties into memory and overwrite the property with\r\n     * the given key to have a value equal to what was passed in as an argument for this function.\r\n     *\r\n     * @param String key Get the value of a key in the translation file\r\n     * @param String value Set the value of the key in the properties file\r\n     * @param Locale locale Determine which translation file to use\r\n     */\r\n    public void setTranslator(String key, String value, Locale locale) {\r\n        File translate = new File(prop.getTranslationPath() + File.separator + locale.toLanguageTag() + \".prop\");\r\n\r\n        if (translate.exists()) {\r\n            Reader reader = null;\r\n            Writer writer = null;\r\n            try {\r\n                reader = new InputStreamReader(new FileInputStream(translate), StandardCharsets.UTF_8);\r\n                Properties prop = new Properties() {\r\n\r\n                    private static final long serialVersionUID = 4112578634029874840L;\r\n\r\n                    @SuppressWarnings(\"rawtypes\")\r\n                    @Override\r\n                    public synchronized Enumeration<Object> keys() {\r\n                        Comparator<Object> byCaseInsensitiveString = Comparator.comparing(Object::toString,\r\n                                String.CASE_INSENSITIVE_ORDER);\r\n\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        Supplier<TreeSet<Object>> supplier = () -> new TreeSet(byCaseInsensitiveString);\r\n\r\n                        TreeSet<Object> sortedSet = super.keySet().stream()\r\n                                .collect(Collectors.toCollection(supplier));\r\n\r\n                        return Collections.enumeration(sortedSet);\r\n                    }\r\n                };\r\n                prop.load(reader);\r\n\r\n                if (value == null || value.length() == 0) {\r\n                    prop.setProperty(key, \"\");\r\n                } else {\r\n                    prop.setProperty(key, value);\r\n\r\n                }\r\n                writer = new OutputStreamWriter(new FileOutputStream(translate), StandardCharsets.UTF_8);\r\n                prop.store(writer, \"Translation-\" + locale.toLanguageTag());\r\n\r\n\r\n            } catch (FileNotFoundException e) {\r\n                log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            } catch (IOException e) {\r\n                log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            } finally {\r\n                try {\r\n                    writer.close();\r\n                } catch (Exception e) {\r\n                    log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n                }\r\n                try {\r\n                    reader.close();\r\n                } catch (Exception e) {\r\n                    log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                translate.createNewFile();\r\n            } catch (IOException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The setTranslator function takes in a key, value, and tag.\r\n     * The function then creates a new file with the name of the tag.prop\r\n     * If that file already exists it will load it into memory and set the property to\r\n     * what was passed in as value for key. It will then save this back to disk overwriting\r\n     * any previous values for that key if they existed or creating them if they did not exist before.\r\n     *\r\n     * @param String key Identify the key in the properties file\r\n     * @param String value Set the value of a key in the properties file\r\n     * @param String tag Identify the file that is to be used for translation\r\n     */\r\n    public void setTranslator(String key, String value, String tag) {\r\n        File translate = new File(prop.getTranslationPath() + File.separator + tag + \".prop\");\r\n\r\n        if (translate.exists()) {\r\n            Reader reader = null;\r\n            Writer writer = null;\r\n            try {\r\n                reader = new InputStreamReader(new FileInputStream(translate), StandardCharsets.UTF_8);\r\n                Properties prop = new Properties() {\r\n\r\n                    private static final long serialVersionUID = 4112578634029874840L;\r\n\r\n                    @SuppressWarnings(\"rawtypes\")\r\n                    @Override\r\n                    public synchronized Enumeration<Object> keys() {\r\n                        Comparator<Object> byCaseInsensitiveString = Comparator.comparing(Object::toString,\r\n                                String.CASE_INSENSITIVE_ORDER);\r\n\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        Supplier<TreeSet<Object>> supplier = () -> new TreeSet(byCaseInsensitiveString);\r\n\r\n                        TreeSet<Object> sortedSet = super.keySet().stream()\r\n                                .collect(Collectors.toCollection(supplier));\r\n\r\n                        return Collections.enumeration(sortedSet);\r\n                    }\r\n                };\r\n                prop.load(reader);\r\n\r\n                if (value == null || value.length() == 0) {\r\n                    prop.setProperty(key, \"\");\r\n                } else {\r\n                    prop.setProperty(key, value);\r\n\r\n                }\r\n                writer = new OutputStreamWriter(new FileOutputStream(translate), StandardCharsets.UTF_8);\r\n                prop.store(writer, \"Translation-\" + tag);\r\n\r\n\r\n            } catch (FileNotFoundException e) {\r\n                log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            } catch (IOException e) {\r\n                log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            } finally {\r\n                try {\r\n                    writer.close();\r\n                } catch (Exception e) {\r\n                    log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n                }\r\n                try {\r\n                    reader.close();\r\n                } catch (Exception e) {\r\n                    log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                translate.createNewFile();\r\n            } catch (IOException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FileTranslatorRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FileUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.utilities.enums.FileType;\r\nimport com.hom.ebmw.utilities.enums.ObjectType;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.poi.openxml4j.exceptions.InvalidFormatException;\r\n\r\nimport java.io.*;\r\nimport java.nio.channels.Channels;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.channels.ReadableByteChannel;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.nio.file.StandardCopyOption;\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\nimport java.util.List;\r\n\r\n@Slf4j\r\npublic class FileUtils {\r\n\r\n    /**\r\n     * The getFileEnd function takes a String fileName as an argument and returns the FileType of that file.\r\n     *\r\n     * @param String fileName Get the file name\r\n     * @return A filetype\r\n     */\r\n    public static FileType getFileEnd(String fileName) {\r\n        fileName = fileName.replace(\".\", \",\");\r\n        String[] values = fileName.split(\",\");\r\n        String value = values[values.length - 1];\r\n        //FileType\r\n        FileType type = null;\r\n        value = value.replace(\",\", \".\").toUpperCase();\r\n        try {\r\n            type = FileType.valueOf(value);\r\n        } catch (IllegalArgumentException e) {\r\n            type = FileType.NULL;\r\n        }\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * The getFileEndAsString function takes a String as an argument and returns the last part of that string.\r\n     *\r\n     * @param String fileName Get the file name\r\n     * @return The end of the file name\r\n     */\r\n    public static String getFileEndAsString(String fileName) {\r\n        fileName = fileName.replace(\".\", \",\");\r\n        String[] values = fileName.split(\",\");\r\n        String value = values[values.length - 1];\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * The getFileEndAsString function takes a file name as input and returns the last three characters of that file name.\r\n     *\r\n     * @param File input Get the name of the file\r\n     * @return The end of a file name as a string\r\n     */\r\n    public static String getFileEndAsString(File input) {\r\n        return getFileEndAsString(input.getName());\r\n    }\r\n\r\n    /**\r\n     * The getFileType function takes a File object as an argument and returns the type of file it is.\r\n     * The function first checks if the file ends with .xlsx, in which case it reads the first line of\r\n     * data from that Excel sheet and determines whether or not there are more than one column. If so,\r\n     * then this is an ECAT input file; otherwise, it's invalid. If the file does not end with .xlsx, then\r\n     * we read in its contents using a BufferedReader object to check for other delimiters (| ; \\t). If none are found,\r\n     *\r\n     * @param File list Get the file path and name\r\n     * @return The type of file that is being processed\r\n     */\r\n    public static ObjectType getFileType(File list) {\r\n        ObjectType sReturnValue = null;\r\n        BufferedReader br = null;\r\n        try {\r\n            while (true) {\r\n                if (list.getPath().toLowerCase().endsWith(\".xlsx\")) {\r\n                    List<List<String>> firstRow = ExcelUtils.readfirstLineOfExcelFile(list);\r\n                    if (firstRow.get(0).size() > 1) {\r\n                        sReturnValue = ObjectType.ECAT_INPUT;\r\n                        break;\r\n                    }\r\n                }\r\n                br = new BufferedReader(new FileReader(list));\r\n                String line = br.readLine();\r\n                br.close();\r\n                if (list.getPath().toLowerCase().endsWith(\".dat\")) {\r\n                    sReturnValue = ObjectType.ECAT_INPUT;\r\n                    break;\r\n                }\r\n\r\n                if (line.contains(\"|\")) {\r\n                    if (line.split(\"|\").length > 1) {\r\n                        sReturnValue = ObjectType.ECAT_INPUT;\r\n                        break;\r\n                    }\r\n                }\r\n                if (line.contains(\";\")) {\r\n                    if (line.split(\";\").length > 1) {\r\n                        sReturnValue = ObjectType.INVALID;\r\n                        break;\r\n                    }\r\n                }\r\n                if (line.contains(\"\\t\")) {\r\n                    if (line.split(\"\\t\").length > 1) {\r\n                        sReturnValue = ObjectType.ECAT_INPUT;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (line.endsWith(\">\")) {\r\n                    sReturnValue = ObjectType.XMLFILE;\r\n                    break;\r\n                }\r\n\r\n                sReturnValue = ObjectType.ECAT_INPUT;\r\n                break;\r\n            }\r\n\r\n        } catch (FileNotFoundException e) {\r\n            log.error(\"File:\" + list.getName() + \" with error: \" + e.getLocalizedMessage());\r\n        } catch (IOException e) {\r\n            log.error(\"File:\" + list.getName() + \" with error: \" + e.getLocalizedMessage());\r\n        } catch (InvalidFormatException e) {\r\n            log.error(e.getLocalizedMessage(), e);\r\n        }\r\n\r\n        return sReturnValue;\r\n    }\r\n\r\n    /**\r\n     * The writeWithFileChannerDMA function writes the contents of an InputStream to a file using FileChannel.transferFrom()\r\n     *\r\n     * @param InputStream inputStream Read the data from\r\n     * @param String      outputFile Specify the file to write to\r\n     * @param long        count Specify the number of bytes to be transferred\r\n     */\r\n    public static void writeWithFileChannerDMA(InputStream inputStream, String outputFile, long count) {\r\n\r\n        try (RandomAccessFile randomAccessFile = new RandomAccessFile(new File(outputFile), \"rw\")) {\r\n            // move the cursor to the end of the file\r\n            randomAccessFile.seek(randomAccessFile.length());\r\n\r\n            // obtain the a file channel from the RandomAccessFile\r\n            try (FileChannel fileChannel = randomAccessFile.getChannel();\r\n                 ReadableByteChannel inputChannel = Channels.newChannel(inputStream)) {\r\n\r\n                fileChannel.transferFrom(inputChannel, 0, count);\r\n\r\n            } catch (IOException e) {\r\n                log.error(\"[writeWithFileChannerDMA.FileChannel]\" + e.getLocalizedMessage());\r\n            }\r\n\r\n        } catch (IOException e) {\r\n            log.error(\"[writeWithFileChannerDMA.RandomAccessFile]\" + e.getLocalizedMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The copyFileTo function copies the contents of a file to another file.\r\n     *\r\n     * @param File src Specify the source file to be copied\r\n     * @param File dst Specify the destination file\r\n     */\r\n    public static void copyFileTo(File src, File dst) {\r\n        copyFileTo(src.toPath(), dst.toPath());\r\n    }\r\n\r\n    /**\r\n     * The copyFileTo function copies a file from one location to another.\r\n     *\r\n     * @param Path src Specify the source file to be copied\r\n     * @param Path dst Specify the destination directory\r\n     */\r\n    public static void copyFileTo(Path src, Path dst) {\r\n        try {\r\n            Files.copy(src, dst, StandardCopyOption.REPLACE_EXISTING);\r\n            log.info(\"Move: \" + src.toFile().getPath());\r\n            log.info(\"  To: \" + dst.toFile().getPath());\r\n        } catch (IOException e) {\r\n            log.error(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            log.debug(\"ErrorMessage: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The deleteOlderThan function deletes all files in a directory that are older than the specified time.\r\n     *\r\n     * @param String directory Specify the directory that we want to delete files from\r\n     * @param long   timeMillisec Determine how old a file has to be in order to be deleted\r\n     */\r\n    public static void deleteOlderThan(String directory, long timeMillisec) {\r\n        File folder = new File(directory);\r\n        Calendar cal = Calendar.getInstance();\r\n        Date time = cal.getTime();\r\n        time.getTime();\r\n\r\n        for (File fi : folder.listFiles()) {\r\n            long fileMillisec = fi.lastModified();\r\n            long timeStampMilliesc = (time.getTime() - timeMillisec);\r\n            if (fileMillisec < timeStampMilliesc) {\r\n                fi.delete();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The mkdir function creates a directory at the specified path.\r\n     *\r\n     * @param String directory Specify the directory to be created\r\n     */\r\n    public static void mkdir(String directory) {\r\n        Path path = Paths.get(directory);\r\n        if (!Files.exists(path)) {\r\n            try {\r\n                Files.createDirectories(path);\r\n            } catch (IOException e) {\r\n                log.error(e.getLocalizedMessage(), e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FileUtils.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-fYrvTmGTBeFXKwJKU3eZFtJlL8GG7ZNy",
    "created" : 1762171111,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\utilities\\\\ExportFileUtils.java\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential NullPointerException in convertCustomerNumber() when customerNumber is null or shorter than 4 characters\",\n      \"justification\": \"String.substring(0,4) assumes input length >=4 and nonnull, leading to NPE or IndexOutOfBounds, which can crash the service when malformed data is processed.\",\n      \"action\": \"Validate customerNumber for null and length >=4 before substring; return original value or throw a controlled IllegalArgumentException; add unit tests for null, short and valid inputs.\",\n      \"source\": \"ExportFileUtils.convertCustomerNumber(String), Zeile 31-38\",\n      \"component\": \"filenaming\",\n      \"impact_scope\": \"prodrelevant, stability\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"FileWriter resources are not closed in finally or trywithresources in many build*File methods\",\n      \"justification\": \"If an exception occurs before explicit close(), the file handle stays open, causing resource leaks and possible filedescriptor exhaustion on the server.\",\n      \"action\": \"Replace all manual FileWriter handling with trywithresources; ensure fw.flush() is implicit; add tests that simulate IOException and verify no open handles remain.\",\n      \"source\": \"ExportFileUtils.buildPriceFile(...), buildPromotionFile(...), buildZinfoFile(...), etc., Zeilen 310330, 620640, 720740\",\n      \"component\": \"IO\",\n      \"impact_scope\": \"performancecritical, stability\",\n      \"relations\": \"Duplicate von Issue 2 (multiple methods)\",\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Using String.split(\\\"|\\\") without escaping the pipe character\",\n      \"justification\": \"In getFileType(), line.split(\\\"|\\\") splits on every character because \\\"|\\\" is a regex alternation operator, causing wrong detection of delimiters and potentially misclassifying files.\",\n      \"action\": \"Escape the pipe: line.split(\\\"\\\\\\\\|\\\"); add unit tests for files with \\\"|\\\" delimiter; refactor delimiter detection into a dedicated utility.\",\n      \"source\": \"ExportFileUtils.getFileType(File), Zeile 124138\",\n      \"component\": \"filetype detection\",\n      \"impact_scope\": \"prodrelevant, functional\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Missing null check for BufferedReader line variable in getFileType()\",\n      \"justification\": \"If the input file is empty, br.readLine() returns null; subsequent calls to line.contains() cause NPE, breaking file processing.\",\n      \"action\": \"Add nullcheck after reading first line; treat empty file as INVALID or throw a controlled exception; add tests for empty files.\",\n      \"source\": \"ExportFileUtils.getFileType(File), Zeile 118124\",\n      \"component\": \"filetype detection\",\n      \"impact_scope\": \"prodrelevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Hardcoded date format strings (e.g., \\\"yyyy-MM-dd_hh-mm-ss\\\") used in several methods\",\n      \"justification\": \"Using nonthreadsafe SimpleDateFormat in static context can cause incorrect timestamps under concurrency and makes localisation difficult.\",\n      \"action\": \"Replace SimpleDateFormat with DateTimeFormatter from java.time; centralise format patterns in a constants class; add tests for formatting correctness.\",\n      \"source\": \"ExportFileUtils.buildPriceFile(...), buildPromotionFile(...), etc., Zeilen 315, 650, 735\",\n      \"component\": \"utilitydate\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Repeated code for creating temporary files (SettingUtils.createTempFile) without handling IOException\",\n      \"justification\": \"If the temporary directory is not writable, the code proceeds with a null file, leading to later NPEs when writing.\",\n      \"action\": \"Wrap createTempFile calls in trycatch, validate the returned path, and fail fast with a meaningful exception; add integration test for unwritable temp directory.\",\n      \"source\": \"Multiple build*File methods, e.g., buildPriceFile, buildZinfoFile, Zeile 300310, 710720\",\n      \"component\": \"fileIO\",\n      \"impact_scope\": \"prodrelevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"String concatenation in loops (e.g., building rowValue in buildCustomFile) leads to O(n) performance\",\n      \"justification\": \"Repeated string concatenation creates many intermediate objects, degrading performance for large tables.\",\n      \"action\": \"Use StringBuilder for row construction; replace \\\"rowValue += (rowValue.isEmpty() ? \\\"\\\" : delimiter) + col\\\" with builder.append(...); add performance test with large datasets.\",\n      \"source\": \"ExportFileUtils.buildCustomFile(...), Zeile 820828\",\n      \"component\": \"performance\",\n      \"impact_scope\": \"performancecritical for large exports\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Method saveContentAsFile catches NullPointerException but continues returning a possibly partially written file\",\n      \"justification\": \"Swallowing NPE hides programming errors and may produce corrupted files without alerting callers.\",\n      \"action\": \"Remove specific NPE catch; let the exception propagate or wrap in a custom IOException; ensure callers handle the error; add unit test for null inputs.\",\n      \"source\": \"ExportFileUtils.saveContentAsFile(...), Zeile 950960\",\n      \"component\": \"utilityfile\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"In getPrefix(Context, LocalCustomer, String) the fallback uses SettingUtils.getSettingByType which may return null, leading to NullPointerException when calling getValue()\",\n      \"justification\": \"If the default setting is missing, sb.append(settingPrefix.getValue()) throws NPE, breaking filename generation.\",\n      \"action\": \"Add null check for settingPrefix; provide default literal or throw a clear exception; add test for missing setting configuration.\",\n      \"source\": \"ExportFileUtils.getPrefix(...), Zeile 10601075\",\n      \"component\": \"configuration\",\n      \"impact_scope\": \"prodrelevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Repeated use of magic strings for prefixes (e.g., \\\"HOH_\\\", \\\"_Positivliste_\\\", \\\"_ZINFO_\\\") scattered across methods\",\n      \"justification\": \"Hardcoded literals make maintenance errorprone and hinder internationalisation.\",\n      \"action\": \"Extract all filename fragments into a constants enum or class; reference constants from all build*File methods; add documentation for each constant.\",\n      \"source\": \"Various build*File methods, e.g., buildPromotionFile Zeile 680, buildZinfoFile Zeile 730\",\n      \"component\": \"namingconvention\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"3\",\n    \"top_todos\": [\n      \"Replace all manual FileWriter handling with trywithresources to prevent resource leaks.\",\n      \"Add proper null and length checks in convertCustomerNumber and getFileType to avoid NPEs.\",\n      \"Fix delimiter detection in getFileType by escaping the pipe character and handling empty files.\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to output JSON with analysis for each file? The schema expects a single object with \"file\": path or chunk ID, and issues list, summary. Probably we need one JSON per file? The instruction: \"Du analysierst jeweils einen Code-Chunk.\" So maybe produce one JSON per chunk. But we have many files. Might need multiple JSON objects? But spec says response must be a single JSON object. Might need to aggregate all issues across all files into one JSON with file field maybe \"multiple\". Could list issues with source referencing file. Let's combine into one output summarizing across all. Provide up to 10 issues per file/chunk, but we have many files; need limit 10 total? It says max 10 issues per file/Chunk. Could include multiple file entries? But schema only allows one file string. So perhaps we need separate output per file. However rule 1: \"Antworte immer als ein einziges JSON-Objekt\". So only one object. Maybe choose the biggest file (ExportFileUtils) for analysis. Provide issues for that file. Let's do that. Provide up to 10 issues. Identify problems: resource leaks (FileWriter not closed in finally), not using try-with-resources, potential NPEs when ctx.getUserSession().get returns null, using StringBuilder without thread safety? Not big. Use of substring without length check in convertCustomerNumber could cause NPE if null or short length. Using magic strings, hardcoded date format, potential security: file paths from user input, no validation leading to path traversal. Use of deprecated Date class, use of SimpleDateFormat not thread-safe. Use of .split(\"|\") which uses regex and splits on every char because \"|\" is regex OR; need escape. Also .split(\"|\") leads to empty strings. Also in getFileType, line.split(\"|\") length >1 always true (splits each char). Also missing null checks for line variable could be null if file empty. Also not closing BufferedReader in finally. Also copyFileTo uses Files.copy with replace but no exception handling for directories. Also deleteOlderThan uses folder.listFiles without null check. Also getFileEnd uses replace \".\" with \",\" could fail for filenames with multiple dots. Also getFileEndAsString duplicate methods. Provide summary rating.\n\nWe'll produce JSON for ExportFileUtils.java with issues list (max 10). Provide summary."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 2270,
      "prompt_tokens" : 27629,
      "total_tokens" : 29899
    },
    "timings" : {
      "cache_n" : 62,
      "prompt_n" : 27567,
      "prompt_ms" : 20727.381,
      "prompt_per_token_ms" : 0.7518910654042877,
      "prompt_per_second" : 1329.9798947102868,
      "predicted_n" : 2270,
      "predicted_ms" : 27671.907,
      "predicted_per_token_ms" : 12.190267400881057,
      "predicted_per_second" : 82.032654995552
    }
  }
}