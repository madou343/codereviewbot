{
  "timestamp" : "2025-11-03T12:59:16.5598233",
  "index" : 10,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FilterRunUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.exceptions.*;\r\nimport com.hom.ebmw.ipim.model.Territory;\r\nimport com.hom.ebmw.jpa.dao.impl.ArticleBaseRepository;\r\nimport com.hom.ebmw.jpa.dao.impl.FilterBaseCustomRepository;\r\nimport com.hom.ebmw.jpa.dao.impl.FilterBaseUpdateRepository;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.KatalogVersion;\r\nimport com.hom.ebmw.utilities.constans.ASTConst;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.hom.ebmw.view.dialogs.CrumbProgressDialog;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.File;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\nimport java.util.concurrent.CompletableFuture;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.stream.Collectors;\r\n\r\n@Slf4j\r\npublic class FilterRunUtils {\r\n\r\n    /**\r\n     * The FilterRunUtils function is a utility function that takes in an array of\r\n     * integers and returns the same array with all negative numbers removed.\r\n     *\r\n     * @return A list of strings\r\n     */\r\n    private FilterRunUtils() {\r\n        log.debug(\"init FilterRunUtils\");\r\n    }\r\n\r\n    /**\r\n     * The checkOfDoubles function checks for duplicate articles in the assortment.\r\n     *\r\n     * @param Context             ctx Get the user session and to access the services\r\n     * @param CrumbProgressDialog dialog Update the progress dialog\r\n     * @return A list of articles\r\n     */\r\n    public static void checkOfDoubles(Context ctx, CrumbProgressDialog dialog) throws DoubleFoundException {\r\n        // Assortment Upload\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        List<AssortmentDatafile> assortmentDataFile = ctx.getServices().getAssortmentDataFileService()\r\n                .findAllByAssortment(assortment);\r\n\r\n        assortmentDataFile.removeIf(item -> Objects.isNull(item.getAstFile().getName()));\r\n\r\n        for (AssortmentDatafile xrossFile : assortmentDataFile) {\r\n            if (Objects.nonNull(dialog))\r\n                dialog.setLabel(TMS.SET_DIALOG_LOAD_FILES_TO_CACHE);\r\n\r\n            final List<ArticleBase> articles;\r\n            articles = readFiles(ctx, xrossFile);\r\n            AstFile dataFile = xrossFile.getAstFile();\r\n            ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, dataFile);\r\n            if (Objects.nonNull(type)) {\r\n                if (type.getName().endsWith(\"INPUT\")) {\r\n                    if (Objects.nonNull(dialog))\r\n                        dialog.setLabel(TMS.SET_DIALOG_CHECK_OF_DOUBLES);\r\n                    FilterUtils.checkIfDouble(ctx, articles, TMS.ERROR_MSG_PRICELIST_CONTAINS_DOUBLES);\r\n                }\r\n\r\n                if (type.getName().endsWith(\"INPUT_POSITIV\")) {\r\n                    if (Objects.nonNull(dialog))\r\n                        dialog.setLabel(TMS.SET_DIALOG_CHECK_OF_DOUBLES);\r\n                    FilterUtils.checkIfDouble(ctx, articles, TMS.ERROR_MSG_POSITIVLIST_CONTAINS_DOUBLES);\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The readFiles function reads the files from the assortment data file.\r\n     *\r\n     * @param Context            ctx Get the user session, which is used to store the assortment\r\n     * @param AssortmentDatafile astDataFile Get the assortment and file from\r\n     * @return A list of articlebase objects\r\n     */\r\n    private static List<ArticleBase> readFiles(Context ctx, AssortmentDatafile astDataFile) {\r\n        Assortment assortment = astDataFile.getAssortment();\r\n        AstFile astFile = astDataFile.getAstFile();\r\n\r\n        List<ArticleBase> articles = new ArrayList<>();\r\n\r\n        File file = new File(SettingUtils.getTempFolder(ctx) + astFile.getName());\r\n        Storage storage = CompUtils.getStorage(ctx, astFile);\r\n\r\n        if (Objects.nonNull(storage.getFileblob())) {\r\n            Blob.loadFromCompressedFile(storage.getFileblob(), file);\r\n            try {\r\n                articles.addAll(ConvertUtils.convertTxt2Prices(file, assortment));\r\n                ctx.getServices().getAssortmentService().save(assortment);\r\n                ctx.getUserSession().put(Params.ACTIVE_ASSORTMENT, assortment);\r\n            } catch (ConvertException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n        return articles;\r\n    }\r\n\r\n    /**\r\n     * The reloadRemoveFilter function is used to remove articles from the database that have been marked as\r\n     * FilterStatus.REMOVEBYFILTER. This function is called when the user clicks on a button in the SettingsActivity\r\n     * class, which then calls this function and passes it a Context object and CrumbProgressDialog object. The for loop\r\n     * iterates through each of the FilterType values (e.g., ALL, FAKE_NEWS, OPINION) and checks if they are valid proofs by calling\r\n     * FilterUtils' isValidProof method with fType as an argument (which returns true or false). If it\r\n     *\r\n     * @param Context             ctx Get the services\r\n     * @param CrumbProgressDialog dialog Update the progress dialog\r\n     */\r\n    public static void reloadRemoveFilter(Context ctx, CrumbProgressDialog dialog) {\r\n        for (FilterType fType : FilterType.values()) {\r\n            if (FilterUtils.isValidProof(fType)) {\r\n                if (Objects.nonNull(dialog))\r\n                    dialog.setLabel(TMS.SET_DIALOG_LOAD_REMOVE, TMS.setProof(fType));\r\n                ctx.getServices().getFilterBaseUpdateService().removeArticleByFilter(ctx, fType, FilterStatus.ALL,\r\n                        FilterStatus.REMOVEBYFILTER);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The reloadAddFilter function is used to reload the filter base with all articles that are not currently in the\r\n     * filter base. This function is called when a user selects &quot;Reload Add Filter&quot; from the menu. The function iterates\r\n     * through each of the FilterTypes and calls addArticleByFilter for each one, passing in ALL as both parameters so that\r\n     * all articles will be added to the filter base. The dialog parameter allows this function to update a progress dialog\r\n     * while it runs, if one was passed into it by its caller (the onOptionsItemSelected method). If no progress dialog was\r\n     * passed into this method\r\n     *\r\n     * @param Context             ctx Get the services\r\n     * @param CrumbProgressDialog dialog Update the progress dialog\r\n     *                            public static void reloadremovefilter(context ctx, crumbprogressdialog dialog) {\r\n     *                            for (filtertype ftype : filtertype\r\n     */\r\n    public static void reloadAddFilter(Context ctx, CrumbProgressDialog dialog) {\r\n        for (FilterType fType : FilterType.values()) {\r\n            if (FilterUtils.isValidProof(fType)) {\r\n                if (Objects.nonNull(dialog))\r\n                    dialog.setLabel(TMS.SET_DIALOG_LOAD_ADD, TMS.setProof(fType));\r\n                ctx.getServices().getFilterBaseUpdateService().addArticleByFilter(ctx, fType, FilterStatus.ALL,\r\n                        FilterStatus.REMOVEBYFILTER);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The reloadIndividualFilter function is used to update the individual filter.\r\n     *\r\n     * @param Context             ctx Access the services\r\n     * @param CrumbProgressDialog dialog Update the progress bar\r\n     */\r\n    public static void reloadIndividualFilter(Context ctx, CrumbProgressDialog dialog) {\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.setProof(FilterType.INDIVIDUAL));\r\n        ctx.getServices().getFilterBaseUpdateService().articleIndividuals(ctx, FilterStatus.ALL,\r\n                FilterStatus.REMOVEBYFILTER, FilterType.INDIVIDUAL, Filterbase.REMOVE_INDIVIDUAL);\r\n        ctx.getServices().getFilterBaseUpdateService().articleIndividuals(ctx, FilterStatus.REMOVEBYFILTER,\r\n                FilterStatus.DEFAULT, FilterType.INDIVIDUAL, Filterbase.ADD_INDIVIDUAL);\r\n    }\r\n\r\n    /**\r\n     * The setLabel function sets the label of the dialog.\r\n     *\r\n     * @param CrumbProgressDialog dialog Set the label of the dialog\r\n     * @param String              label Set the label of the crumbprogressdialog\r\n     */\r\n    private static void setLabel(CrumbProgressDialog dialog, String label) {\r\n\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(label);\r\n    }\r\n\r\n    /**\r\n     * The proofReadingFiles function is used to check the input files for errors.\r\n     * It checks if there are doubles in the pricelist and/or positivlist, and throws an exception if so.\r\n     * If no error occurs, it returns the AstFile of the pricelist.\r\n     *\r\n     * @param CrumbProgressDialog            dialog Set the label of the dialog\r\n     * @param List&lt;AssortmentDatafile&gt; assortmentDataFile Get the astfile from the assortmentdatafile\r\n     * @param List&lt;ArticleBase&gt;        articles Pass the list of articles to the caller\r\n     * @param List&lt;ArticleBase&gt;        positives Store the positive articles\r\n     * @return The input file\r\n     */\r\n    private static AstFile proofReadingFiles(CrumbProgressDialog dialog, List<AssortmentDatafile> assortmentDataFile,\r\n                                             final List<ArticleBase> articles, final List<ArticleBase> positives)\r\n            throws ParameterException, DoubleFoundException, AstFileNotExistsException {\r\n        Context ctx = dialog.getCtx();\r\n        AstFile inputFile = null;\r\n        for (AssortmentDatafile xrossFile : assortmentDataFile) {\r\n            setLabel(dialog, TMS.SET_DIALOG_LOAD_FILES_TO_CACHE);\r\n\r\n            AstFile dataFile = xrossFile.getAstFile();\r\n            ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, dataFile);\r\n            if (Objects.nonNull(type)) {\r\n                if (type.getName().endsWith(\"INPUT\")) {\r\n                    ArticleBaseQueueUtils.createArticleList(ctx, xrossFile, articles);\r\n\r\n                    setLabel(dialog, TMS.SET_DIALOG_CHECK_OF_DOUBLES);\r\n\r\n                    FilterUtils.checkIfDouble(ctx, articles, TMS.ERROR_MSG_PRICELIST_CONTAINS_DOUBLES);\r\n                    inputFile = dataFile;\r\n                }\r\n\r\n                if (type.getName().endsWith(\"INPUT_POSITIV\")) {\r\n                    ArticleBaseQueueUtils.createPositivList(ctx, xrossFile, positives);\r\n                    setLabel(dialog, TMS.SET_DIALOG_CHECK_OF_DOUBLES);\r\n\r\n                    FilterUtils.checkIfDouble(ctx, positives, TMS.ERROR_MSG_POSITIVLIST_CONTAINS_DOUBLES);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Objects.isNull(inputFile))\r\n            throw new AstFileNotExistsException();\r\n\r\n        return inputFile;\r\n    }\r\n\r\n    /**\r\n     * The proofAssortmentValidation function is used to validate the assortment.\r\n     *\r\n     * @param Context ctx Get the user session and the current user\r\n     * @param AstFile inputFile Get the value of a parameter in the input file\r\n     * @param final   List&lt;ArticleBase&gt; articles Determine if the assortment is empty\r\n     */\r\n    private static void proofAssortmentValidation(Context ctx, AstFile inputFile, final List<ArticleBase> articles) throws AstFileNotExistsException {\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n\r\n        Boolean initial = CompUtils.getParameter(ctx, FileParam.INITIAL, inputFile);\r\n\r\n        if (Objects.isNull(initial) && articles.isEmpty() && assortment.getName().isEmpty()) {\r\n            assortment.setDeleteBy(user);\r\n            assortment.setDeleteOn(LocalDateTime.now());\r\n            ctx.getServices().getAssortmentService().save(assortment);\r\n            throw new AstFileNotExistsException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The importImpex function is used to import the data from a file into the database.\r\n     *\r\n     * @param CrumbProgressDialog     dialog Show the progress of the import\r\n     * @param Context                 ctx Get the current user's locale\r\n     * @param AstFile                 inputFile Get the file type\r\n     * @param List&lt;ArticleBase&gt; articles Store the articles that are read from the file\r\n     * @param List&lt;ArticleBase&gt; positives Store the positive articles\r\n     */\r\n    private static void importImpex(CrumbProgressDialog dialog, Context ctx, AstFile inputFile,\r\n                                    final List<ArticleBase> articles, final List<ArticleBase> positives) throws FileEmptyException {\r\n        ObjectType dataFileType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, inputFile);\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n\r\n        if (Objects.nonNull(articles) && !articles.isEmpty()) {\r\n            dialog.importLists(articles, Table.MAIN);\r\n        } else {\r\n            if (!dataFileType.equals(ObjectType.IMPEX_INPUT)) {\r\n                TranslationProvider i18n = ctx.getServices().getTranslationService();\r\n                Locale locale = Locale.forLanguageTag(user.getLocale());\r\n                throw new FileEmptyException(i18n.getTranslation(TMS.ERROR_MSG_PRICELIST_IS_EMPTY, locale, ctx));\r\n            }\r\n        }\r\n\r\n        if (Objects.nonNull(positives) && !positives.isEmpty())\r\n            dialog.importLists(positives, Table.getTemp(1));\r\n\r\n        dialog.waitOfImport();\r\n    }\r\n\r\n    /**\r\n     * The importDefault function is used to import the default articles and positives into the database.\r\n     * It does this by splitting up the list of articles and positives into chunks of 1000, then inserting them\r\n     * in parallel using CompletableFuture.allOf(). This allows for a much faster import than if it were done sequentially.\r\n     *\r\n     * @param Context ctx Get the services and user session\r\n     * @param final   List&lt;ArticleBase&gt; articles Pass the list of articles to be imported\r\n     *                private static list&lt;articlebase&gt; importarticles(context ctx, final string filename) throws ioexception {\r\n     *                file file = new file(filename);\r\n     *                <p>\r\n     *                if (!file\r\n     * @param final   List&lt;ArticleBase&gt; positives Import the positives into a temporary table\r\n     */\r\n    private static void importDefault(Context ctx, final List<ArticleBase> articles,\r\n                                      final List<ArticleBase> positives) throws InterruptedException, ExecutionException {\r\n        final ArticleBaseRepository articleService = ctx.getServices().getArticleBaseService();\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n\r\n        List<CompletableFuture<String>> futureList = new ArrayList<>();\r\n        CompletableFuture<String> futureArticles = CompletableFuture.supplyAsync(() -> {\r\n            int partSize = 1000;\r\n\r\n            List<List<ArticleBase>> splitList = InternalUtils.listSplitter(articles, partSize);\r\n            for (List<ArticleBase> split : splitList) {\r\n                articleService.insertIntoTable(ctx, split, Table.MAIN);\r\n            }\r\n            articleService.updateGlobals(ctx, Table.MAIN);\r\n            return \"finished Articles import\";\r\n        });\r\n        futureList.add(futureArticles);\r\n\r\n        if (Objects.nonNull(tabSession.get(Table.getTemp(1)))) {\r\n            CompletableFuture<String> futurePositives = CompletableFuture.supplyAsync(() -> {\r\n                int partSize = 1000;\r\n                List<List<ArticleBase>> splitList = InternalUtils.listSplitter(positives, partSize);\r\n                for (List<ArticleBase> split : splitList) {\r\n                    articleService.insertIntoTable(ctx, split, Table.getTemp(1));\r\n                }\r\n                articleService.updateGlobals(ctx, Table.getTemp(1));\r\n                return \"finished Positiv import\";\r\n            });\r\n            futureList.add(futurePositives);\r\n        }\r\n\r\n        CompletableFuture<Void> allFutures = CompletableFuture\r\n                .allOf(futureList.toArray(new CompletableFuture[futureList.size()]));\r\n\r\n        CompletableFuture<List<String>> allCompletableFuture = allFutures\r\n                .thenApply(future -> futureList.stream().map(CompletableFuture::join).collect(Collectors.toList()));\r\n        allCompletableFuture.get().forEach(log::debug);\r\n    }\r\n\r\n    /**\r\n     * The importFiles function is used to import the files that are uploaded by the user.\r\n     *\r\n     * @param CrumbProgressDialog     dialog Display the progress of the import\r\n     * @param Context                 ctx Get the current user and to set the active article base table\r\n     *                                private static void importdefault(context ctx, list&lt;articlebase&gt; articles, list&lt;articlebase&gt; positives) throws articlebasequeueexception {\r\n     *                                <p>\r\n     *                                user user = ctx\r\n     * @param AstFile                 inputFile Read the file from the server\r\n     * @param List&lt;ArticleBase&gt; articles Import the articleprice file\r\n     * @param List&lt;ArticleBase&gt; positives Import the positive file\r\n     */\r\n    private static void importFiles(CrumbProgressDialog dialog, Context ctx, AstFile inputFile,\r\n                                    final List<ArticleBase> articles, final List<ArticleBase> positives) throws AstFileNotExistsException,\r\n            ArticleBaseQueueException, FileEmptyException, InterruptedException, ExecutionException {\r\n\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n\r\n        proofAssortmentValidation(ctx, inputFile, articles);\r\n\r\n        ctx.getUserSession().remove(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n\r\n        ArticleBaseQueueUtils.addQueueTable(ctx, user, Table.MAIN); // ArticlePrice File\r\n        if (Objects.nonNull(positives) && !positives.isEmpty()) {\r\n            ArticleBaseQueueUtils.addQueueTable(ctx, user, Table.getTemp(1)); // Positiv Compare File\r\n        }\r\n\r\n        setLabel(dialog, TMS.SET_DIALOG_IMPORT_PRICEFILE);\r\n\r\n        if (Objects.nonNull(dialog)) {\r\n            importImpex(dialog, ctx, inputFile, articles, positives);\r\n        } else {\r\n            importDefault(ctx, articles, positives);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterImpex function is used to filter the impex file.\r\n     *\r\n     * @param Context ctx Get the user session\r\n     * @param AstFile inputFile Get the territory and assortment\r\n     *                private static void filterimpex(context ctx, astfile inputfile) {\r\n     *                assortment assortment = ctx\r\n     */\r\n    private static void filterImpex(Context ctx, AstFile inputFile) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, inputFile);\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n\r\n        updateService.setArticleloadToAssignMaterial(ctx);\r\n\r\n        // LOAD Default ASSORTMENT for IMPEX // Change with PDM-2687\r\n        Object value = CompUtils.getParameter(ctx, FileParam.BASE_ASSORTMENT, assortment);\r\n        if (Objects.nonNull(value) && value instanceof Boolean) {\r\n            if ((Boolean) value) {\r\n                KatalogVersion version = CompUtils.getKatalogVersion(ctx, inputFile);\r\n                String assortmentName = version.getPimAssortmentName();\r\n                updateService.importArticleBasicAssortment(ctx, assortmentName);\r\n                updateService.setArticleloadToAssignMaterial(ctx);\r\n            }\r\n        }\r\n        ctx.getUserSession().remove(Params.ACTIVE_S3_CATALOG);\r\n        Boolean isS3Catalog = CompUtils.getParameter(ctx, FileParam.S3_CATALOG, assortment);\r\n        if (Objects.nonNull(isS3Catalog) && isS3Catalog) {\r\n            ctx.getUserSession().put(Params.ACTIVE_S3_CATALOG, SettingUtils.getS3CatalogSetting(ctx, territory));\r\n            updateService.importArticleS3Catalog(ctx);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterNotInPIM function is used to filter out articles that are not in the PIM.\r\n     * It does this by setting a flag on each article, which can then be used as a filter.\r\n     * The function also sets the assortment of each article, so that it can be filtered later on.\r\n     *\r\n     * @param CrumbProgressDialog dialog Display the progress of the function\r\n     * @param Context             ctx Get the active assortment and to get the filterbaseupdateservice\r\n     * @param AstFile             inputFile Get the assortment name\r\n     */\r\n    private static void filterNotInPIM(CrumbProgressDialog dialog, Context ctx, AstFile inputFile) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n\r\n        ObjectType assortmentType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n\r\n        updateService.setArticleInPIM(ctx, Table.MAIN);\r\n\r\n        if (!assortmentType.equals(ObjectType.PROMOTION)) {\r\n            if (Objects.nonNull(dialog))\r\n                dialog.setLabel(TMS.SET_DIALOG_ARTICLEASSORTMENT);\r\n            KatalogVersion version = CompUtils.getKatalogVersion(ctx, inputFile);\r\n            String assortmentName = version.getPimAssortmentName();\r\n            updateService.setArticleBasicAssortment(ctx, assortmentName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterDelta function is used to filter the articles in the current session\r\n     * based on their comment field. The function will check if there are any articles\r\n     * with a certain comment and then add them to a list that can be accessed by other functions.\r\n     *\r\n     * @param Context ctx Get the user session and the services\r\n     */\r\n    private static void filterDelta(Context ctx) {\r\n\r\n        final ArticleBaseRepository articleService = ctx.getServices().getArticleBaseService();\r\n        List<ArticleBase> articlesInCommet = ctx.getServices().getArticleBaseService().findAll(ctx);\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n\r\n        // HAS_NOTINPIM\r\n        if (articleService.exists(ctx, FilterType.NOTINPIM)) {\r\n            List<ArticleBase> notInPIM = articlesInCommet.stream()\r\n                    .filter(item -> item.getComment().contains(FilterType.NOTINPIM.name()))\r\n                    .collect(Collectors.toList());\r\n            ctx.getUserSession().put(Params.HAS_NOTINPIM, notInPIM);\r\n        }\r\n\r\n        // HAS_NOTAPPROVAL\r\n        if (articleService.exists(ctx, FilterType.NOTAPPROVAL)) {\r\n            List<ArticleBase> notApproval = articlesInCommet.stream()\r\n                    .filter(item -> item.getComment().contains(FilterType.NOTAPPROVAL.name()))\r\n                    .collect(Collectors.toList());\r\n            ctx.getUserSession().put(Params.HAS_NOTAPPROVAL, notApproval);\r\n        }\r\n\r\n        // HAS_INVALID_VTL_STATUS\r\n        if (articleService.exists(ctx, FilterType.VTL_STATUS)) {\r\n            List<ArticleBase> notApproval = articlesInCommet.stream()\r\n                    .filter(item -> item.getComment().contains(FilterType.VTL_STATUS.name()))\r\n                    .collect(Collectors.toList());\r\n            ctx.getUserSession().put(Params.HAS_INVALID_VTL_STATUS, notApproval);\r\n        }\r\n\r\n        // HAS_NOTFOUND\r\n        Object table = tabSession.get(Table.getTemp(1));\r\n        if (Objects.nonNull(table)) {\r\n            List<ArticleBase> notFound = articleService.findAllNotInPositiv(ctx, Table.getTemp(1));\r\n            if (Objects.nonNull(notFound) && !notFound.isEmpty()) {\r\n                ctx.getUserSession().put(Params.HAS_NOTFOUND, notFound);\r\n            }\r\n\r\n            // HAS_NOTPOSITIV\r\n            List<ArticleBase> notPositiv = articlesInCommet.stream()\r\n                    .filter(item -> item.getComment().contains(FilterType.REMOVEBYPOSTIV.name()))\r\n                    .collect(Collectors.toList());\r\n            if (!notPositiv.isEmpty()) {\r\n                ctx.getUserSession().put(Params.HAS_NOTPOSITIV, notPositiv);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterNotPrice function is used to remove articles from the assortment that do not have a price.\r\n     *\r\n     * @param CrumbProgressDialog dialog Update the dialog label\r\n     * @param Context             ctx Get the usersession\r\n     */\r\n    private static void filterNotPrice(CrumbProgressDialog dialog, Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        ObjectType assortmentType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n\r\n        if (assortmentType.equals(ObjectType.ECAT)) {\r\n\r\n            setLabel(dialog, TMS.SET_DIALOG_REMOVE_BY_NO_PRICE);\r\n\r\n            updateService.setArticleNoPrice(ctx);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterPositiv function is used to remove all articles from the main table that are not in the temp table.\r\n     *\r\n     * @param CrumbProgressDialog dialog Update the progress bar\r\n     * @param Context             ctx Get the services\r\n     * @param boolean             isValid Determine if the filter is valid or not\r\n     */\r\n    private static void filterPositiv(CrumbProgressDialog dialog, Context ctx, boolean isValid) {\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n        if (isValid) {\r\n            setLabel(dialog, TMS.SET_DIALOG_REMOVE_BY_POSITIV);\r\n            updateService.setArticleRemoveByPositiv(ctx, Table.getTemp(1), Table.MAIN);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterCountryLock function is used to remove all articles from the database that are not\r\n     * associated with a specific country. This function is called by the filterBaseUpdate function, and\r\n     * it takes in a CrumbProgressDialog dialog, Context ctx, and AstFile inputFile as parameters. The\r\n     * first thing this function does is create an instance of FilterBaseUpdateRepository called updateService.\r\n     * Then it creates an instance of Territory called territory which gets its value from CompUtils' getParameter\r\n     * method using FileParam's TERRITORY enum value and inputFile as parameters. If territory has a non-\r\n     *\r\n     * @param CrumbProgressDialog dialog Update the progress bar\r\n     * @param Context             ctx Get the services and to get parameters from the input file\r\n     * @param AstFile             inputFile Get the territory\r\n     */\r\n    private static void filterCountryLock(CrumbProgressDialog dialog, Context ctx, AstFile inputFile) {\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n        Territory territory = CompUtils.getParameter(ctx, FileParam.TERRITORY, inputFile);\r\n        if (Objects.nonNull(territory)) {\r\n\r\n            setLabel(dialog, TMS.SET_DIALOG_REMOVE_BY_COUNTRY_LOCK);\r\n\r\n            updateService.setArticleCountryLock(ctx, territory.getKey(), Table.MAIN);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterNotApproval function is a static function that takes in two parameters:\r\n     *\r\n     * @param CrumbProgressDialog dialog Update the dialog label\r\n     * @param Context             ctx Get the services\r\n     */\r\n    private static void filterNotApproval(CrumbProgressDialog dialog, Context ctx) {\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n        setLabel(dialog, TMS.SET_DIALOG_REMOVE_BY_NOT_APPROVAL);\r\n\r\n        updateService.setArticleNotApproval(ctx, Table.MAIN);\r\n    }\r\n\r\n    /**\r\n     * The filterPromotion function is used to filter out promotions that are not active.\r\n     *\r\n     * @param CrumbProgressDialog dialog Display a progress bar in the ui\r\n     * @param Context             ctx Get the services and to get the parameters from the inputfile\r\n     * @param AstFile             inputFile Determine the type of file\r\n     */\r\n    private static void filterPromotion(CrumbProgressDialog dialog, Context ctx, AstFile inputFile) {\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n        ObjectType assortmentType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, inputFile);\r\n\r\n        if (assortmentType.equals(ObjectType.PROMOTION)) {\r\n            // VTL DEACTIVE 07.05.2021 TO-DO Muss neu gepr√ºft werden\r\n            if (Objects.nonNull(dialog))\r\n                dialog.setLabel(TMS.SET_DIALOG_REMOVE_BY_NOT_ACTIV_VTL);\r\n            updateService.setArticleNotActivVTL(ctx, Table.MAIN);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterDIS function is used to remove all articles from the main table that have a DIS value of 1.\r\n     * This function is called by the filterBaseUpdateService, which in turn is called by the updateFilterBase function.\r\n     * The filterDIS function first checks if there are any articles with a DIS value of 1 in the main table, and if so it removes them.\r\n     *\r\n     * @param CrumbProgressDialog dialog Update the dialog label\r\n     * @param Context             ctx Get the services and to get the database\r\n     */\r\n    private static void filterDIS(CrumbProgressDialog dialog, Context ctx) {\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n        if (FilterUtils.removeDIS(ctx)) {\r\n\r\n            setLabel(dialog, TMS.SET_DIALOG_REMOVE_BY_DIS);\r\n\r\n            updateService.articleFilterAssignedMaterialDis(ctx, Table.MAIN);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterRestrictions function is used to filter out the restrictions that are set on an assortment.\r\n     *\r\n     * @param CrumbProgressDialog dialog Update the progress bar in the dialog\r\n     * @param Context             ctx Get the services and user session\r\n     */\r\n    private static void filterRestrictions(CrumbProgressDialog dialog, Context ctx) {\r\n        final FilterBaseCustomRepository customService = ctx.getServices().getFilterBaseCustomService();\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n\r\n        ctx.getServices().getFilterBaseCustomService().removeByTypeAndAssortment(FilterType.INDIVIDUAL_ADM, assortment);\r\n        List<Filter> filters = ArticleBaseQueueUtils.getAdmFilter(ctx, assortment);\r\n        if (!filters.isEmpty()) {\r\n\r\n            setLabel(dialog, TMS.SET_DIALOG_ADMIN_RESTRICTION);\r\n\r\n            filters.forEach(item -> customService.cloneFromFilter(item, assortment));\r\n            ctx.getServices().getFilterBaseUpdateService().articleIndividuals(ctx, FilterStatus.ALL,\r\n                    FilterStatus.REMOVEBYFILTER, FilterType.INDIVIDUAL_ADM, Filterbase.REMOVE_INDIVIDUAL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The runWork function is the main function of the AssortmentWorker class.\r\n     * It takes in a Context, an assortment, and a CrumbProgressDialog as parameters.\r\n     * The runWork function then creates an AstNotification object called notify.\r\n     * Then it sets up some variables: error to false, articles to be an empty ArrayList of ArticleBase objects, and positives to be another empty ArrayList of ArticleBase objects.  It also removes any ACTIVE_ARTICLE_BASE_TABLE from the user session (whatever that means).  Then it tries to do all sorts of stuff with those variables and parameters I just\r\n     *\r\n     * @param Context             ctx Get the user session and to access the services\r\n     * @param Assortment          assortment Get the assortment data file\r\n     * @param CrumbProgressDialog dialog Display the progress of the import process\r\n     */\r\n    public static boolean runWork(Context ctx, Assortment assortment, CrumbProgressDialog dialog)\r\n            throws DoubleFoundException, ParameterException, FileEmptyException, ArticleBaseQueueException,\r\n            AstFileNotExistsException, ExecutionException {\r\n        AstNotification notify = new AstNotification(ctx);\r\n\r\n        boolean error = false;\r\n        final List<ArticleBase> articles = new ArrayList<>();\r\n        final List<ArticleBase> positives = new ArrayList<>();\r\n\r\n        ctx.getUserSession().remove(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        try {\r\n            setLabel(dialog, TMS.SET_DIALOG_IMPORT_ARTICLES);\r\n\r\n            // Assortment Upload\r\n            List<AssortmentDatafile> assortmentDataFile = ctx.getServices().getAssortmentDataFileService()\r\n                    .findAllByAssortment(assortment);\r\n\r\n            setLabel(dialog, TMS.SET_DIALOG_CLEAR_CACHE);\r\n\r\n            ArticleBaseQueueUtils.resetUserQueues(ctx);\r\n            // Manachmal ist er zu schnell bevor der Truncate abgeschlossen ist. Daher soll\r\n            // die funktion ca 1 sek ruhen.\r\n            InternalUtils.waitRandonIn(2000);\r\n\r\n            if (Objects.nonNull(assortmentDataFile) && !assortmentDataFile.isEmpty()) {\r\n\r\n                AstFile inputFile = proofReadingFiles(dialog, assortmentDataFile, articles, positives);\r\n\r\n                importFiles(dialog, ctx, inputFile, articles, positives);\r\n\r\n                setLabel(dialog, TMS.SET_DIALOG_REMOVE_NOT_IN_PIM);\r\n\r\n                filterNotInPIM(dialog, ctx, inputFile);\r\n\r\n                filterImpex(ctx, inputFile);\r\n\r\n\r\n                filterNotPrice(dialog, ctx);\r\n                filterPositiv(dialog, ctx, !positives.isEmpty());\r\n\r\n                filterCountryLock(dialog, ctx, inputFile);\r\n\r\n                filterNotApproval(dialog, ctx);\r\n\r\n                filterPromotion(dialog, ctx, inputFile);\r\n\r\n                filterDIS(dialog, ctx);\r\n\r\n                filterRestrictions(dialog, ctx);\r\n\r\n                // Filter Delta If Not in PIM not Approval or Positiv list in use\r\n                filterDelta(ctx);\r\n\r\n                setLabel(dialog, TMS.SET_DIALOG_LOAD_ADD);\r\n\r\n            } else {\r\n                if (Objects.nonNull(dialog))\r\n                    dialog.firstUIBreadCrumb();\r\n                error = true;\r\n            }\r\n        } catch (DoubleFoundException | ParameterException | FileEmptyException | ArticleBaseQueueException\r\n                 | AstFileNotExistsException e) {\r\n\r\n            dialog.setThrower(e);\r\n            error = true;\r\n            dialog.resetCurrentAssortment();\r\n            if (e instanceof ArticleBaseQueueException || e instanceof AstFileNotExistsException) {\r\n                notify.errorMessage(e);\r\n            } else {\r\n                notify.errorPrintMessage(e.getMessage());\r\n            }\r\n\r\n        } catch (InterruptedException e) {\r\n            log.debug(\"CompureFuture Failed\", e);\r\n        }\r\n\r\n        return error;\r\n    }\r\n\r\n\r\n    /**\r\n     * The runReload function is used to reload the assortment.\r\n     *\r\n     * @param Context             ctx Get the services\r\n     * @param Assortment          assortment Determine which assortment to load\r\n     * @param CrumbProgressDialog dialog Display a progress bar in the ui\r\n     * @return A boolean\r\n     */\r\n    public static boolean runReload(Context ctx, Assortment assortment, CrumbProgressDialog dialog) {\r\n        boolean error = false;\r\n        final FilterBaseUpdateRepository updateService = ctx.getServices().getFilterBaseUpdateService();\r\n        final ArticleBaseRepository articleService = ctx.getServices().getArticleBaseService();\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_IMPORT_ARTICLES);\r\n\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_CLEAR_CACHE);\r\n        articleService.resetArticles(ctx);\r\n\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_REMOVE_NOT_IN_PIM);\r\n        updateService.setArticleInPIM(ctx, Table.MAIN);\r\n\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_ARTICLEASSORTMENT);\r\n        KatalogVersion version = CompUtils.getKatalogVersion(ctx, assortment);\r\n        String assortmentName = version.getPimAssortmentName();\r\n        updateService.setArticleBasicAssortment(ctx, assortmentName);\r\n\r\n        filterPositiv(dialog, ctx, true);\r\n\r\n        filterCountryLock(dialog, ctx, assortment);\r\n\r\n        filterNotApproval(dialog, ctx);\r\n\r\n        filterNotPrice(dialog, ctx);\r\n\r\n        filterPositiv(dialog, ctx, true);\r\n        filterDIS(dialog, ctx);\r\n        filterRestrictions(dialog, ctx);\r\n\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * The saveAssortment function saves the current assortment to a file.\r\n     *\r\n     * @param Context             ctx Get the services and session\r\n     * @param CrumbProgressDialog dialog Display the progress of the saveassortment function\r\n     * @return The assortment\r\n     */\r\n    public static Assortment saveAssortment(Context ctx, CrumbProgressDialog dialog) {\r\n        // Save To Archiv\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_ARCHIV_CONTENT);\r\n        ctx.getServices().getArticleBaseService().saveCurrentArticles(ctx);\r\n\r\n        // Save To File\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_SAVE_FILE);\r\n\r\n        List<ArticleBase> articles = new ArrayList<>(ctx.getServices().getArticleBaseService().findAllByFilterStatus(ctx, \"IN\", FilterStatus.DEFAULT));\r\n        File assortmentFile = AssortmentUtil.getFile(ctx, articles, ASTConst.DEFAULT, assortment);\r\n\r\n        CompUtils.saveStorage(ctx, assortment, assortmentFile);\r\n\r\n        // save Article Size PDM-2566\r\n        CompUtils.setParameter(ctx, FileParam.ARTICLE_SIZE, articles.size(), assortment);\r\n\r\n        // free Space\r\n        if (Objects.nonNull(dialog))\r\n            dialog.setLabel(TMS.SET_DIALOG_CLEAR_CACHE);\r\n        ArticleBaseQueueUtils.resetUserQueues(ctx);\r\n\r\n        return ctx.getServices().getAssortmentService().save(assortment);\r\n    }\r\n\r\n    /**\r\n     * The setFilterToAssortment function adds a filter to the assortment.\r\n     *\r\n     * @param Context ctx Access the user session, to get the active assortment and to save a new assortment filter\r\n     * @param Filter  filter Add a filter to the assortment\r\n     */\r\n    public static void setFilterToAssortment(Context ctx, Filter filter) {\r\n        AssortmentFilter assortmentFilter = new AssortmentFilter();\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        List<AssortmentFilter> filters = ctx.getServices().getAssortmentFilterService().findAllByAssortment(assortment);\r\n        Optional<AssortmentFilter> optFilter = filters.stream()\r\n                .filter(item -> item.getFilter().getId() == filter.getId()).findFirst();\r\n        if (!optFilter.isPresent()) {\r\n            assortmentFilter.setCreateBy(user);\r\n            assortmentFilter.setFilter(filter);\r\n            assortmentFilter.setAssortment(assortment);\r\n            ctx.getServices().getAssortmentFilterService().save(assortmentFilter);\r\n            Optional<Assortment> optAssortment = ctx.getServices().getAssortmentService().findById(assortment.getId());\r\n            if (optAssortment.isPresent()) {\r\n                assortment = optAssortment.get();\r\n                ctx.getUserSession().put(Params.ACTIVE_ASSORTMENT, assortment);\r\n            }\r\n            ctx.getServices().getFilterBaseCustomService().cloneFromFilter(filter, assortment);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The isFilterStructureTreeValid function checks if the filter structure of an assortment is valid.\r\n     *\r\n     * @param Context    ctx Access the services and other objects in the system\r\n     * @param Assortment oldAssortment Get the old filter structure\r\n     * @param String     structureType Determine the root filter of the assortment\r\n     * @param Locale     locale Get the translation of the error message\r\n     * @return A message if the filter structure is not valid\r\n     */\r\n    public static String isFilterStructureTreeValid(Context ctx, Assortment oldAssortment, String structureType, Locale locale) {\r\n        TranslationProvider translator = ctx.getServices().getTranslationService();\r\n        String error = \"\";\r\n        // Scan OldFilter\r\n        Optional<Filterbase> optFilterRoot = ctx.getServices().getFilterBaseProofService().getRootFilterStructureByAssortment(oldAssortment);\r\n        Optional<Filterbase> optAssortmentsRoot = ctx.getServices().getFilterBaseProofService().getRootFilterStructureByName(structureType);\r\n\r\n        if (optFilterRoot.isPresent() && optAssortmentsRoot.isPresent() && optFilterRoot.get().getIdentifier().equals(optAssortmentsRoot.get().getIdentifier())) {\r\n            List<Filterbase> diffList = ctx.getServices().getFilterBaseProofService().findAllNotInFilterStructure(oldAssortment);\r\n            if (!diffList.isEmpty()) {\r\n                error = translator.getTranslation(TMS.ERROR_MSG_STRUCTURE_FILTERS_X_NOT_VALID, locale, ctx);\r\n                if (error.contains(\"%s\")) {\r\n                    StringBuilder sb = new StringBuilder();\r\n                    diffList.forEach(item -> sb.append((sb.length() > 0 ? \"\\n\" : \"\") + item.getLabel()));\r\n                    error = String.format(error, sb);\r\n                }\r\n            }\r\n        } else {\r\n            error = translator.getTranslation(TMS.ERROR_MSG_STRUCTURE_FILTER_NOT_VALID, locale, ctx);\r\n        }\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * The setDefaultAutoSorting function sets the default auto sorting profile for an assortment.\r\n     *\r\n     * @param Context    ctx Get the services and to get the setting type\r\n     * @param Assortment assortment Set the filter to the assortment\r\n     */\r\n    public static void setDefaultAutoSorting(Context ctx) {\r\n        Optional<Setting> optSetting = ctx.getServices().getSettingCustomServices().findBySettingType(ctx,\r\n                SettingType.DEFAULT_AUTO_SORT_PROFIL);\r\n        optSetting.ifPresent(setting -> {\r\n            Optional<Filter> optFilter = ctx.getServices().getFilterService().findById(Parse.toInt(setting.getValue()));\r\n            optFilter.ifPresent(filter -> setFilterToAssortment(ctx, filter));\r\n        });\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FilterRunUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FilterUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.exceptions.AstFileNotExistsException;\r\nimport com.hom.ebmw.exceptions.DoubleFoundException;\r\nimport com.hom.ebmw.exceptions.ZinfoToLongException;\r\nimport com.hom.ebmw.ipim.model.AssignedMaterial;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class FilterUtils {\r\n\r\n    private FilterUtils() {\r\n        log.debug(\"noConstructorNeeded\");\r\n    }\r\n\r\n    /**\r\n     * The isValidProof function is used to determine whether or not a given FilterType\r\n     * should be considered valid.  The function returns true if the FilterType is valid,\r\n     * and false otherwise.  A FilterType is considered invalid if it has been set to one of the following values:\r\n     * NOTAPPROVAL, NOTINPIM, NOPRICE, NOTFOUNDINPOSITIV, REMOVEBYPOSTIV, BASIC_ASSORTMENT , COUNTRY_LOCK , INDIVIDUAL , INDIVIDUAL_ADM .\r\n     *\r\n     * @param FilterType type Determine which filter is being used\r\n     * @return A boolean value\r\n     */\r\n    public static boolean isValidProof(FilterType type) {\r\n        boolean result = true;\r\n\r\n        switch (type) {\r\n            case NOTAPPROVAL:\r\n                result = false;\r\n                break;\r\n            case NOTINPIM:\r\n                result = false;\r\n                break;\r\n            case NOPRICE:\r\n                result = false;\r\n                break;\r\n            case NOTFOUNDINPOSITIV:\r\n                result = false;\r\n                break;\r\n            case REMOVEBYPOSTIV:\r\n                result = false;\r\n                break;\r\n            case BASIC_ASSORTMENT:\r\n                result = false;\r\n                break;\r\n            case COUNTRY_LOCK:\r\n                result = false;\r\n                break;\r\n            case INDIVIDUAL:\r\n                result = false;\r\n                break;\r\n            case INDIVIDUAL_ADM:\r\n                result = false;\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The removeDIS function is used to determine whether or not the DIS button should be displayed on the customer's page.\r\n     * The function takes in a Context object as an argument and returns a boolean value.\r\n     * If the user's KAM code is 05 or 07, then it will return false, meaning that they are not allowed to see DIS buttons.\r\n     * Otherwise, it will return true and allow them to see DIS buttons.\r\n     *\r\n     * @param Context ctx Get the active customer from the user session\r\n     * @return True if the active customer's kam is not 05 or 07\r\n     */\r\n    public static boolean removeDIS(Context ctx) {\r\n        boolean result = true;\r\n        LocalCustomer customer = ctx.getUserSession().get(Params.ACTIVE_CUSTOMER);\r\n        String value = \"\";\r\n        if (Objects.nonNull(customer.getKam())) {\r\n            value = customer.getKam().trim();\r\n        }\r\n\r\n        switch (value) {\r\n            case \"05\":\r\n            case \"07\":\r\n                result = false;\r\n                break;\r\n            default:\r\n                result = true;\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getCurrencyCode function takes a currency name and locale as parameters,\r\n     * and returns the corresponding currency code.\r\n     *\r\n     * @param String currencyName Find the currency code\r\n     * @param Locale locale Get the currency code for a given locale\r\n     * @return The currency code for the given currency name\r\n     */\r\n    public static String getCurrencyCode(String currencyName, Locale locale) {\r\n        String code = \"\";\r\n        Optional<Currency> optCurren = Currency.getAvailableCurrencies().parallelStream().filter(currency -> currency.getDisplayName(locale).equals(currencyName)).findFirst();\r\n        if (optCurren.isPresent()) {\r\n            code = optCurren.get().getCurrencyCode();\r\n        }\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * The getCurrencyName function takes a currency code and locale as parameters,\r\n     * and returns the name of the currency in that locale.\r\n     *\r\n     * @param String currencyCode Get the currency code\r\n     * @param Locale locale Determine the language of the currency name\r\n     * @return The currency name for the specified locale\r\n     */\r\n    public static String getCurrencyName(String currencyCode, Locale locale) {\r\n        String code = \"\";\r\n        Optional<Currency> optCurren = Currency.getAvailableCurrencies().parallelStream().filter(currency -> currency.getCurrencyCode().equals(currencyCode)).findFirst();\r\n        if (optCurren.isPresent()) {\r\n            code = optCurren.get().getDisplayName(locale);\r\n        }\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * The checkIfDouble function checks if there are any duplicate ArticleBase objects in the List of articles.\r\n     * If there are, it throws a DoubleFoundException with the list of duplicates and the tmsValue as parameters.\r\n     *\r\n     * @param Context                 ctx Pass the context of the calling class\r\n     * @param List&lt;ArticleBase&gt; articles Pass the list of articles to the function\r\n     * @param String                  tmsValue Display the tms value in the error message\r\n     */\r\n    public static void checkIfDouble(Context ctx, List<ArticleBase> articles, String tmsValue) throws DoubleFoundException {\r\n        Map<String, ArticleBase> doubleCheck = new HashMap<String, ArticleBase>();\r\n        List<ArticleBase> isDouble = new ArrayList<ArticleBase>();\r\n\r\n        articles.forEach(item -> {\r\n            ArticleBase value = doubleCheck.get(item.getArticleNr());\r\n            if (Objects.nonNull(value)) {\r\n                isDouble.add(item);\r\n            } else {\r\n                doubleCheck.put(item.getArticleNr(), item);\r\n            }\r\n        });\r\n\r\n        if (!isDouble.isEmpty())\r\n            throw new DoubleFoundException(ctx, isDouble, tmsValue);\r\n    }\r\n\r\n    /**\r\n     * The checkIfCommentToLong function checks if the comment field of a Zinfo object is longer than the maxLength parameter.\r\n     * If it is, then an exception will be thrown.\r\n     *\r\n     * @param Collection&lt;Zinfo&gt; zinfo Get the list of zinfo objects\r\n     * @param int                     maxLength Determine the maximum length of a comment\r\n     */\r\n    public static void checkIfCommentToLong(Collection<Zinfo> zinfo, int maxLength) throws ZinfoToLongException {\r\n        List<Zinfo> isToLong = new ArrayList<Zinfo>();\r\n\r\n        zinfo.forEach(item -> {\r\n            if (Objects.nonNull(item.getComment()) && item.getComment().length() > maxLength) {\r\n                isToLong.add(item);\r\n            }\r\n        });\r\n\r\n        if (!isToLong.isEmpty())\r\n            throw new ZinfoToLongException(isToLong);\r\n    }\r\n\r\n    /**\r\n     * The isAstFileNull function checks if the AstFile object is null.\r\n     *\r\n     * @param AstFile astFile Check if the file is null\r\n     */\r\n    public static void isAstFileNull(AstFile astFile) throws AstFileNotExistsException {\r\n        if (Objects.isNull(astFile)) {\r\n            throw new AstFileNotExistsException();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The updateAssignedMaterialLabels function takes a context and a list of filters as parameters.\r\n     * It then creates an empty map called mats, which will be used to store the key-value pairs from the materials list.\r\n     * The function then iterates through each item in the materials list, adding its key-value pair to mats.\r\n     * Finally, it iterates through each filter in filters and updates its label if it is equal to 3 characters long (i.e., if it is not already updated).\r\n     *\r\n     * @param Context                ctx Access the services of the application\r\n     * @param List&lt;Filterbase&gt; filters Get the list of filters that will be used to update the assigned material labels\r\n     */\r\n    public static void updateAssignedMaterialLabels(Context ctx, List<Filterbase> filters) {\r\n        List<AssignedMaterial> materials = ctx.getServices().getEnumerationService().getAllAssignedMaterials();\r\n        Map<String, String> mats = new HashMap<String, String>();\r\n        materials.forEach(item -> mats.put(item.getKey(), item.getLabel()));\r\n        filters.forEach(item -> {\r\n            if (item.getLabel().length() == 3) item.setLabel(mats.get(item.getLabel()));\r\n        });\r\n    }\r\n\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\FilterUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\HttpClientHelper.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport org.codehaus.jettison.json.JSONException;\r\nimport org.codehaus.jettison.json.JSONObject;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\n\r\npublic class HttpClientHelper {\r\n\r\n    private HttpClientHelper() {\r\n    }\r\n\r\n    /**\r\n     * The getResponseStringFromConn function takes in an HttpURLConnection and returns a String containing the response from the server.\r\n     *\r\n     * @param HttpURLConnection conn Make a connection to the server\r\n     * @return The response string from the server\r\n     */\r\n    public static String getResponseStringFromConn(HttpURLConnection conn) throws IOException {\r\n\r\n        BufferedReader reader;\r\n        if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\r\n            reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\r\n        } else {\r\n            reader = new BufferedReader(new InputStreamReader(conn.getErrorStream()));\r\n        }\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        String line;\r\n        while ((line = reader.readLine()) != null) {\r\n            stringBuilder.append(line);\r\n        }\r\n\r\n        return stringBuilder.toString();\r\n    }\r\n\r\n    /**\r\n     * The processResponse function takes in a response code and a response string,\r\n     * and returns a JSONObject containing the response code as well as the parsed\r\n     * JSONObject. If there is no valid JSON object to parse, then an empty string\r\n     * is returned instead. This function also handles any errors that may occur when parsing the json object.\r\n     *\r\n     * @param int    responseCode Store the response code from the server\r\n     * @param String response Create a jsonobject\r\n     * @return A jsonobject\r\n     */\r\n    static JSONObject processResponse(int responseCode, String response) throws JSONException {\r\n\r\n        JSONObject responseJson = new JSONObject();\r\n        responseJson.put(\"responseCode\", responseCode);\r\n\r\n        if (response.equalsIgnoreCase(\"\")) {\r\n            responseJson.put(\"responseMsg\", \"\");\r\n        } else {\r\n            responseJson.put(\"responseMsg\", new JSONObject(response));\r\n        }\r\n        return responseJson;\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\HttpClientHelper.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ImportFileUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@Slf4j\r\npublic class ImportFileUtils {\r\n\r\n    private ImportFileUtils() {\r\n        log.debug(\"constructor not in use\");\r\n    }\r\n\r\n    /**\r\n     * The readDelimiterFile function reads a file and returns the contents of that file as a list of maps.\r\n     * Each map represents one line in the input file, with each key being an integer representing the column number\r\n     * and each value being a string representing that column's value. The delimiter parameter is used to determine how\r\n     * columns are separated from one another (e.g., if delimiter = &quot;,&quot; then values are separated by commas).\r\n     *\r\n     * @param File   inputFile Specify the file to be read\r\n     * @param String delimiter Split the line into an array of strings\r\n     * @return A list of maps\r\n     */\r\n    public static List<Map<Integer, String>> readDelimiterFile(File inputFile, String delimiter) {\r\n        List<Map<Integer, String>> fileContent = new ArrayList<>();\r\n\r\n        try (BufferedReader br = new BufferedReader(new FileReader(inputFile))) {\r\n            String line = br.readLine();\r\n            while (line != null) {\r\n                fileContent.add(ConvertUtils.convertLine(line, delimiter));\r\n                line = br.readLine();\r\n            }\r\n        } catch (IOException e) {\r\n            log.error(\"File:\" + inputFile.getName() + \" with error: \" + e.getLocalizedMessage(), e);\r\n        }\r\n\r\n        return fileContent;\r\n    }\r\n\r\n    /**\r\n     * The readDefaultCSVFile function reads a CSV file and returns the data as a list of maps.\r\n     * The first line of the CSV file is assumed to be column headers, which are used as keys in each map.\r\n     * Each subsequent line is read into its own map, with the column header being used as key for each value in that row.\r\n     *\r\n     * @param File inputFile Specify the file to be read\r\n     * @return A list of maps\r\n     */\r\n    public static List<Map<Integer, String>> readDefaultCSVFile(File inputFile) {\r\n        return readDelimiterFile(inputFile, \";\");\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ImportFileUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\InfoReload.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.jpa.dao.impl.ArticleBaseGetRepository;\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.view.sortment.subview.InfoBox;\r\nimport com.vaadin.flow.component.grid.Grid;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Objects;\r\n\r\npublic class InfoReload {\r\n\r\n    /**\r\n     * The reload function is used to update the contents of a grid.\r\n     * It takes in an InfoBox, which contains information about what data should be displayed,\r\n     * and a Grid&lt;Filterbase&gt;, which is the grid that will be updated with new data.\r\n     * The function first gets all of the filters from the InfoBox's filter list and adds them to a FilterList object.\r\n     * Then it creates an RpcProxy object using this FilterList as its parameter.\r\n     * This RpcProxy uses RPC calls to get all of the records that match these filters from our database on our server side code (in Java).\r\n     *\r\n     * @param Context                ctx Get the usersession object\r\n     * @param Grid&lt;Filterbase&gt; source Get the data from the grid\r\n     */\r\n    public static void reload(Context ctx, Grid<Filterbase> source) {\r\n        final InfoBox box = ctx.getUserSession().get(Params.ACTIVE_INFO_BOX);\r\n        reload(box, ctx, source);\r\n    }\r\n\r\n    /**\r\n     * The reload function is used to reload the InfoBox with a new article.\r\n     * The function takes in an InfoBox, Context, and Grid as parameters.\r\n     * It then adds an ItemDoubleClickListener to the grid that will get the item clicked on by the user and store it in a Filterbase variable called filter.\r\n     * If this filter is not null, then we switch on its direction value (which can be 0 or -2).  If it's 0, we call box's reloadByArticle method with two parameters:  A lambda expression that calls our getArticle function using ctx and filter as arguments; and filter itself\r\n     *\r\n     * @param final                  InfoBox box Reload the grid\r\n     * @param Context                ctx Get the current vaadinsession\r\n     * @param Grid&lt;Filterbase&gt; source Add a double click listener to the grid\r\n     */\r\n    public static void reload(final InfoBox box, Context ctx, Grid<Filterbase> source) {\r\n        source.addItemDoubleClickListener(event -> {\r\n            Filterbase filter = event.getItem();\r\n            if (Objects.nonNull(filter)) {\r\n                switch (filter.getDirection()) {\r\n\r\n                    case 0:\r\n                        box.reloadByArticle(() -> getArticle(ctx, filter), filter);\r\n                        break;\r\n                    case -1:\r\n                    case -2:\r\n                    case 1:\r\n                    case 2:\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The getArticle function is a helper function that returns a list of ArticleBase objects.\r\n     * The getArticle function takes in two parameters: the context and the filter.\r\n     * The context parameter is used to access services, such as the article base get service, which are needed to retrieve articles from SAP Commerce Cloud.\r\n     * The filter parameter contains information about what type of articles should be retrieved (e.g., all articles with an assigned material) and how they should be filtered (e.g., only those with an assigned material not in basic assortment).\r\n     *\r\n     * @param Context    ctx Get the services and session\r\n     * @param Filterbase filter Get the filter type and label\r\n     */\r\n    private static List<ArticleBase> getArticle(Context ctx, Filterbase filter) {\r\n        List<ArticleBase> result = new ArrayList<ArticleBase>();\r\n        final ArticleBaseGetRepository repo = ctx.getServices().getArticleBaseGetService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n\r\n        switch (filter.getType()) {\r\n\r\n            case \"ARTIKELKLASSE\":\r\n                result.addAll(repo.getArticleClass(ctx, filter.getLabel(), locale));\r\n                break;\r\n\r\n            case \"ZUORDNUNG_MATERIAL\":\r\n                if (filter.getLabel().contains(\"BASIC\")) {\r\n                    result.addAll(repo.getArticleAssignedMaterialInBasicAssortment(ctx, locale));\r\n                } else {\r\n                    result.addAll(repo.getArticleAssignedMaterialNotInBasicAssortment(ctx, filter.getIdentifier(), locale));\r\n                }\r\n                break;\r\n            case \"BRANDS\":\r\n                result.addAll(repo.getArticleBrands(ctx, filter.getLabel(), locale));\r\n                break;\r\n            case \"GHS_CODES\":\r\n                result.addAll(repo.getArticleGHSCode(ctx, filter.getLabel(), locale));\r\n                break;\r\n            case \"INFOTYPE\":\r\n                result.addAll(repo.getArticleInfoType(ctx, filter.getLabel(), locale));\r\n                break;\r\n            case \"STRUCTURE\":\r\n                if (filter.getIdentifier().contains(String.valueOf(filter.getStructureGroupId()))) {\r\n                    result.addAll(repo.getArticleStructure(ctx, filter.getIdentifier(), locale));\r\n                } else {\r\n                    result.addAll(repo.getArticleStructureClassification(ctx, String.valueOf(filter.getStructureGroupId()), filter.getStructureType(), locale));\r\n                }\r\n                break;\r\n            case \"CONFIG\":\r\n                result.addAll(repo.getArticleConfig(ctx, filter.getLabel(), locale));\r\n                break;\r\n            case \"NOTFREE\":\r\n                result.addAll(repo.getArticleNotFree(ctx, filter.getLabel(), locale));\r\n                break;\r\n            case \"INTRASTAT\":\r\n                result.addAll(repo.getArticleIntraStat(ctx, filter.getLabel(), locale));\r\n                break;\r\n            case \"INDIVIDUAL\":\r\n                result.addAll(repo.getArticleIndividual(ctx, filter));\r\n                break;\r\n            case \"S3_CATALOGS\":\r\n                result.addAll(repo.getArticleS3CatalogFilter(ctx, filter.getLabel(), locale));\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\InfoReload.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\InitialUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.service.IPIMService;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\n\r\nimport static com.hom.ebmw.utilities.enums.SettingType.DEFAULT_ECAT_STRUCUTURE_NAME;\r\nimport static com.hom.ebmw.utilities.enums.SettingType.DEFAULT_IMPEX_STRUCUTURE_NAME;\r\n\r\npublic class InitialUtils {\r\n\r\n    /**\r\n     * The initialFilterBase function is used to set the default structure names for the eCat and Impex structures.\r\n     *\r\n     * @param Context ctx Get the services object\r\n     */\r\n    public static void initialFilterBase(Context ctx) {\r\n        setStructureName(ctx.getServices(), SettingUtils.getSettingByType(ctx, DEFAULT_ECAT_STRUCUTURE_NAME));\r\n        setStructureName(ctx.getServices(), SettingUtils.getSettingByType(ctx, DEFAULT_IMPEX_STRUCUTURE_NAME));\r\n    }\r\n\r\n    /**\r\n     * The setStructureName function is used to set the name of a structure.\r\n     *\r\n     * @param Services services Access the database\r\n     * @param Setting  setting Get the value of the setting\r\n     */\r\n    public static void setStructureName(Services services, Setting setting) {\r\n        SettingType type = SettingType.valueOf(setting.getIdentifier());\r\n        services.getFilterBaseCustomService().removeWhereStructureTypeLike(type.getOptional());\r\n        services.getFilterBaseCustomService().removeWhereStructureTypeLike(setting.getValue());\r\n        writeStructureByName(services, setting);\r\n    }\r\n\r\n    /**\r\n     * The writeStructureByName function is used to write the structure of a category by name.\r\n     *\r\n     * @param Services services Get the ipimservice\r\n     * @param Setting  setting Specify the location of the output file\r\n     */\r\n    private static void writeStructureByName(Services services, Setting setting) {\r\n        IPIMService iPIMService = services.getIPIMService();\r\n        Language lang = new Language();\r\n        lang.setKey(\"7\"); // Cached German Only\r\n        iPIMService.getAllStructureOfCategoryToFileBase(setting, lang);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\InitialUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\Command.java =====\n```\npackage com.hom.ebmw.utilities.interfaces;\r\n\r\npublic interface Command {\r\n    void execute();\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\Command.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\HasPermission.java =====\n```\npackage com.hom.ebmw.utilities.interfaces;\r\n\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.jpa.model.RolePermission;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.utilities.PermissionFactory;\r\n\r\npublic interface HasPermission {\r\n    /**\r\n     * The getPermission function is a factory method that returns the appropriate RolePermission object for the given user.\r\n     *\r\n     * @param User     user Get the user's role\r\n     * @param Services services Access the database to get the permissions for a user\r\n     * @return A rolepermission object\r\n     */\r\n    default RolePermission getPermission(User user, Services services) throws NullPointerException {\r\n        return new PermissionFactory().getFactory(user, services, getClass().getCanonicalName());\r\n    }\r\n\r\n    /**\r\n     * The getPermission function is a static function that returns an instance of the RolePermission class.\r\n     * The getPermission function takes in three parameters: user, services, and clazz.\r\n     * The user parameter is an object of type User which represents the current logged-in user.\r\n     * The services parameter is an object of type Services which represents all available services to be used by the application.\r\n     * Finally, clazz is a Class&lt;?&gt; object representing any class within our application that we want to check for permissions on behalf of this particular user (user).\r\n     *\r\n     * @param User           user Get the role of the user\r\n     * @param Services       services Access the database\r\n     * @param Class&lt;?&gt; clazz Get the canonical name of the class\r\n     * @return A rolepermission object\r\n     */\r\n    default RolePermission getPermission(User user, Services services, Class<?> clazz) throws NullPointerException {\r\n        return new PermissionFactory().getFactory(user, services, clazz.getCanonicalName());\r\n    }\r\n\r\n    /**\r\n     * The getPermission function is a factory method that returns an instance of the RolePermission class.\r\n     * The getPermission function takes in three parameters: user, services, and clazzName.\r\n     * The user parameter is used to determine which role the current user has been assigned to.\r\n     * The services parameter is used to access the database and retrieve information about users from it.\r\n     * Finally, clazzName represents a string containing the name of a class that implements RolePermission (e.g., &quot;Admin&quot;).\r\n     *\r\n     * @param User     user Get the user's role the services services parameter is used to access the database\r\n     * @param Services services Get the user's role\r\n     * @param String   clazzName Get the class name of the object\r\n     * @return A rolepermission object\r\n     */\r\n    default RolePermission getPermission(User user, Services services, String clazzName) throws NullPointerException {\r\n        return new PermissionFactory().getFactory(user, services, clazzName);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\HasPermission.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\ObjectType.java =====\n```\npackage com.hom.ebmw.utilities.interfaces;\r\n\r\npublic interface ObjectType {\r\n\r\n    String POSITIVASSORTMENT = \"POSITIVASSORTMENT\";\r\n    String OLD_POSITIV_LIST = \"OLD_POSITIV_LIST\";\r\n    String ARTICLEASSORTMENT = \"ARTICLEASSORTMENT\";\r\n    String ARTICLEBASE = \"ARTICLEBASE\";\r\n    String ARTICLEASSORTMENT_CONVERTED = \"ARTICLEASSORTMENT_CONVERTED\";\r\n    String BATCHFILES = \"BATCHFILES\";\r\n    String PRICEFILE = \"PRICEFILE\";\r\n    String PRICEFILE_CONVERTED = \"PRICEFILE_CONVERTED\";\r\n    String CUSTOMASSORTMENT = \"CUSTOMASSORTMENT\";\r\n    String INVALID = \"INVALID\";\r\n    String XMLFILE = \"XMLFILE\";\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\ObjectType.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\PageConst.java =====\n```\npackage com.hom.ebmw.utilities.interfaces;\r\n\r\nimport java.util.Locale;\r\n\r\npublic interface PageConst {\r\n    Locale APP_LOCALE = Locale.US;\r\n\r\n    String PAGE_ROOT = \"\";\r\n    String PAGE_ROOT_ALIAS = \"main\";\r\n    String PAGE_DEMO = \"demo\";\r\n    String PAGE_CONFIG = \"config\";\r\n    String PAGE_SETTING = \"setting\";\r\n    String PAGE_STATISTIC = \"statistic\";\r\n    String PAGE_ADMIN = \"admin\";\r\n    String PAGE_USER = \"user\";\r\n    String PAGE_ERROR = \"error\";\r\n    String PAGE_EXPORT = \"export\";\r\n    String PAGE_GENERIC = \"generic\";\r\n    String PAGE_TEST = \"test-demo\";\r\n    String PAGE_ECAT = \"ecat\";\r\n    String PAGE_AUTOSORT = \"autosort\";\r\n    String PAGE_PROFIL = \"profil\";\r\n    String PAGE_GLB_EXCLUDE = \"global_exclude\";\r\n    String PAGE_CELUM_EXPORT = \"celum_export\";\r\n    String PAGE_ESHOP = \"impex\";\r\n    String PAGE_LA = \"layout-automation\";\r\n    String PAGE_PROMOTION = \"promotion\";\r\n    String PAGE_LOGOUT = \"logoutx\";\r\n    String PAGE_LOGOUT2 = \"loggedOut\";\r\n    String PAGE_SWAGGER = \"swagger\";\r\n\r\n    String TITLE_DEMO = \"Demo\";\r\n    String TITLE_LOGOUT = \"Logout\";\r\n    String TITLE_LOGOUT2 = \"LoggedOut\";\r\n    String TITLE_CONFIG = \"Configuration\";\r\n    String TITLE_SETTING = \"Setting\";\r\n    String TITLE_STATISTIC = \"Statistic\";\r\n    String TITLE_ADMIN = \"Admin\";\r\n    String TITLE_USER = \"User\";\r\n    String TITLE_ERROR = \"ERROR - ACCESS DENIED\";\r\n    String TITLE_EXPORT = \"Export\";\r\n    String TITLE_GENERIC = \"Generic\";\r\n    String TITLE_TEST = \"TEST-DEMO\";\r\n    String TITLE_ECAT = \"eCat\";\r\n    String TITLE_AUTOSORT = \"Auto-Sort\";\r\n    String TITLE_PROFIL = \"Profil\";\r\n    String TITLE_GLB_EXCLUDE = \"Global Exclude\";\r\n    String TITLE_CELUM_EXPORT = \"Celum Exclude\";\r\n    String TITLE_ESHOP = \"impex\";\r\n    String TITLE_LA = \"Layout Automation\";\r\n    String TITLE_PROMOTION = \"promotion\";\r\n    String TITLE_NOT_FOUND = \"Page was not found\";\r\n    String TITLE_ACCESS_DENIED = \"Access denied\";\r\n    String TITLE_SWAGGER = \"API-DOC\";\r\n\r\n    String VIEWPORT = \"width=1400px, minimum-scale=0.7, initial-scale=0.7, user-scalable=no\";\r\n\r\n    // Mutable for testing.\r\n    int NOTIFICATION_DURATION = 4000;\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\interfaces\\PageConst.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\InternalUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\nimport java.util.function.Function;\r\nimport java.util.stream.Collectors;\r\n\r\n@Slf4j\r\npublic class InternalUtils {\r\n\r\n    /**\r\n     * The isNull function takes a String value and returns an empty string if the\r\n     * value is null. Otherwise, it returns the original string.\r\n     *\r\n     * @param String value Check if the value is null\r\n     * @return A string\r\n     */\r\n    public static String isNull(String value) {\r\n        String retValue = \"\";\r\n        if (value != null) {\r\n            retValue = value;\r\n        }\r\n        return retValue;\r\n    }\r\n\r\n    /**\r\n     * The placeIfNull function takes a String value and returns it if it is not null.\r\n     * If the value is null, then an empty string (&quot;&quot;) will be returned instead.\r\n     *\r\n     * @param String value Check if the value is null or not\r\n     * @return An empty string if the value is null\r\n     */\r\n    public static String placeIfNull(String value) {\r\n        return Objects.isNull(value) ? \"\" : value;\r\n    }\r\n\r\n    /**\r\n     * The replaceSpecials function takes a string and replaces all special characters with an underscore.\r\n     * It also replaces double underscores with single underscores, and it replaces umlauts (√∂√§√º√ñ√Ñ√ú)\r\n     * with their non-umlau\r\n     *\r\n     * @param String value Replace all special characters with underscores\r\n     * @return A string without any special characters\r\n     */\r\n    public static String replaceSpecials(String value) {\r\n        return value.replaceAll(\"[.,;:!?&%$¬ß\\\"'=\\\\\\\\ \\\\/\\\\]\\\\[\\\\|\\\\{\\\\}]\", \"_\")\r\n                .replace(\"__\", \"_\")\r\n                // replace Umlautet\r\n                .replace(\"√∂\", \"oe\")\r\n                .replace(\"√ñ\", \"Oe\")\r\n                .replace(\"√§\", \"ae\")\r\n                .replace(\"√Ñ\", \"Ae\")\r\n                .replace(\"√º\", \"ue\")\r\n                .replace(\"√ú\", \"Ue\");\r\n    }\r\n\r\n    /**\r\n     * The waitRandonIn function is used to wait for a random amount of time.\r\n     *\r\n     * @param int maxMilliSec Set the maximum amount of time in milliseconds that the thread will sleep\r\n     * @return A random number between 10 and maxmillisec\r\n     */\r\n    public static void waitRandonIn(int maxMilliSec) {\r\n        try {\r\n            int milliSec = ThreadLocalRandom.current().nextInt(10, maxMilliSec + 1);\r\n            Thread.sleep(milliSec);\r\n        } catch (InterruptedException e) {\r\n            log.error(e.getLocalizedMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The wait function is used to pause the execution of a program for a specified amount of time.\r\n     *\r\n     * @param int milliSec Set the amount of time that the program will wait before continuing\r\n     * @return Nothing\r\n     */\r\n    public static void wait(int milliSec) {\r\n        try {\r\n            Thread.sleep(milliSec);\r\n        } catch (InterruptedException e) {\r\n            log.error(e.getLocalizedMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The listSplitter function takes a list and splits it into smaller lists of the same size.\r\n     *\r\n     * @param List&lt;E&gt; toSplit Specify the list that will be split\r\n     * @param long          split Determine the size of each sublist\r\n     * @return A list&lt;list&lt;t&gt;&gt;\r\n     */\r\n    public static <E> List<List<E>> listSplitter(List<E> toSplit, long split) {\r\n        List<List<E>> result = new ArrayList<List<E>>();\r\n        long skip = 0;\r\n        long limit = split;\r\n        while (skip <= toSplit.size()) {\r\n            List<E> skiped = toSplit.stream().skip(skip).collect(Collectors.toList());\r\n            List<E> toAdd = skiped.stream().limit(limit).collect(Collectors.toList());\r\n            result.add(toAdd);\r\n            skip = skip + limit;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The listToString function takes a list of objects and converts them to a string.\r\n     *\r\n     * @param List&lt;E&gt; listObj Pass the list object to be converted\r\n     * @param Function&lt;? super E Pass in a lambda expression that will be used to map the elements of the list to strings\r\n     * @param String&gt;    mapper Convert the elements of the list to a string\r\n     * @param String        pattern Join the elements of the list\r\n     * @return A string representation of a list\r\n     * @docauthor Trelent\r\n     */\r\n    public static <E> String listToString(List<E> listObj, Function<? super E, String> mapper, String pattern) {\r\n        return listObj.stream().map(mapper).collect(Collectors.joining(pattern));\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\InternalUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\JsonMapper.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\n\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClient;\r\n\r\n@Slf4j\r\npublic class JsonMapper {\r\n    private static final ObjectMapper MAPPER = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\r\n\r\n    static {\r\n        MAPPER.registerModule(new JavaTimeModule());\r\n    }\r\n\r\n    /**\r\n     * The toJsonString function takes an OAuth2AuthorizedClient object and converts it to a JSON string.\r\n     *\r\n     * @param OAuth2AuthorizedClient authorizedClient Store the client information\r\n     * @return A json string of the oauth2authorizedclient object\r\n     */\r\n    public static String toJsonString(OAuth2AuthorizedClient authorizedClient) {\r\n        String clientJsonString;\r\n        try {\r\n            clientJsonString = MAPPER.writeValueAsString(authorizedClient);\r\n        } catch (JsonProcessingException e) {\r\n            log.warn(\"Error when transfer OAuth2AuthorizedClient to Json\", e);\r\n            clientJsonString = \"Fail to generate Json Stringo of current OAuth2AuthorizedClient\";\r\n        }\r\n        return clientJsonString;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\JsonMapper.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\Parse.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.utilities.enums.AstDateFormat;\r\nimport com.hom.ebmw.utilities.enums.AstDateTimeFormat;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.text.*;\r\nimport java.time.LocalDate;\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.Objects;\r\n\r\n@Slf4j\r\npublic class Parse {\r\n\r\n    /**\r\n     * The toLong function converts a String to a Long.\r\n     *\r\n     * @param Object value Determine the type of value that is being passed in\r\n     * @return The value of the long passed in\r\n     */\r\n    public static long toLong(Object value) {\r\n        long result = 0;\r\n        if (value instanceof String) {\r\n            try {\r\n                result = Long.parseLong((String) value);\r\n            } catch (NumberFormatException e) {\r\n                log.debug(\"Value[\" + value + \"] is not a Long\");\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The toBoolean function converts a String to a boolean.\r\n     *\r\n     * @param Object value Pass in the value of the object that is being converted\r\n     * @return A boolean value\r\n     */\r\n    public static boolean toBoolean(Object value) {\r\n        boolean result = false;\r\n        if (value instanceof String) {\r\n            try {\r\n                result = Boolean.parseBoolean((String) value);\r\n            } catch (NumberFormatException e) {\r\n                log.debug(\"Value[\" + value + \"] is not a Boolean\");\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The toInt function converts a String to an int.\r\n     *\r\n     * @param Object value Convert the value to an integer\r\n     * @return 0 if the value is not a string\r\n     */\r\n    public static int toInt(Object value) {\r\n        int result = 0;\r\n        if (value instanceof String) {\r\n            try {\r\n                result = Integer.parseInt((String) value);\r\n            } catch (NumberFormatException e) {\r\n                log.debug(\"Value[\" + value + \"] is not a Integer\");\r\n            }\r\n        }\r\n        if (value instanceof Integer) {\r\n            result = (Integer) value;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The toDouble function converts a String to a Double.\r\n     *\r\n     * @param Object value Convert the value to a double\r\n     * @return A double value\r\n     */\r\n    public static double toDouble(Object value) {\r\n        double result = 0;\r\n        if (value instanceof String) {\r\n            String sValue = (String) value;\r\n            if (!sValue.isEmpty()) {\r\n                try {\r\n                    result = Double.parseDouble(sValue);\r\n                } catch (NumberFormatException e1) {\r\n                    try {\r\n                        if (sValue.length() > 2) {\r\n                            String decimal = sValue.substring(sValue.length() - 3, sValue.length() - 2);\r\n\r\n                            if (decimal.equals(\",\")) {\r\n                                sValue = sValue.replace(\".\", \"\");\r\n                                sValue = sValue.replace(\",\", \".\");\r\n                            } else if (decimal.equals(\".\")) {\r\n                                sValue = sValue.replace(\",\", \"\");\r\n                            }\r\n                        }\r\n\r\n                        sValue = sValue.replace(\",\", \".\");\r\n                        result = Double.parseDouble(sValue);\r\n                    } catch (NumberFormatException e2) {\r\n                        log.debug(\"ErrorMessage: Value[\" + value + \"] is not a Double\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The toFloat function converts a String to a float.\r\n     *\r\n     * @param Object value Pass in the value that is to be converted\r\n     * @return A float value\r\n     */\r\n    public static float toFloat(Object value) {\r\n        float result = 0;\r\n        if (value instanceof String) {\r\n            String sValue = (String) value;\r\n            if (!sValue.isEmpty()) {\r\n                try {\r\n                    result = Float.parseFloat(sValue);\r\n                } catch (NumberFormatException e1) {\r\n                    try {\r\n                        if (sValue.length() > 2) {\r\n                            String decimal = sValue.substring(sValue.length() - 3, sValue.length() - 2);\r\n\r\n                            if (decimal.equals(\",\")) {\r\n                                sValue = sValue.replace(\".\", \"\");\r\n                                sValue = sValue.replace(\",\", \".\");\r\n                            } else if (decimal.equals(\".\")) {\r\n                                sValue = sValue.replace(\",\", \"\");\r\n                            }\r\n                        }\r\n\r\n                        sValue = sValue.replace(\",\", \".\");\r\n                        result = Float.parseFloat(sValue);\r\n                    } catch (NumberFormatException e2) {\r\n                        log.debug(\"ErrorMessage: Value[\" + value + \"] is not a Double\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The toString function converts the value of an object to a string.\r\n     *\r\n     * @param Object value Determine what type of object is being passed in\r\n     * @return The value of the object as a string\r\n     */\r\n    public static String toString(Object value) {\r\n        String result = \"\";\r\n        if (value instanceof String) {\r\n            result = (String) value;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The convertDateTime function takes a string representing a date and time in the format &quot;yyyyMMddhhmmss&quot;\r\n     * and converts it to the format &quot;yyyy-MM-dd_hh:mm:ss&quot;.  It returns this new string.\r\n     *\r\n     * @param String toConvert Pass the date and time to be converted\r\n     * @return A string in the format of yyyy-mm-dd_hh:mm:ss\r\n     */\r\n    public static String convertDateTime(String toConvert) {\r\n        return convertDateTime(toConvert, \"yyyyMMddhhmmss\", \"yyyy-MM-dd_hh:mm:ss\");\r\n    }\r\n\r\n    /**\r\n     * The convertDate function takes a string in the format of ddMMyyyy and converts it to yyyy-MM-dd.\r\n     *\r\n     * @param String toConvert Pass in the date to be converted\r\n     * @return The date in the format yyyy-mm-dd\r\n     */\r\n    public static String convertDate(String toConvert) {\r\n        return convertDateTime(toConvert, \"ddMMyyyy\", \"yyyy-MM-dd\");\r\n    }\r\n\r\n    /**\r\n     * The getTimeStamp function returns a string containing the current date and time.\r\n     *\r\n     * @param String format Specify the format of the timestamp\r\n     * @return The current date and time in a specific format\r\n     */\r\n    public static String getTimeStamp(String format) {\r\n        Calendar cal = Calendar.getInstance();\r\n        Date time = cal.getTime();\r\n        DateFormat formatter = new SimpleDateFormat(format, Locale.GERMAN);\r\n        return formatter.format(time);\r\n    }\r\n\r\n    /**\r\n     * The convertDate function takes a date string in one format and converts it to another format.\r\n     *\r\n     * @param String value Convert the date\r\n     * @param String fromFormat Specify the format of the date in string value\r\n     * @param String toFormat Format the date\r\n     * @return A string in the format &quot;yyyy-mm-dd hh:mm:ss&quot;\r\n     */\r\n    public static String convertDate(String value, String fromFormat, String toFormat) {\r\n        String result = \"\";\r\n        if (value.isEmpty()) {\r\n            result = getTimeStamp(toFormat);\r\n        } else {\r\n            try {\r\n                DateFormat formatter = new SimpleDateFormat(fromFormat, Locale.GERMAN);\r\n                Date date = formatter.parse(value);\r\n                formatter = new SimpleDateFormat(toFormat, Locale.GERMAN);\r\n                result = formatter.format(date);\r\n            } catch (ParseException e) {\r\n                log.debug(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The convertDateTime function converts a date string from one format to another.\r\n     *\r\n     * @param String value Pass the date and time that needs to be converted\r\n     * @param String fromFormat Specify the format of the date that is passed in as a string value\r\n     * @param String toFormat Set the format of the time stamp\r\n     * @return The current date and time in the format &quot;yyyy-mm-dd hh:mm:ss&quot;\r\n     */\r\n    public static String convertDateTime(String value, String fromFormat, String toFormat) {\r\n        String result = \"\";\r\n        if (value.isEmpty()) {\r\n            result = getTimeStamp(toFormat);\r\n        } else {\r\n            try {\r\n                DateFormat formatter = new SimpleDateFormat(fromFormat, Locale.GERMAN);\r\n                Date date = formatter.parse(value);\r\n                formatter = new SimpleDateFormat(toFormat, Locale.GERMAN);\r\n                result = formatter.format(date);\r\n            } catch (ParseException e) {\r\n                log.debug(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * The getTimeStamp function returns a string containing the current date and time in the format yyyyMMddHHmmss.\r\n     *\r\n     * @return The current time in the format yyyymmddhhmmss\r\n     */\r\n    public static String getTimeStamp() {\r\n        Calendar cal = Calendar.getInstance();\r\n        Date time = cal.getTime();\r\n        DateFormat formatter = new SimpleDateFormat(\"yyyyMMddHHmmss\", Locale.GERMAN);\r\n        return formatter.format(time);\r\n    }\r\n\r\n    /**\r\n     * The getDate function returns a string containing the current date and time in the format:\r\n     * yyyy-MM-dd_HH-mm-ss. This is used to name files so that they can be sorted by creation date.\r\n     *\r\n     * @return The current date and time\r\n     */\r\n    public static String getDate() {\r\n        Calendar cal = Calendar.getInstance();\r\n        Date time = cal.getTime();\r\n        DateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\", Locale.GERMAN);\r\n        return formatter.format(time);\r\n    }\r\n\r\n    /**\r\n     * The getCurrentDate function returns the current date and time.\r\n     *\r\n     * @return The current date and time\r\n     */\r\n    public static Date getCurrentDate() {\r\n        Calendar cal = Calendar.getInstance();\r\n        Date time = cal.getTime();\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * The getDate function takes a String value and a String format as parameters.\r\n     * It then uses the SimpleDateFormat class to parse the date from the string,\r\n     * using the given format. If an error occurs during parsing, it is caught and logged.\r\n     *\r\n     * @param String value Get the date from a string\r\n     * @param String format Define the format of the date\r\n     * @return A date object\r\n     */\r\n    public static Date getDate(String value, String format) {\r\n        Date date = null;\r\n        try {\r\n            DateFormat formatter = new SimpleDateFormat(format, Locale.GERMAN);\r\n            date = formatter.parse(value);\r\n        } catch (ParseException e) {\r\n            log.debug(\"ErrorMessage: \" + e.getLocalizedMessage());\r\n        }\r\n        return date;\r\n    }\r\n\r\n    /**\r\n     * The getLocalDate function takes a String value and an AstDateFormat format,\r\n     * and returns a LocalDate object. The function uses the parse method of the\r\n     * DateTimeFormatter class to convert the String value into a LocalDate object.\r\n     *\r\n     * @param String        value Pass the date value to be converted\r\n     * @param AstDateFormat format Specify the format of the date\r\n     * @return A localdate object\r\n     */\r\n    public static LocalDate getLocalDate(String value, AstDateFormat format) {\r\n        return getLocalDate(value, format.getFormat());\r\n    }\r\n\r\n    /**\r\n     * The getLocalDate function takes a String value and a String format as parameters.\r\n     * It returns the LocalDate object that corresponds to the given date string in the given format.\r\n     * If no date is provided, it returns today's date instead.\r\n     *\r\n     * @param String value Parse the date from a string to a localdate object\r\n     * @param String format Parse the date string in a specific format\r\n     * @return The current date if the value is empty\r\n     */\r\n    private static LocalDate getLocalDate(String value, String format) {\r\n        LocalDate date = LocalDate.now();\r\n        if (!value.isEmpty()) {\r\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format, Locale.GERMAN);\r\n            date = LocalDate.parse(value, formatter);\r\n        }\r\n\r\n        return date;\r\n    }\r\n\r\n    /**\r\n     * The getLocalDateTime function takes a String value and a String format as parameters.\r\n     * It returns the LocalDateTime object that is created from the given value, using the given format.\r\n     * If no value is provided, it will return today's date instead of an empty string.\r\n     *\r\n     * @param String value Pass the date string to be parsed\r\n     * @param String format Specify the format of the date string\r\n     * @return A localdatetime object\r\n     */\r\n    public static LocalDateTime getLocalDateTime(String value, String format) {\r\n        LocalDateTime date = LocalDateTime.now();\r\n        if (!value.isEmpty()) {\r\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format, Locale.GERMAN);\r\n            date = LocalDateTime.parse(value, formatter);\r\n        }\r\n\r\n        return date;\r\n    }\r\n\r\n    /**\r\n     * The getLocalDateTime function takes a Date object and a String format as parameters.\r\n     * It returns the LocalDateTime object that corresponds to the given date and format.\r\n     * If no value is passed, it returns the current time in LocalDateTime form.\r\n     *\r\n     * @param Date   value Convert the date to a localdatetime object\r\n     * @param String format Format the date\r\n     * @return A localdatetime object\r\n     */\r\n    public static LocalDateTime getLocalDateTime(Date value, String format) {\r\n        LocalDateTime date = LocalDateTime.now();\r\n        if (Objects.nonNull(value)) {\r\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format, Locale.GERMAN);\r\n            date = LocalDateTime.parse(formatDate(value, format), formatter);\r\n        }\r\n\r\n        return date;\r\n    }\r\n\r\n    /**\r\n     * The formatDate function takes a Date object and a String format as parameters.\r\n     * It returns the date in the specified format.\r\n     *\r\n     * @param Date   value Determine the date that is to be formatted\r\n     * @param String format Format the date\r\n     * @return A string in the format &quot;dd\r\n     */\r\n    public static String formatDate(Date value, String format) {\r\n        DateFormat formatter = new SimpleDateFormat(format, Locale.GERMAN);\r\n        return formatter.format(value);\r\n    }\r\n\r\n    /**\r\n     * The formatDateTime function takes a LocalDateTime value and an AstDateTimeFormat format,\r\n     * and returns the formatted date/time string.\r\n     *\r\n     * @param LocalDateTime     value Pass in the date and time value that will be formatted\r\n     * @param AstDateTimeFormat format Determine the format of the date and time\r\n     * @return A string representation of the date and time in a given format\r\n     */\r\n    public static String formatDateTime(LocalDateTime value, AstDateTimeFormat format) {\r\n        return formatDateTime(value, format.getFormat());\r\n    }\r\n\r\n    /**\r\n     * The formatDateTime function takes a LocalDateTime value and a String format as parameters.\r\n     * It returns the formatted date time string.\r\n     *\r\n     * @param LocalDateTime value Pass the date and time to be formatted\r\n     * @param String        format Define the format of the date\r\n     * @return A string\r\n     */\r\n    private static String formatDateTime(LocalDateTime value, String format) {\r\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format, Locale.GERMAN);\r\n        return value.format(formatter);\r\n    }\r\n\r\n    /**\r\n     * The formatDate function takes a LocalDate object and formats it according to the format string provided.\r\n     *\r\n     * @param LocalDate     value Pass in the date that will be formatted\r\n     * @param AstDateFormat format Specify the format of the date\r\n     * @return A string representation of the date value, formatted according to the format parameter\r\n     */\r\n    public static String formatDate(LocalDate value, AstDateFormat format) {\r\n        return formatDate(value, format.getFormat());\r\n    }\r\n\r\n    /**\r\n     * The formatDate function takes a LocalDate value and a String format as parameters.\r\n     * It returns the date in the specified format.\r\n     *\r\n     * @param LocalDate value Pass the date to be formatted\r\n     * @param String    format Specify the format of the date\r\n     * @return A string in the format &quot;dd\r\n     */\r\n    private static String formatDate(LocalDate value, String format) {\r\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(format, Locale.GERMAN);\r\n        return value.format(formatter);\r\n    }\r\n\r\n    /**\r\n     * The formatToPrice function takes a String as an argument and returns a String.\r\n     * The function converts the input string to a double, then formats it into\r\n     * currency format using DecimalFormat. If the price is 0, it returns an empty string.\r\n     *\r\n     * @param String price Convert the price to a double\r\n     * @return A string\r\n     */\r\n    public static String formatToPrice(String price) {\r\n        String result = \"\";\r\n        DecimalFormat df = new DecimalFormat(\"#0.00\", new DecimalFormatSymbols(Locale.GERMAN));\r\n        double dPrice = Parse.toDouble(price);\r\n        if (dPrice != 0.0f) {\r\n            result = df.format(dPrice);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The formatToPrice function takes a String price and a Locale locale as parameters.\r\n     * It returns the formatted price as a String.\r\n     * The function first creates an empty string result, which will be returned at the end of the function.\r\n     * Then it creates a DecimalFormat object df with two decimal places and using symbols from locale (e.g., &quot;,&quot; for thousands separator).\r\n     * Next, it converts price to double dPrice using Parse's toDouble method (see above).\r\n     * If dPrice is not 0, then we format it into result using df's format method; otherwise we leave result empty\r\n     *\r\n     * @param String price Convert the string to a double\r\n     * @param Locale locale Format the price to a specific locale\r\n     * @return A string with the price in the format of #0\r\n     */\r\n    public static String formatToPrice(String price, Locale locale) {\r\n        String result = \"\";\r\n        DecimalFormat df = new DecimalFormat(\"#0.00\", new DecimalFormatSymbols(locale));\r\n        double dPrice = Parse.toDouble(price);\r\n        if (dPrice != 0.0f) {\r\n            result = df.format(dPrice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\Parse.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\PermissionFactory.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.jpa.model.Permission;\r\nimport com.hom.ebmw.jpa.model.Role;\r\nimport com.hom.ebmw.jpa.model.RolePermission;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.view.MainView;\r\nimport com.hom.ebmw.view.errors.AccessDeniedView;\r\nimport com.hom.ebmw.view.logout.LogoutView;\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.router.RouteConfiguration;\r\nimport com.vaadin.flow.router.RouteData;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.Optional;\r\n\r\n@Slf4j\r\npublic class PermissionFactory {\r\n    private RolePermission activePermission = new RolePermission();\r\n    private Permission activePermissionClazz;\r\n    private Services services;\r\n\r\n    /**\r\n     * The getFactory function is used to create a new RolePermission object.\r\n     * The function takes in three parameters: user, services, and clazzName.\r\n     * The user parameter is the current User that has logged into the system.\r\n     * The services parameter is an instance of Services which contains all of the necessary service objects for this class to use (e.g., PermissionService).\r\n     * Finally, clazzName represents a String containing the name of a specific permission class (e.g., &quot;User&quot;).\r\n     *\r\n     * @param User     user Get the user's id\r\n     * @param Services services Access the database\r\n     * @param String   clazzName Identify the class that is being used\r\n     * @return The activepermission object\r\n     */\r\n    public RolePermission getFactory(User user, Services services, String clazzName) {\r\n        this.services = services;\r\n        try {\r\n            user.getId();\r\n            Optional<Permission> permClazz = services.getPermissionService().findByName(clazzName);\r\n            if (!permClazz.isPresent()) {\r\n                try {\r\n                    genPermissions();\r\n                } catch (NullPointerException e) {\r\n                    log.error(\"IS API Request / Web = \", e);\r\n                }\r\n\r\n                permClazz = services.getPermissionService().findByName(clazzName);\r\n                permClazz.ifPresent(perm -> {\r\n                    activePermissionClazz = perm;\r\n                    updateRolePermission(activePermissionClazz);\r\n                });\r\n\r\n                permClazz = services.getPermissionService().findByName(clazzName);\r\n            }\r\n            if (!permClazz.isPresent()) {\r\n                Permission permClass = new Permission();\r\n                permClass.setName(clazzName);\r\n                activePermissionClazz = services.getPermissionService().save(permClass);\r\n                updateRolePermission(activePermissionClazz);\r\n            } else {\r\n                activePermissionClazz = permClazz.get();\r\n            }\r\n\r\n            getActiveRights(user, clazzName);\r\n        } catch (Exception e) {\r\n            UI ui = UI.getCurrent();\r\n            if (Objects.nonNull(ui)) {\r\n                ui.access(() -> ui.navigate(AccessDeniedView.class));\r\n            }\r\n        }\r\n\r\n        return activePermission;\r\n    }\r\n\r\n    /**\r\n     * The updateRolePermission function is used to update the role permissions for a given permission.\r\n     *\r\n     * @param Permission perm Set the permission for each role\r\n     */\r\n    private void updateRolePermission(Permission perm) {\r\n        List<Role> roles = services.getRoleService().findAll();\r\n        roles.forEach(item -> {\r\n            RolePermission rolePerm = new RolePermission();\r\n            rolePerm.setPermission(perm);\r\n            rolePerm.setRole(item);\r\n            rolePerm = services.getRolePermissionService().save(rolePerm);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The genPermissions function is used to generate permissions for all the views in the application.\r\n     * It does this by first getting a list of all available routes, and then removing any routes that are not views (such as logout or access denied).\r\n     * Then it iterates through each route, and checks if there is already a permission with that name. If there isn't one, it creates one.\r\n     */\r\n    private void genPermissions() {\r\n        List<RouteData> routes = RouteConfiguration.forSessionScope().getAvailableRoutes();\r\n        routes.removeIf(route -> route.getNavigationTarget().equals(MainView.class)\r\n                || route.getNavigationTarget().equals(AccessDeniedView.class)\r\n                || route.getNavigationTarget().equals(LogoutView.class)); //\r\n\r\n        routes.forEach(route -> {\r\n            Optional<Permission> optPermission = services.getPermissionService()\r\n                    .findByName(route.getNavigationTarget().getName());\r\n            if (!optPermission.isPresent()) {\r\n                services.getPermissionService().save(new Permission(route.getNavigationTarget().getCanonicalName()));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The getActiveRights function is used to determine the permissions of a user.\r\n     * It takes in two parameters: a User object and a String representing the class name.\r\n     * The function first checks if the primary role of the user is null, and if it isn't,\r\n     * then it sets that as their primary role. If it is null, then we check all roles associated with this user\r\n     * to see which one has an inherits value of false (meaning that they are not inherited from another role).\r\n     * If there exists such a Role object in our list of roles for this particular User object, then we set that\r\n     *\r\n     * @param User   user Get the user's role and permissions\r\n     * @param String clazzName Determine the class that is being accessed\r\n     */\r\n    private void getActiveRights(User user, String clazzName) {\r\n        Role primaryRole = user.getRole();\r\n        if (Objects.isNull(primaryRole)) {\r\n            List<Role> roles = services.getRoleService().findAllInUser(user);\r\n            Optional<Role> optRole = roles.stream().filter(role -> !role.isInherits()).findFirst();\r\n            if (optRole.isPresent()) {\r\n                primaryRole = optRole.get();\r\n            } else {\r\n                roles.forEach(role -> {\r\n                    List<RolePermission> optPerm = services.getRolePermissionService().findByRoleAndPermission(role,\r\n                            activePermissionClazz);\r\n                    if (!optPerm.isEmpty()) {\r\n                        RolePermission perm = optPerm.get(0);\r\n                        if (role.isInherits()) {\r\n                            if (!activePermission.isDelete())\r\n                                activePermission.setDelete(perm.isDelete());\r\n                            if (!activePermission.isRead())\r\n                                activePermission.setRead(perm.isRead());\r\n                            if (!activePermission.isWrite())\r\n                                activePermission.setWrite(perm.isWrite());\r\n                            if (!activePermission.isEdit())\r\n                                activePermission.setEdit(perm.isEdit());\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (Objects.nonNull(primaryRole)) {\r\n            List<RolePermission> optPerm = services.getRolePermissionService().findByRoleAndPermission(primaryRole,\r\n                    activePermissionClazz);\r\n            if (!optPerm.isEmpty()) {\r\n                activePermission = optPerm.get(0);\r\n            }\r\n        }\r\n        log.trace(\"Permission: [\"\r\n                + (!Objects.isNull(activePermission) ? activePermission.getPermission().getName() : \"false\") + \"]\");\r\n\r\n    }\r\n}\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\PermissionFactory.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\SchedulerUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.jpa.model.SettingParameter;\r\nimport com.hom.ebmw.jpa.model.User;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.Delay;\r\nimport com.hom.ebmw.pojo.DelayWrapper;\r\nimport com.hom.ebmw.utilities.enums.FileParam;\r\nimport com.hom.ebmw.utilities.enums.ObjectType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.scheduling.support.CronTrigger;\r\n\r\nimport java.time.LocalDate;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\nimport java.util.stream.Collectors;\r\n\r\n@Slf4j\r\npublic class SchedulerUtils {\r\n\r\n    /**\r\n     * The startUploadDelay function is used to schedule the upload function.\r\n     * The upload function will be scheduled according to the cron expression in the setting table.\r\n     * If there is no cron expression, then it will default to &quot; 0 0 0 0 1 ?&quot; which means that it will run every month on day 1 at midnight.\r\n     *\r\n     * @param final Context ctx Get the services from the context\r\n     */\r\n    public static void startUploadDelay(final Context ctx) {\r\n\r\n        Optional<Setting> optSetting = ctx.getServices().getSettingServices()\r\n                .findByIdentifier(SettingType.UPLOAD_SCHEDULER.create());\r\n        optSetting.ifPresent(setting -> {\r\n            String cron = setting.getValue();\r\n            if (cron.isEmpty()) {\r\n                cron = \" 0 0 0 0 1 ?\";\r\n            }\r\n            ctx.getServices().getTaskscheduler().schedule(() -> upload(ctx, setting), new CronTrigger(cron));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The isValid function checks to see if the delay is valid.\r\n     *\r\n     * @param Delay        delay Get the prefix, days and type of a delay\r\n     * @param DelayWrapper wrapper Pass the delaywrapper object to the isvalid function\r\n     * @return True if the delay is valid\r\n     */\r\n    private static boolean isValid(Delay delay, DelayWrapper wrapper) {\r\n        boolean valid = false;\r\n        LocalDate compareDate = null;\r\n        compareDate = LocalDate.now().plusDays(delay.getDays());\r\n\r\n        valid = wrapper.getName().startsWith(delay.getPrefix()) && wrapper.getValidFrom().equals(compareDate)\r\n                && wrapper.getType().equals(delay.getType());\r\n\r\n        return valid;\r\n    }\r\n\r\n    /**\r\n     * The isValid function checks if the assortment is valid.\r\n     *\r\n     * @param Context    ctx Access the services\r\n     * @param Assortment assortment Get the name of the file\r\n     * @return True if the file name starts with a prefix defined in the settings\r\n     */\r\n    public static boolean isValid(Context ctx, Assortment assortment) {\r\n        boolean result = false;\r\n        Optional<Setting> optSetting = ctx.getServices().getSettingCustomServices().findBySettingType(ctx,\r\n                SettingType.UPLOAD_SCHEDULER);\r\n        if (optSetting.isPresent()) {\r\n            List<SettingParameter<Delay>> spDepaies = ctx.getServices().getSettingParameterService()\r\n                    .findAllBySettingOrderByDisplayOrder(optSetting.get());\r\n\r\n            final ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n            Optional<SettingParameter<Delay>> optDelay = spDepaies.stream()\r\n                    .filter(item -> assortment.getName().startsWith(item.getValue().getPrefix())\r\n                            && type.equals(item.getValue().getType()))\r\n                    .findFirst();\r\n            result = optDelay.isPresent();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The upload function is responsible for uploading the assortment to the customer's FTP server.\r\n     * It does this by first checking if there are any assortments in queue, and then checks if they have been queued for a long enough time.\r\n     * If so, it uploads them to the customer's FTP server using AssortmentUtil.upload().\r\n     *\r\n     * @param Context ctx Access the services and other objects\r\n     * @param Setting setting Get the setting parameter from the database\r\n     */\r\n    private static void upload(Context ctx, Setting setting) {\r\n        List<SettingParameter<Delay>> spDepaies = ctx.getServices().getSettingParameterService()\r\n                .findAllBySettingOrderByDisplayOrder(setting);\r\n        List<DelayWrapper> delaies = ctx.getServices().getDelayParameterRepository()\r\n                .getDelayWrappers(FileParam.QUEUE_ON);\r\n        spDepaies.forEach(item -> {\r\n            final Delay delay = item.getValue();\r\n            List<DelayWrapper> filtered = delaies.stream().filter(wrapper -> isValid(delay, wrapper))\r\n                    .collect(Collectors.toList());\r\n            log.info(\"Start upload for \" + delay.getPrefix() + \" | \" + delay.getType() + \" [\" + filtered.size() + \"] \");\r\n\r\n            filtered.forEach(valid -> {\r\n                Optional<Assortment> optAssortment = ctx.getServices().getAssortmentService().findById(valid.getId());\r\n                optAssortment.ifPresent(assortment -> {\r\n                    ctx.getUserSession().put(Params.ACTIVE_ASSORTMENT, assortment);\r\n                    ctx.getUserSession().put(Params.ACTIVE_CUSTOMER, valid.getCustomer());\r\n                    AssortmentUtil.upload(ctx, assortment);\r\n                    CompUtils.removeParameter(ctx, FileParam.QUEUE_ON, assortment);\r\n                    CompUtils.removeParameter(ctx, FileParam.QUEUE_BY, assortment);\r\n                    Optional<User> optUser = ctx.getServices().getUserServices().findByUserId(\"FAKE\");\r\n                    optUser.ifPresent(user -> CompUtils.setParameter(ctx, FileParam.UPLOAD_BY, user, assortment));\r\n                    ctx.getUserSession().remove(Params.ACTIVE_ASSORTMENT);\r\n                    ctx.getUserSession().remove(Params.ACTIVE_CUSTOMER);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\SchedulerUtils.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-nAY1sQJeAM9djgz0u8VWYtIsLiTOBLKQ",
    "created" : 1762171156,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\utilities\\\\*\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential NullPointerException in checkOfDoubles when accessing item.getAstFile().getName() without null-check on getAstFile()\",\n      \"justification\": \"If an AssortmentDatafile has a null AstFile, calling getName() will throw NPE, breaking the import flow.\",\n      \"action\": \"Add a null-check for item.getAstFile() before accessing getName(); skip or log such entries; add unit test for null AstFile handling.\",\n      \"source\": \"FilterRunUtils.checkOfDoubles, line with assortmentDataFile.removeIf\",\n      \"component\": \"filter-runner\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Resource leak in HttpClientHelper.getResponseStringFromConn ‚Äì BufferedReader is never closed\",\n      \"justification\": \"Unclosed streams can exhaust file descriptors under heavy load, leading to IO errors.\",\n      \"action\": \"Wrap reader creation in try-with-resources; ensure streams are closed after reading; add integration test simulating many requests.\",\n      \"source\": \"HttpClientHelper.getResponseStringFromConn\",\n      \"component\": \"http-client\",\n      \"impact_scope\": \"performance-critical\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Inconsistent JSON response type in HttpClientHelper.processResponse (responseMsg sometimes String, sometimes JSONObject)\",\n      \"justification\": \"Consumers expecting a JSONObject may encounter a ClassCastException when responseMsg is an empty string.\",\n      \"action\": \"Always wrap responseMsg in a JSONObject, using null or empty JSONObject for empty responses; update documentation and tests.\",\n      \"source\": \"HttpClientHelper.processResponse\",\n      \"component\": \"http-client\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Inefficient and buggy listSplitter implementation in InternalUtils\",\n      \"justification\": \"While loop adds an extra empty sublist when skip equals size; repeated stream operations cause O(n^2) time and high memory usage on large lists.\",\n      \"action\": \"Rewrite listSplitter using a simple for-loop or subList; stop when skip >= size; add unit tests for edge cases (size 0, exact multiples).\",\n      \"source\": \"InternalUtils.listSplitter\",\n      \"component\": \"utils\",\n      \"impact_scope\": \"performance-critical\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential NPE in readFiles when storage.getFileblob() returns null but storage itself could be null\",\n      \"justification\": \"CompUtils.getStorage may return null; accessing getFileblob() would cause NPE, interrupting the import pipeline.\",\n      \"action\": \"Validate storage is non-null before calling getFileblob(); handle missing storage with proper exception; add tests for missing storage scenario.\",\n      \"source\": \"FilterRunUtils.readFiles\",\n      \"component\": \"filter-runner\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Repeated saving of Assortment inside readFiles loop\",\n      \"justification\": \"Calling ctx.getServices().getAssortmentService().save(assortment) for each file incurs unnecessary DB writes, impacting performance.\",\n      \"action\": \"Move save operation outside the loop or batch updates after processing all files; verify behavior with integration test.\",\n      \"source\": \"FilterRunUtils.readFiles\",\n      \"component\": \"filter-runner\",\n      \"impact_scope\": \"performance\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Default cron expression in SchedulerUtils.startUploadDelay contains leading space and invalid format\",\n      \"justification\": \"An invalid cron expression will cause the scheduler to fail silently, preventing scheduled uploads.\",\n      \"action\": \"Correct default to a valid expression like \\\"0 0 0 1 * ?\\\"; add validation for cron strings; unit test scheduler initialization.\",\n      \"source\": \"SchedulerUtils.startUploadDelay\",\n      \"component\": \"scheduler\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Broad catch of generic Exception in PermissionFactory.getFactory hides underlying errors\",\n      \"justification\": \"Swallowing exceptions and redirecting to AccessDeniedView makes debugging difficult and may mask configuration problems.\",\n      \"action\": \"Catch specific exceptions (e.g., DataAccessException); log full stack trace; rethrow or handle gracefully; add tests for error paths.\",\n      \"source\": \"PermissionFactory.getFactory\",\n      \"component\": \"security\",\n      \"impact_scope\": \"security-critical\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"PermissionFactory.genPermissions uses route.getNavigationTarget().getCanonicalName() but saves Permission with canonical name while later lookup uses class name\",\n      \"justification\": \"Inconsistent naming can cause duplicate permissions or missed matches, leading to incorrect access control.\",\n      \"action\": \"Standardize permission naming (use getName() or getCanonicalName consistently); add unit tests for permission creation and lookup.\",\n      \"source\": \"PermissionFactory.genPermissions\",\n      \"component\": \"security\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"SchedulerUtils.isValid compares wrapper.getValidFrom() with compareDate using equals, but compareDate includes plusDays which may not reflect intended validation logic\",\n      \"justification\": \"Incorrect date comparison could cause valid delays to be ignored, preventing uploads.\",\n      \"action\": \"Clarify business rule; possibly compare wrapper.getValidFrom() >= LocalDate.now() plus delay; adjust logic and add tests for edge dates.\",\n      \"source\": \"SchedulerUtils.isValid\",\n      \"component\": \"scheduler\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"2\",\n    \"top_todos\": [\n      \"Add null-checks for AstFile in checkOfDoubles and storage in readFiles to prevent NPEs\",\n      \"Fix resource leak and inconsistent JSON handling in HttpClientHelper\",\n      \"Rewrite InternalUtils.listSplitter for correct behavior and O(n) performance\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to output a JSON object reviewing each file/chunk? The prompt: \"You are a senior code reviewer. Analyze each code chunk.\" We have multiple files. Should we produce one JSON per file? The schema expects \"file\": string and \"issues\": [] and summary. Probably we need to produce one JSON per file? But spec says answer must be a single JSON object. It could include multiple issues across the whole set, but file field is a single file path. However we have many files. Could combine? Might need separate JSON per file? The instruction: \"Du analysierst jeweils einen Code-Chunk.\" Means each chunk separate, but the system expects one JSON per request. Probably we need to output for each file separately? The hard rule: \"Antwort immer als ein einziges JSON-Objekt\". So maybe we need to combine all issues from all files into one JSON, with file set to something like \"multiple\" or null? But schema requires file string path of the file or chunk ID. Could we set file to \"multiple\"? Might be acceptable. But better to produce separate outputs? The instruction: \"Du analysierst jeweils einen Code-Chunk.\" In this conversation, they've provided multiple chunks. Possibly they expect one JSON per file, but they said only one JSON object. Might need to produce array? No schema doesn't allow array of results.\n\nGiven constraints, maybe we should only review the first file? But they gave many files. Could combine all issues, but file field ambiguous.\n\nWe could set file to \"C:\\\\Users\\\\mtheele\\\\IdeaProjects\\\\TIP - Assortmenttool_2\\\\src\\\\main\\\\java\\\\com\\\\hom\\\\ebmw\\\\utilities\\\\*\". Provide issues across files, each issue source indicating class/method.\n\nLet's compile issues up to 10.\n\nIdentify key problems:\n\n1. FilterRunUtils.checkOfDoubles: removes items from assortmentDataFile using removeIf with Objects.isNull(item.getAstFile().getName()) -> potential NullPointerException if item.getAstFile() is null. severity High.\n\n2. readFiles: uses Blob.loadFromCompressedFile without handling IOException, could swallow exceptions. Also uses ctx.getServices().getAssortmentService().save inside loop; may cause performance issues.\n\n3. reloadAddFilter javadoc includes stray code snippet inside comment, not bug.\n\n4. listSplitter in InternalUtils: while loop condition skip <= size leads to final empty list added. Might cause extra empty list. Also inefficient.\n\n5. listSplitter uses streams repeatedly; could cause O(n^2) performance.\n\n6. HttpClientHelper.getResponseStringFromConn: does not close BufferedReader, resource leak. Severity Med.\n\n7. HttpClientHelper.processResponse: returns JSONObject with responseMsg set to \"\" string or JSONObject; could be inconsistent type (String vs JSONObject). Might cause runtime issues. Severity Low.\n\n8. PermissionFactory.getFactory: catches generic Exception and navigates to AccessDeniedView, may hide real errors; also uses UI.getCurrent() which may be null in non-UI thread.\n\n9. SchedulerUtils.startUploadDelay: cron default string has leading space \" 0 0 0 0 1 ?\" which is invalid cron expression. Also if cron empty sets to that, could cause scheduling errors. Severity Med.\n\n10. SchedulerUtils.isValid: compares wrapper.getValidFrom().equals(compareDate) but compareDate includes plusDays, might be wrong logic; also null handling.\n\nWe have 10.\n\nProvide summary rating maybe 2 stars.\n\nNow craft JSON."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 2218,
      "prompt_tokens" : 24776,
      "total_tokens" : 26994
    },
    "timings" : {
      "cache_n" : 527,
      "prompt_n" : 24249,
      "prompt_ms" : 18303.558,
      "prompt_per_token_ms" : 0.7548170233824075,
      "prompt_per_second" : 1324.824386602867,
      "predicted_n" : 2218,
      "predicted_ms" : 26670.879,
      "predicted_per_token_ms" : 12.024742560865645,
      "predicted_per_second" : 83.16186354412991
    }
  }
}