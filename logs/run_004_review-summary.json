{
  "timestamp" : "2025-11-03T12:52:48.3943764",
  "index" : 4,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseCustomRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.configuration.security.SessionUtils;\r\nimport com.hom.ebmw.jpa.dao.FilterBaseDAO;\r\nimport com.hom.ebmw.jpa.dao.UserDAO;\r\nimport com.hom.ebmw.jpa.model.ArticleBase;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filter;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.UserSession;\r\nimport com.hom.ebmw.utilities.InternalUtils;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.TranslationProvider;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.stereotype.Repository;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.*;\r\n\r\nimport static com.hom.ebmw.utilities.constans.ASTConst.DB_DELIMITER;\r\nimport static com.hom.ebmw.view.components.SpcComponent.*;\r\n\r\n@Repository\r\npublic class FilterBaseCustomRepository {\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    private final FilterBaseDAO filterBaseDefaultServices;\r\n\r\n    private final TranslationProvider i18n;\r\n\r\n    private final UserDAO userSession;\r\n\r\n    /**\r\n     * The FilterBaseCustomRepository function is used to create a custom repository for the FilterBase entity.\r\n     * The function takes in a JdbcTemplate, FilterBaseDAO, TranslationProvider and UserDAO as parameters.\r\n     * The function returns nothing.\r\n     *\r\n     * @param JdbcTemplate        dbServices Access the database\r\n     * @param FilterBaseDAO       filterBaseDefaultServices Access the default services\r\n     * @param TranslationProvider i18n Translate the filterbase\r\n     * @param UserDAO             userSession Get the user's language\r\n     * @return A filterbasecustomrepository object\r\n     */\r\n    public FilterBaseCustomRepository(JdbcTemplate dbServices, FilterBaseDAO filterBaseDefaultServices, TranslationProvider i18n, UserDAO userSession) {\r\n        this.dbServices = dbServices;\r\n        this.filterBaseDefaultServices = filterBaseDefaultServices;\r\n        this.i18n = i18n;\r\n        this.userSession = userSession;\r\n    }\r\n\r\n    /**\r\n     * The removeAllIn function is used to remove all of the Filterbase objects in a list from the database.\r\n     * The function takes in a List&lt;Filterbase&gt; object, and splits it into smaller lists of 90 items each.\r\n     * This is done because SQL Server has an upper limit on how many parameters can be passed into one query, which is 2100.\r\n     * If we were to pass more than that number of parameters into our query, then we would get an error message saying that there are too many arguments for this function call.\r\n     * So instead, we split up our list so that each sublist contains no more than 90 items (\r\n     *\r\n     * @param List&lt;Filterbase&gt; filters Pass a list of filterbase objects to the removeallin function\r\n     * @return A list of filterbase\r\n     */\r\n    @Transactional\r\n    public void removeAllIn(List<Filterbase> filters) {\r\n        int partSize = 90;\r\n        List<List<Filterbase>> splitList = InternalUtils.listSplitter(filters, partSize);\r\n        splitList.forEach(items -> {\r\n            String ids = InternalUtils.listToString(items, item -> String.valueOf(item.getId()), \",\");\r\n            if (!ids.isEmpty()) {\r\n                dbServices.execute(\"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE PARENT_ID IN (\" + ids + \") \");\r\n                dbServices.execute(\"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE ID IN (\" + ids + \")\");\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The remove function is used to remove a filter from the database.\r\n     *\r\n     * @param Filterbase filters Pass the filterbase object to the remove function\r\n     */\r\n    @Transactional\r\n    public void remove(Filterbase filters) {\r\n        String sqlExecute = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE ID = '\" + filters.getEntityIdentifier() + \"'\";\r\n        dbServices.execute(sqlExecute);\r\n    }\r\n\r\n    /**\r\n     * The removeByTypeAndAssortment function removes all filters of a given type and assortment.\r\n     *\r\n     * @param FilterType type Determine which type of filter to remove\r\n     * @param Assortment assortment Specify which assortment the filter belongs to\r\n     */\r\n    @Transactional\r\n    public void removeByTypeAndAssortment(FilterType type, Assortment assortment) {\r\n        String sqlExecute = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE TYPE = '\" + type.name() + \"' AND ASSORTMENT_ID = \" + assortment.getId();\r\n        dbServices.execute(sqlExecute);\r\n    }\r\n\r\n    /**\r\n     * The removeWhereStructureTypeLike function removes all rows from the AST_FILTERBASE table where the TYPE column is equal to 'STRUCTURE' and\r\n     * STRUCTURE_TYPE column is equal to a given type. The function also checks that ASSORTMENT_ID and FILTER_ID are null.\r\n     *\r\n     * @param String type Determine the type of filter to be removed\r\n     */\r\n    @Transactional\r\n    public void removeWhereStructureTypeLike(String type) {\r\n        String sqlExecute = \"\";\r\n        sqlExecute = \"ALTER TABLE AST_FILTERBASE NOCHECK CONSTRAINT ALL\";\r\n        dbServices.execute(sqlExecute);\r\n\r\n        sqlExecute = \"DELETE AST_FILTERBASE WHERE TYPE = 'STRUCTURE' AND STRUCTURE_TYPE = '\" + type + \"' \"\r\n                + \"AND ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL\";\r\n        dbServices.execute(sqlExecute);\r\n\r\n        sqlExecute = \"ALTER TABLE AST_FILTERBASE CHECK CONSTRAINT ALL\";\r\n        dbServices.execute(sqlExecute);\r\n    }\r\n\r\n    /**\r\n     * The removeByFilterbase function removes a Filterbase from the database.\r\n     *\r\n     * @param Filterbase base Get the id of the filterbase to be deleted\r\n     */\r\n    @Transactional\r\n    public void removeByFilterbase(Filterbase base) {\r\n\r\n        String sqlExecute = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE PARENT_ID = \" + base.getId() + \" \";\r\n        dbServices.execute(sqlExecute);\r\n\r\n        sqlExecute = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE ID = \" + base.getId() + \" \";\r\n        dbServices.execute(sqlExecute);\r\n    }\r\n\r\n    /**\r\n     * The removeByAssortment function removes all FilterBase objects from the database that are associated with a given Assortment object.\r\n     *\r\n     * @param Assortment assortment Find the assortment in the database\r\n     */\r\n    @Transactional\r\n    public void removeByAssortment(Assortment assortment) {\r\n        String sqlExecute = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE ASSORTMENT_ID = '\" + assortment.getId() + \"' \";\r\n        dbServices.execute(sqlExecute);\r\n    }\r\n\r\n    /**\r\n     * The countByAssortment function returns the number of filters in a given assortment.\r\n     *\r\n     * @param Assortment assortment Filter the results\r\n     */\r\n    @Transactional\r\n    public int countByAssortment(Assortment assortment) {\r\n        String sqlExecute = \"SELECT COUNT(ID) FROM AST_FILTERBASE WHERE ASSORTMENT_ID = '\" + assortment.getId() + \"' AND [DELETE] = 0 \";\r\n        return dbServices.queryForObject(sqlExecute, Integer.class);\r\n    }\r\n\r\n    /**\r\n     * The countByFilter function returns the number of rows in the AST_FILTERBASE table that have a FILTER_ID equal to filter.getId() and [DELETE] = 0\r\n     *\r\n     * @param Filter filter Filter the results of the query\r\n     * @return The number of rows in the table that match the filter\r\n     */\r\n    @Transactional\r\n    public int countByFilter(Filter filter) {\r\n        String sqlExecute = \"SELECT COUNT(ID) FROM AST_FILTERBASE WHERE FILTER_ID = '\" + filter.getId() + \"' AND [DELETE] = 0 \";\r\n        return dbServices.queryForObject(sqlExecute, Integer.class);\r\n    }\r\n\r\n    /**\r\n     * The removeByFilter function removes a filter from the database.\r\n     *\r\n     * @param Filter filter Get the id of the filter that is being deleted\r\n     */\r\n    @Transactional\r\n    public void removeByFilter(Filter filter) {\r\n\r\n        String sqlChilds = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE PARENT_ID = '\" + filter.getId() + \"' \";\r\n        dbServices.execute(sqlChilds);\r\n\r\n        String sqlParent = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE FILTER_ID = '\" + filter.getId() + \"' \";\r\n        dbServices.execute(sqlParent);\r\n    }\r\n\r\n    /**\r\n     * The insertArticleInFilterBase function is used to insert articles into the filterbase.\r\n     *\r\n     * @param UserSession             uSession Get the active assortment\r\n     * @param List&lt;ArticleBase&gt; articleBases Get the article number from each articlebase object\r\n     */\r\n    public void insertArticleInFilterBase(UserSession uSession, List<ArticleBase> articleBases) {\r\n        Assortment assortment = uSession.get(Params.ACTIVE_ASSORTMENT);\r\n        String individual = FilterType.INDIVIDUAL.name();\r\n        Filterbase parent = new Filterbase();\r\n        parent.setEntityIdentifier(individual + DB_DELIMITER + assortment.getId());\r\n        Optional<Filterbase> optParent = filterBaseDefaultServices\r\n                .findByEntityIdentifierAndDelete(individual + DB_DELIMITER + assortment.getId(), false);\r\n        if (!optParent.isPresent()) {\r\n            parent.setAssortment(assortment);\r\n            parent.setLabel(individual);\r\n            parent.setIdentifier(individual);\r\n            parent.setEntityIdentifier(individual + DB_DELIMITER + assortment.getId());\r\n            parent.setType(individual);\r\n            parent.setDirection(Filterbase.REMOVE_INDIVIDUAL);\r\n            parent = filterBaseDefaultServices.save(parent);\r\n        } else {\r\n            parent = optParent.get();\r\n            List<Filterbase> currentIndividuals = filterBaseDefaultServices.findAllByParentAndDelete(parent, false);\r\n            currentIndividuals.forEach(filters -> {\r\n                articleBases.removeIf(article -> article.getArticleNr().equals(filters.getIdentifier()));\r\n            });\r\n        }\r\n\r\n        int partSize = 1000;\r\n        final Filterbase parentFilter = parent;\r\n        List<List<ArticleBase>> splitList = InternalUtils.listSplitter(articleBases, partSize);\r\n        splitList.forEach(items -> {\r\n            insertFilterBaseIn(items, parentFilter);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The insertArticleInFilterBase function takes a list of ArticleBase objects and a Filterbase object as input.\r\n     * It then checks if the articleNr of each ArticleBase object is already present in the database, by checking\r\n     * if it exists in any Filterbase objects that have parent equal to the given Filterbase object. If an articleNr\r\n     * is not found, it will be added to a new list called &quot;newArticles&quot;. The function then splits this newArticles\r\n     * list into sublists with 1000 items each (to avoid memory issues), and calls insertFilterBaseIn on these sublists.\r\n     *\r\n     * @param List&lt;ArticleBase&gt; articleBases Get the articlenr from each articlebase object\r\n     * @param final                   Filterbase parent Set the parent of the new filterbase objects\r\n     */\r\n    public void insertArticleInFilterBase(List<ArticleBase> articleBases, final Filterbase parent) {\r\n        List<Filterbase> currentIndividuals = filterBaseDefaultServices.findAllByParentAndDelete(parent, false);\r\n        currentIndividuals.forEach(filters -> {\r\n            articleBases.removeIf(article -> article.getArticleNr().equals(filters.getIdentifier()));\r\n        });\r\n        int partSize = 1000;\r\n        List<List<ArticleBase>> splitList = InternalUtils.listSplitter(articleBases, partSize);\r\n        splitList.forEach(items -> {\r\n            insertFilterBaseIn(items, parent);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The insertFilterBaseIn function takes a list of articles and a parent filterbase object.\r\n     * It then creates an insert statement for each article in the list, using the parent filterbase as its parent.\r\n     * The function then executes this insert statement on the database.\r\n     *\r\n     * @param List&lt;ArticleBase&gt; articles Get the article id and the filterbase parent is used to get the parent id\r\n     * @param Filterbase              parent Get the parent_id of the filterbase table\r\n     */\r\n    @Transactional\r\n    private void insertFilterBaseIn(List<ArticleBase> articles, Filterbase parent) {\r\n        String body = \"\";\r\n        String insertHeader = \"INSERT INTO [dbo].[AST_FILTERBASE] ([ENTITY_IDENTIFIER],[IDENTIFIER],[TYPE],[DIRECTION],[PARENT_ID],[FILTER_ID],[ASSORTMENT_ID],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[LABEL],[DELETE]) VALUES \";\r\n        for (ArticleBase article : articles) {\r\n            body += (body.isEmpty() ? \"\" : \",\") + insertArticleInFilter(article, parent);\r\n        }\r\n        dbServices.execute(insertHeader + \" \" + body);\r\n    }\r\n\r\n    /**\r\n     * The insertFilterInFilterBase function takes a list of filters and inserts them into the filterbase table.\r\n     *\r\n     * @param List&lt;Filterbase&gt; filters Pass a list of filterbase objects to the function\r\n     */\r\n    public void insertFilterInFilterBase(List<Filterbase> filters) {\r\n        int partSize = 1000;\r\n        List<List<Filterbase>> splitList = InternalUtils.listSplitter(filters, partSize);\r\n        splitList.forEach(items -> {\r\n            insertFilterBaseIn(items);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The insertFilterBaseIn function takes a list of Filterbase objects and inserts them into the AST_FILTERBASE table.\r\n     *\r\n     * @param List&lt;Filterbase&gt; filters Insert the filters into the database\r\n     */\r\n    @Transactional\r\n    public void insertFilterBaseIn(List<Filterbase> filters) {\r\n        String body = \"\";\r\n        String insertHeader = \"INSERT INTO [dbo].[AST_FILTERBASE] ([ENTITY_IDENTIFIER],[IDENTIFIER],[TYPE],[DIRECTION],[PARENT_ID],[FILTER_ID],[ASSORTMENT_ID],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[LABEL],[DELETE]) VALUES \";\r\n        if (!filters.isEmpty()) {\r\n            for (Filterbase filter : filters) {\r\n                body += (body.isEmpty() ? \"\" : \",\") + insertFilterInFilter(filter);\r\n            }\r\n            dbServices.execute(insertHeader + \" \" + body);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The cloneFromFilter function takes a filter and an assortment as parameters.\r\n     * It then deletes any previous filters that were cloned from the same filter,\r\n     * but to a different assortment. This is done by deleting all children of the\r\n     * previous filters, then deleting the parent filters themselves. The function\r\n     * then inserts new rows into AST_FILTERBASE for each row in AST_FILTERBASE where\r\n     * FILTER_ID = from (the parameter) and IDENTIFIER IS NOT NULL AND [DELETE] = 0 .\r\n     *\r\n     * @param Filter     from Get the filter id to be cloned\r\n     * @param Assortment to Get the assortment id\r\n     */\r\n    @Transactional\r\n    public void cloneFromFilter(Filter from, Assortment to) {\r\n\r\n        String deletePreviousChild = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE PARENT_ID IN (\"\r\n                + \"Select ID FROM AST_FILTERBASE WHERE ASSORTMENT_ID = \" + to.getId() + \" AND LABEL IN (\"\r\n                + \"Select LABEL from AST_FILTERBASE where FILTER_ID = \" + from.getId() + \"))\";\r\n        dbServices.execute(deletePreviousChild);\r\n\r\n        String deletePrevious = \"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE ASSORTMENT_ID = \" + to.getId() + \" AND LABEL IN (\"\r\n                + \"Select LABEL from AST_FILTERBASE where FILTER_ID = \" + from.getId() + \")\";\r\n        dbServices.execute(deletePrevious);\r\n\r\n        String insertFilter = \"INSERT INTO AST_FILTERBASE (ENTITY_IDENTIFIER, IDENTIFIER, LABEL, TYPE, DIRECTION, STRUCTURE_GROUP_ID,[STRUCTURE_TYPE], PARENT_ID, CHILD_COUNT, SORT, ASSORTMENT_ID, FILTER_ID)\"\r\n                + \"SELECT CONCAT(IDENTIFIER , '\" + DB_DELIMITER + \"', TYPE, '\" + DB_DELIMITER + \"', \" + to.getId()\r\n                + \"), IDENTIFIER, LABEL, TYPE, DIRECTION, STRUCTURE_GROUP_ID,[STRUCTURE_TYPE], PARENT_ID, CHILD_COUNT, SORT, \"\r\n                + to.getId() + \", NULL \" + \"FROM AST_FILTERBASE WHERE FILTER_ID = \" + from.getId()\r\n                + \" AND IDENTIFIER IS NOT NULL AND [DELETE] = 0 \";\r\n        dbServices.execute(insertFilter);\r\n\r\n        String insertChild = \"INSERT INTO [dbo].[AST_FILTERBASE](ENTITY_IDENTIFIER,[IDENTIFIER],[LABEL],[TYPE],[DIRECTION],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[PARENT_ID],[CHILD_COUNT],[SORT],[ASSORTMENT_ID], FILTER_ID) \"\r\n                + \"SELECT DISTINCT CONCAT(child.IDENTIFIER ,  '\" + DB_DELIMITER + \"' , child.TYPE, '\" + DB_DELIMITER\r\n                + \"', \" + to.getId()\r\n                + \"),child.[IDENTIFIER],child.[LABEL],child.[TYPE],child.[DIRECTION],child.[STRUCTURE_GROUP_ID],child.[STRUCTURE_TYPE], parentB.ID, child.[CHILD_COUNT],child.[SORT],\"\r\n                + to.getId() + \", NULL \" + \"FROM AST_FILTERBASE child \"\r\n                + \"INNER JOIN AST_FILTERBASE parentA ON child.PARENT_ID = parentA.ID AND parentA.FILTER_ID = \"\r\n                + from.getId() + \" AND child.[DELETE] = 0 \"\r\n                + \"INNER JOIN AST_FILTERBASE parentB ON parentB.IDENTIFIER = parentA.IDENTIFIER AND parentB.ASSORTMENT_ID = \"\r\n                + to.getId() + \" AND parentA.[DELETE] = 0 \";\r\n        dbServices.execute(insertChild);\r\n    }\r\n\r\n    /**\r\n     * The clone function is used to copy the filters from one assortment to another.\r\n     * The function first copies all of the parent filters, then it copies all of the child filters.\r\n     * It does this by using a SQL query that inserts into AST_FILTERBASE (the table where filter information is stored)\r\n     * and selects from AST_FILTERBASE (the table where filter information is stored).  The insert statement uses a select statement with multiple joins in order to get data for each column in AST_FILTERBASE.\r\n     *\r\n     * @param Assortment from Get the assortment id from which to copy the filters\r\n     * @param Assortment to Set the assortment id of the cloned filters\r\n     */\r\n    @Transactional\r\n    public void clone(Assortment from, Assortment to) {\r\n        String insertParent = \"INSERT INTO [dbo].[AST_FILTERBASE]([ENTITY_IDENTIFIER],[IDENTIFIER],[LABEL],[TYPE],[DIRECTION],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[PARENT_ID],[CHILD_COUNT],[SORT],[ASSORTMENT_ID], FILTER_ID, [DELETE]) \"\r\n                + \" SELECT CONCAT(IDENTIFIER , '\" + DB_DELIMITER + \"', TYPE, '\" + DB_DELIMITER + \"', \" + to.getId()\r\n                + \"),[IDENTIFIER],[LABEL],[TYPE],[DIRECTION]\"\r\n                + \",[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],replace([PARENT_ID],'\" + DB_DELIMITER + from.getId() + \"','\"\r\n                + DB_DELIMITER + to.getId() + \"'),[CHILD_COUNT],[SORT],\" + to.getId() + \", NULL, 0 \"\r\n                + \"  FROM [dbo].[AST_FILTERBASE] WHERE ASSORTMENT_ID = \" + from.getId() + \" AND PARENT_ID IS NULL AND [DELETE] = 0 AND TYPE != '\" + FilterType.INDIVIDUAL_ADM.name() + \"' \";\r\n        dbServices.execute(insertParent);\r\n\r\n        String insertChild = \"INSERT INTO [dbo].[AST_FILTERBASE](ENTITY_IDENTIFIER,[IDENTIFIER],[LABEL],[TYPE],\" +\r\n                \"[DIRECTION],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[PARENT_ID],[CHILD_COUNT],[SORT],[ASSORTMENT_ID],FILTER_ID, [DELETE])\"\r\n                + \"SELECT DISTINCT CONCAT(child.IDENTIFIER ,  '\" + DB_DELIMITER + \"' , child.TYPE, '\" + DB_DELIMITER\r\n                + \"', \" + to.getId()\r\n                + \"),child.[IDENTIFIER],child.[LABEL],child.[TYPE],child.[DIRECTION],child.[STRUCTURE_GROUP_ID],child.[STRUCTURE_TYPE], parentB.ID, child.[CHILD_COUNT],child.[SORT],\"\r\n                + to.getId() + \", NULL , 0\" + \"FROM AST_FILTERBASE child \"\r\n                + \"INNER JOIN AST_FILTERBASE parentA ON child.PARENT_ID = parentA.ID AND parentA.ASSORTMENT_ID = \"\r\n                + from.getId() + \" \"\r\n                + \"INNER JOIN AST_FILTERBASE parentB ON parentB.IDENTIFIER = parentA.IDENTIFIER AND parentB.ASSORTMENT_ID = \"\r\n                + to.getId();\r\n        dbServices.execute(insertChild);\r\n    }\r\n\r\n    /**\r\n     * The insertArticleInFilter function is used to insert an article into a filter.\r\n     *\r\n     * @param ArticleBase article Get the article number\r\n     * @param Filterbase  parent Get the parent id, type and assortment\r\n     * @return A string that looks like this:\r\n     */\r\n    private String insertArticleInFilter(ArticleBase article, Filterbase parent) {\r\n        // [ENTITY_IDENTIFIER],[IDENTIFIER],[TYPE],[DIRECTION],[PARENT_ID],[ASSORTMENT_ID],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[LABEL],[DELETE]\r\n        String body = String.format(\"('%s','%s','%s',%d,'%s',%s,'%s',0,'','INDIVIDUAL',0)\"\r\n                /* X [ENTITY_IDENTIFIER] */, parent.getLabel() + \":\" + article.getArticleNr() + DB_DELIMITER + parent.getType()\r\n                        + DB_DELIMITER + parent.getAssortment().getId()\r\n                /* X [IDENTIFIER] */, article.getArticleNr()\r\n                /* X [TYPE] */, parent.getType()\r\n                /* X [DIRECTION] */, parent.getDirection()\r\n                /* X [PARENT_ID] */, parent.getId()\r\n                /* X [FILTER_ID] */, \"NULL\"\r\n                /* X [ASSORTMENT_ID] */, parent.getAssortment().getId());\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * The insertFilterInFilter function is used to insert a filter into the database.\r\n     *\r\n     * @param Filterbase filter Get the values for the insertfilterinfilter function\r\n     * @return A string\r\n     */\r\n    private String insertFilterInFilter(Filterbase filter) {\r\n        // [ID],[IDENTIFIER],[TYPE],[DIRECTION],[PARENT_ID],[ASSORTMENT_ID],[STRUCTURE_GROUP_ID],[STRUCTURE_TYPE],[LABEL],[DELETE]\r\n        String sParent = \"NULL\";\r\n        if (Objects.nonNull(filter.getParent())) {\r\n            sParent = String.valueOf(filter.getParent().getId());\r\n        }\r\n\r\n        String body = String.format(\"('%s','%s','%s',%d, %s, %s, %s, %d,'%s','%s',0)\"\r\n                /* X [ENTITY_IDENTIFIER] */, filter.getEntityIdentifier().replace(\"'\", \"''\")\r\n                /* X [IDENTIFIER] */, filter.getIdentifier().replace(\"'\", \"''\")\r\n                /* X [TYPE] */, filter.getType()\r\n                /* X [DIRECTION] */, filter.getDirection()\r\n                /* X [PARENT_ID] */, sParent\r\n                /* X [FILTER_ID] */, Objects.isNull(filter.getFilter()) ? \"NULL\" : String.valueOf(filter.getFilter().getId())\r\n                /* X [ASSORTMENT_ID] */, Objects.isNull(filter.getAssortment()) ? \"NULL\" : String.valueOf(filter.getAssortment().getId())\r\n                /* X [STRUCTURE_GROUP_ID] */, filter.getStructureGroupId()\r\n                /* X [STRUCTURE_TYPE] */, filter.getStructureType()\r\n                /* X [LABEL] */, filter.getLabel().replace(\"'\", \"''\"));\r\n        return body;\r\n    }\r\n\r\n    /**\r\n     * The insertFilterInFilterBase function takes a context and a map of filters as parameters.\r\n     * The function then iterates through the filter map, creating an identifier string and an ANDs string.\r\n     * The identifier string is used to create the label for the filterbase object that will be created in this function.\r\n     * The ANDs string is used to create the identifier for said filterbase object, which will also be saved in this function.\r\n     *\r\n     * @param Context        ctx Get the active assortment\r\n     * @param Map&lt;String  Store the filter settings\r\n     * @param Map&lt;String  Store the filter settings\r\n     * @param String&gt;&gt; filter Create the ands string\r\n     */\r\n    public void insertFilterInFilterBase(Context ctx, Map<String, Map<String, String>> filter) {\r\n        String ands = \"\";\r\n        String identifiers = \"\";\r\n        for (String key : filter.keySet()) {\r\n            Map<String, String> filterSetting = filter.get(key);\r\n            for (String settingKey : filterSetting.keySet()) {\r\n                ands += (!ands.isEmpty() ? \" AND \" : \"\")\r\n                        + filterByString(key, settingKey, filterSetting.get(settingKey));\r\n                identifiers += (!identifiers.isEmpty() ? \"; \" : \"\")\r\n                        + createIdentifierByString(ctx, key, settingKey, filterSetting.get(settingKey));\r\n            }\r\n        }\r\n        Filterbase base = new Filterbase();\r\n        base.setAssortment(ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT));\r\n        base.setIdentifier(ands);\r\n        base.setLabel(identifiers);\r\n        base.setDirection(Filterbase.REMOVE_INDIVIDUAL);\r\n        base.setType(FilterType.INDIVIDUAL);\r\n        base.setEntityIdentifier(base.getIdentifier().replace(\" \", \"_\") + DB_DELIMITER + base.getAssortment().getId());\r\n        filterBaseDefaultServices.save(base);\r\n    }\r\n\r\n    /**\r\n     * The filterByString function takes three parameters:\r\n     *\r\n     * @param String attribute Specify the attribute name of the table\r\n     * @param String type Determine the type of filter to be applied\r\n     * @param String value Get the value of the filter\r\n     * @return A string\r\n     */\r\n    private String filterByString(String attribute, String type, String value) {\r\n        String sResult = \"\";\r\n\r\n        if (value.contains(\"'\")) {\r\n            value = value.replace(\"'\", \"[']\");\r\n        }\r\n\r\n        if (value.contains(\"_\")) {\r\n            value = value.replace(\"_\", \"[_]\");\r\n        }\r\n\r\n        if (value.contains(\"%\")) {\r\n            value = value.replace(\"%\", \"[%]\");\r\n        }\r\n\r\n        if (value.contains(\"?\")) {\r\n            value = value.replace(\"?\", \"[?]\");\r\n        }\r\n\r\n        if (value.contains(\"$\")) {\r\n            value = value.replace(\"$\", \"[$]\");\r\n        }\r\n\r\n        if (value.contains(\"&\")) {\r\n            value = value.replace(\"&\", \"[&]\");\r\n        }\r\n\r\n        if (value.contains(\",\")) {\r\n            double dValue = Parse.toDouble(value.replace(\",\", \".\"));\r\n            if (dValue != 0.) {\r\n                value = String.valueOf(dValue);\r\n            }\r\n        }\r\n\r\n        switch (type) {\r\n            case \"=\": // gleich\r\n                sResult = attribute + \" = '\" + value.toUpperCase() + \"' \";\r\n                break;\r\n            case \"!=\": // ungleich\r\n                sResult = attribute + \" != '\" + value.toUpperCase() + \"' \";\r\n                break;\r\n\r\n            case \"<\": // kleiner\r\n                sResult = \"CAST(REPLACE(\" + attribute + \",',','.') AS FLOAT ) < \" + value + \" \";\r\n                break;\r\n\r\n            case \">\": // größer\r\n                sResult = \"CAST(REPLACE(\" + attribute + \",',','.') AS FLOAT ) > \" + value + \" \";\r\n                break;\r\n\r\n            case \"contains\": // beinhält\r\n                sResult = attribute + \" LIKE '%\" + value.toUpperCase() + \"%' \";\r\n                break;\r\n\r\n            case \"startWith\": // startet mit\r\n                sResult = attribute + \" LIKE '\" + value.toUpperCase() + \"%' \";\r\n                break;\r\n\r\n            case \"endWith\": // endet mit\r\n                sResult = attribute + \" LIKE '%\" + value.toUpperCase() + \"' \";\r\n                break;\r\n            case \"----\":\r\n            default:\r\n                sResult = \"\";\r\n                break;\r\n        }\r\n        return sResult;\r\n    }\r\n\r\n    /**    \r\n     * The createIdentifierByString function takes a context, an attribute, a type and a value as parameters.\r\n     * It then creates an identifier string based on the given parameters.\r\n     * The identifier is used to display the search criteria in the GUI.\r\n     *\r\n     *\r\n     * @param Context ctx Get the current locale and to translate the attribute name\r\n    private string createidentifierbydate(context ctx, string attribute, string type, date value) {\r\n    locale locale = new sessionutils(usersession)\r\n     * @param String attribute Get the translation of the attribute in a specific language\r\n     * @param String type Determine the type of search\r\n     * @param String value Get the value of the attribute\r\n     *\r\n     * @return A string like this:\r\n     *\r\n\r\n     */\r\n    private String createIdentifierByString(Context ctx, String attribute, String type, String value) {\r\n        String sResult = \"\";\r\n\r\n        Locale locale = new SessionUtils(userSession).getLocale(ctx);\r\n\r\n        String transAttribute = i18n.getTranslation(\r\n                TMS.SEARCH + (attribute.toLowerCase().replace(\" \", \"-\").replace(\"_\", \"-\")), locale, ctx);\r\n\r\n        switch (type) {\r\n            case EQUALS: // gleich\r\n                sResult = transAttribute + \" = \" + value.toUpperCase();\r\n                break;\r\n            case NOT_EQUALS: // ungleich\r\n                sResult = transAttribute + \" ≠ \" + value.toUpperCase();\r\n                break;\r\n\r\n            case LESSER_THAN: // kleiner\r\n                sResult = transAttribute + \" < \" + value;\r\n                break;\r\n\r\n            case GREATER_THAN: // größer\r\n                sResult = transAttribute + \" > \" + value;\r\n                break;\r\n\r\n            case CONTAINS: // beinhält\r\n                sResult = transAttribute + \" ...\" + value.toUpperCase() + \"...\";\r\n                break;\r\n\r\n            case START_WITH: // startet mit\r\n                sResult = transAttribute + \" \" + value.toUpperCase() + \"...\";\r\n                break;\r\n\r\n            case END_WITH: // endet mit\r\n                sResult = transAttribute + \" ...\" + value.toUpperCase();\r\n                break;\r\n            case UNUSED:\r\n            default:\r\n                sResult = \"\";\r\n                break;\r\n        }\r\n        return sResult;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseCustomRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseExportRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.KatalogVersion;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.Parse;\r\nimport com.hom.ebmw.utilities.TreeConverter;\r\nimport com.hom.ebmw.utilities.constans.ASTConst;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n@Repository\r\npublic class FilterBaseExportRepository {\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    /**\r\n     * The FilterBaseExportRepository function is used to filter the data in the BaseExport table.\r\n     *\r\n     * @param JdbcTemplate dbServices Access the database\r\n     * @return A filterbaseexportrepository object\r\n     */\r\n    public FilterBaseExportRepository(JdbcTemplate dbServices) {\r\n        this.dbServices = dbServices;\r\n    }\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the article table that is currently active in\r\n     * the user session. The function first gets a map from the user session, which contains all of\r\n     * our active tables. Then it gets a map from that map, which contains all of our main tables. It\r\n     * then returns this value as a string. This function is used to get an article table name for use\r\n     * in other functions such as addArticle and deleteArticle (see below).\r\n     *\r\n     * @param Context ctx Get the current user session\r\n     * @return The name of the table that is currently active in the user session\r\n     */\r\n    private String articleTableName(Context ctx) {\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        return tabSession.get(Table.MAIN);\r\n    }\r\n\r\n    /**\r\n     * The flatList function takes an array of integers and returns a string\r\n     * containing the values separated by commas.  For example, if the input is:\r\n     * { 1, 2, 3 } then this function will return &quot;3&quot;.  If there are no elements in\r\n     * the array then it will return an empty string.\r\n     *\r\n     * @param int... status Pass in an array of ints\r\n     * @return A string of comma-separated numbers\r\n     */\r\n    private String flatList(int... status) {\r\n        String stats = \"\";\r\n        for (int i = 0; i < status.length; i++) {\r\n            stats += (stats.isEmpty() ? \"\" : \",\") + status[i];\r\n        }\r\n        return stats;\r\n    }\r\n\r\n    /**\r\n     * The getArticleTable function returns the name of the article table in a given context.\r\n     *\r\n     * @param Context ctx Get the database name\r\n     *                private string getarticletable(context ctx) {\r\n     *                return &quot;`&quot; + dbhelper\r\n     * @param int...  status Pass a variable number of arguments to the function\r\n     * @return The name of the table to use for a given context\r\n     */\r\n    private String getArticleTable(Context ctx, int... status) {\r\n        String stats = \"\";\r\n        for (int i = 0; i < status.length; i++) {\r\n            stats += (stats.isEmpty() ? \"\" : \",\") + status[i];\r\n        }\r\n        return getArticleTable(ctx) + \" WHERE FOUND_ARTICLE_STATUS IN (\" + stats + \")\";\r\n    }\r\n\r\n    /**\r\n     * The getArticleTable function returns a string that is the name of the article table.\r\n     *\r\n     * @param Context ctx Get the name of the table\r\n     * @return A string\r\n     */\r\n    private String getArticleTable(Context ctx) {\r\n        return \"SELECT ARTICLE_REVISION_ID FROM \" + articleTableName(ctx);\r\n    }\r\n\r\n    /**\r\n     * The getStartDate function returns the start date of a given assortment.\r\n     *\r\n     * @param Context ctx Get the user session and to retrieve parameters from it\r\n     *                private localdate getenddate(context ctx) {\r\n     *                katalogversion version = null;\r\n     *                assortment assortment = ctx\r\n     * @return The start date of the current assortment\r\n     */\r\n    private LocalDate getStartDate(Context ctx) {\r\n        KatalogVersion version = null;\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        ObjectType fileType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n        if (Objects.isNull(fileType)) {\r\n            fileType = ObjectType.ECAT;\r\n        }\r\n        version = CompUtils.getKatalogVersion(ctx, fileType);\r\n\r\n        if (Objects.isNull(version)) {\r\n            version = CompUtils.getKatalogVersion(ctx, assortment);\r\n        }\r\n\r\n        return version.getValidFrom();\r\n    }\r\n\r\n    /**\r\n     * The getArticleType function is used to retrieve the article type from the database.\r\n     *\r\n     * @param Context    ctx Get the start date of the article\r\n     * @param String     tableName Determine the table name to be used in the query\r\n     * @param FilterType type Determine the type of filter that is being used\r\n     * @return The article type from the database\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleType(Context ctx, String tableName, FilterType type) {\r\n\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n        String startDate = getStartDate(ctx).toString();\r\n\r\n        String sqlValue = \"Select CASE \" + \"WHEN e.VALID_FROM = '\" + startDate + \"' THEN SUBSTRING(NEXT_\" + tableName\r\n                + \", 1,3) \" + \"WHEN e.VALID_FROM < '\" + startDate + \"' THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \"\r\n                + \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" + \"e.ARTICLE_REVISION_ID \"\r\n                + \"from AST_PIM_FILTER_ARTICLE_\" + tableName + \" e \" + \"INNER JOIN \" + articleTableName(ctx)\r\n                + \" f ON f.ARTICLE_REVISION_ID = e.ARTICLE_REVISION_ID AND f.FOUND_ARTICLE_STATUS = 0\";\r\n\r\n        result.addAll(dbServices.query(sqlValue, new FilterbaseRowMapper(type)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterial function returns a list of Filterbase objects that are assigned to the article.\r\n     *\r\n     * @param Context ctx Get the current context of the application\r\n     * @param int...  status Pass in a variable number of arguments\r\n     * @return A list of filterbase objects\r\n     */\r\n    public List<Filterbase> getArticleAssignedMaterial(Context ctx, int... status) {\r\n        return getArticleType(ctx, \"ASSIGNED_MATERIAL\", FilterType.ZUORDNUNG_MATERIAL);\r\n    }\r\n\r\n    /**\r\n     * The getArticleInfoType function returns a list of Filterbase objects, each containing the name and id of an article info type.\r\n     *\r\n     * @param Context ctx Get the application context\r\n     * @param int...  status Pass in a variable number of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    public List<Filterbase> getArticleInfoType(Context ctx, int... status) {\r\n        return getArticleType(ctx, \"INFO_TYPE\", FilterType.INFOTYPE);\r\n    }\r\n\r\n    /**\r\n     * The getArticleClass function returns a list of article classes.\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param int...  status Pass a variable number of arguments to the method\r\n     * @return A list of filterbase objects\r\n     */\r\n    public List<Filterbase> getArticleClass(Context ctx, int... status) {\r\n        return getArticleType(ctx, \"CLASS\", FilterType.ARTIKELKLASSE);\r\n    }\r\n\r\n    /**\r\n     * The getArticleBrand function is used to retrieve the brand of a given article.\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param int...  status Pass in a variable number of arguments\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleBrand(Context ctx, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT REPLACE(REPLACE(LABEL,'NO_BRAND',''),'- EMPTY -','') AS LABEL, ARTICLE_REVISION_ID \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_BRANDS \" + \"Where ARTICLE_REVISION_ID IN ( \"\r\n                + getArticleTable(ctx, status) + \" ) \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.BRANDS));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleGHSCode function is used to retrieve the GHS codes for a given article.\r\n     *\r\n     * @param Context ctx Get the current user's language\r\n     * @param int...  status Pass in a variable number of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleGHSCode(Context ctx, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT LABEL, ARTICLE_REVISION_ID \" + \"FROM AST_PIM_FILTER_ARTICLE_GHS_CODE \"\r\n                + \"Where ARTICLE_REVISION_ID IN ( \" + getArticleTable(ctx, status) + \" ) \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.GHS_CODES));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleTradingGroup function is used to retrieve the article trading group from the database.\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param int...  status Pass in a variable number of ints\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleTradingGroup(Context ctx, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT LABEL, ARTICLE_REVISION_ID \" + \"FROM AST_PIM_FILTER_ARTICLE_TRADING_GROUP \"\r\n                + \"Where ARTICLE_REVISION_ID IN ( \" + getArticleTable(ctx, status) + \" ) \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.GHS_CODES));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleConfig function is used to retrieve the article configuration from the database.\r\n     *\r\n     * @param Context ctx Get the locale and the user\r\n     * @param int...  status Pass in a variable number of int values to the method\r\n     * @return The following:\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleConfig(Context ctx, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT LABEL, ARTICLE_REVISION_ID \" + \"FROM AST_PIM_FILTER_ARTICLE_CONFIG \"\r\n                + \"Where ARTICLE_REVISION_ID IN ( \" + getArticleTable(ctx, status) + \" ) \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.CONFIG));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleIntraStat function is used to retrieve the Intrastat information for a given article.\r\n     *\r\n     * @param Context ctx Get the user's language\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIntraStat(Context ctx, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT LABEL, ARTICLE_REVISION_ID \" + \"FROM AST_PIM_FILTER_ARTICLE_INTRA_STAT \"\r\n                + \"Where ARTICLE_REVISION_ID IN ( \" + getArticleTable(ctx, status) + \" ) AND TERRITORY = 'DE' \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.INTRASTAT));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleNotFree function returns a list of Filterbase objects that are not free.\r\n     *\r\n     * @param Context ctx Get the correct database connection\r\n     * @param int...  status Pass an array of int values to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleNotFree(Context ctx, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT LABEL, ARTICLE_REVISION_ID \" + \"FROM AST_PIM_FILTER_ARTICLE_NOT_FREE \"\r\n                + \"Where ARTICLE_REVISION_ID IN ( \" + getArticleTable(ctx, status) + \" ) AND TERRITORY = 'DE' \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.NOTFREE));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureClassification function is used to retrieve the structure classification of an article.\r\n     *\r\n     * @param Context ctx Get the table name for the article\r\n     * @param Locale  locale Get the language of the user\r\n     * @param String  structureName Get the structure name from the database\r\n     * @param int...  status Get the status of the article\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructureClassification(Context ctx, Locale locale, String structureName, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        Language lang = getLanguage(ctx, locale);\r\n\r\n        String sqlParent = \" SELECT sl.LABEL, sl.STRUCTURE_GROUP_ID, ab.ARTICLE_REVISION_ID \"\r\n                + \"FROM AST_PIM_FILTER_STRUCTURE_CLASSIFICATION sc \"\r\n                + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG sl ON sl.STRUCTURE_GROUP_ID = sc.STRUCTURE_GROUP_ID \"\r\n                + \"AND sl.LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP artStr ON artStr.STRUCTURE_GROUP_ID = sc.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN \" + articleTableName(ctx) + \" ab ON ab.ARTICLE_REVISION_ID = artStr.ARTICLE_REVISION_ID \"\r\n                + \"WHERE STRUCTURE_NAME LIKE '\" + structureName + \"' \";\r\n\r\n        result.addAll(dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureParent function is used to retrieve the parent of a given structure.\r\n     *\r\n     * @param Context ctx Get the correct table name for the article\r\n     * @param Locale  locale Get the language of the article\r\n     * @param String  structureName Get the structure name from the database\r\n     * @param int...  status Pass in a variable number of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructureParent(Context ctx, Locale locale, String structureName, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        Language lang = getLanguage(ctx, locale);\r\n\r\n        String sqlParent = \"Select sl.LABEL, sl.STRUCTURE_GROUP_ID, ab.ARTICLE_REVISION_ID \"\r\n                + \"from AST_PIM_FILTER_STRUCTURE_LANG sl \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP_PARENT p ON p.PARENT_ID = sl.STRUCTURE_GROUP_ID \"\r\n                + \"AND sl.LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_CLASSIFICATION sc ON sc.STRUCTURE_GROUP_ID = p.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP artStr ON artStr.STRUCTURE_GROUP_ID = sc.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN \" + articleTableName(ctx) + \" ab ON ab.ARTICLE_REVISION_ID = artStr.ARTICLE_REVISION_ID \"\r\n                + \"WHERE STRUCTURE_NAME LIKE '\" + structureName + \"' \";\r\n\r\n        result.addAll(dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureTree function is used to retrieve the article structure tree for a given assortment.\r\n     * The function takes in three parameters: ctx, setting, and language.\r\n     *\r\n     * @param Context  ctx Get the name of the article table\r\n     * @param Setting  setting Determine the type of filter to be returned\r\n     * @param Language language Get the language for the filter structure\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructureTree(Context ctx, Setting setting, Language language) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        SettingType type = SettingType.valueOf(setting.getIdentifier());\r\n\r\n        String sqlStmt = \"Select ID, ENTITY_IDENTIFIER,a.IDENTIFIER,c.LABEL,TYPE, DIRECTION,a.STRUCTURE_GROUP_ID,STRUCTURE_TYPE, PARENT_ID, ARTICLE_REVISION_ID,SORT, ASSORTMENT_ID, FILTER_ID \"\r\n                + \"from AST_FILTERBASE a INNER JOIN \"\r\n                + \"(Select DISTINCT value as STRUCTURE_GROUP_ID, b.ARTICLE_REVISION_ID FROM ( \"\r\n                + \"Select IDENTIFIER, STRUCTURE_GROUP_ID, value from AST_FILTERBASE a \"\r\n                + \"OUTER APPLY string_split(IDENTIFIER,':') b \"\r\n                + \"WHERE ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND STRUCTURE_TYPE = '\" + type.getOptional() + \"' \"\r\n                + \") a INNER JOIN (\"\r\n                + \"Select a.ARTICLE_REVISION_ID,b.STRUCTURE_GROUP_ID from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"WHERE b.STRUCTURE_ID = \" + setting.getValue() + \" AND a.FOUND_ARTICLE_STATUS = 0\"\r\n                + \") b ON b.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID ) b ON a.STRUCTURE_GROUP_ID = b.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG c ON a.STRUCTURE_GROUP_ID = c.STRUCTURE_GROUP_ID \"\r\n                + \"WHERE ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND STRUCTURE_TYPE = '\" + type.getOptional() + \"' AND PARENT_ID IS NOT NULL AND a.[DELETE] = 0 AND c.LANGUAGE_ID = \" + language.getKey();\r\n        result.addAll(dbServices.query(sqlStmt, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructure function is used to retrieve the article structure from the database.\r\n     * The function takes in a context, locale, and structure name as parameters.\r\n     * It then uses these parameters to query the database for all of the articles that have a status\r\n     * matching one of those passed into it (the default is 0). It then returns this list of articles\r\n     * with their corresponding structures. This function also formats this list into a tree format so that it can be displayed on screen properly.\r\n     *\r\n     * @param Context ctx Determine the article table name\r\n     * @param Locale  locale Get the language of the user\r\n     * @param String  structureName Get the structure name\r\n     * @param int...  status Pass an array of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructure(Context ctx, Locale locale, String structureName, int... status) {\r\n        /*\r\n         * Select f.ID, f.IDENTIFIER, f.STRUCTURE_GROUP_ID, l.LABEL,\r\n         * s.ARTICLE_REVISION_ID FROM AST_FILTERBASE f INNER JOIN AST_FILTERBASE f2 ON\r\n         * f2.IDENTIFIER LIKE concat(f.IDENTIFIER,'%') INNER JOIN\r\n         * AST_PIM_FILTER_STRUCTURE_LANG l ON l.STRUCTURE_GROUP_ID =\r\n         * f.STRUCTURE_GROUP_ID AND l.LanguageID = 7 INNER JOIN\r\n         * AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP s ON s.STRUCTURE_GROUP_ID =\r\n         * f2.STRUCTURE_GROUP_ID INNER JOIN AST_ARTICLE_BASE_01 a ON\r\n         * s.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID AND FOUND_ARTICLE_STATUS IN (0)\r\n         * where l.LABEL IS NOT NULL AND f.ID LIKE '%#eshop'\r\n         *\r\n         */\r\n        List<Filterbase> sqlResult = new ArrayList<Filterbase>();\r\n        List<Filterbase> treeResult = new ArrayList<Filterbase>();\r\n        Language lang = getLanguage(ctx, locale);\r\n        String sqlFlatTree = \"Select f.ID, f.ENTITY_IDENTIFIER, f.IDENTIFIER, f.STRUCTURE_GROUP_ID, l.LABEL \"\r\n                + \"FROM AST_FILTERBASE f \" + \"INNER JOIN AST_FILTERBASE f2 \"\r\n                + \"ON f2.IDENTIFIER LIKE concat(f.IDENTIFIER,'%') AND f.[DELETE] = 0 \" + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG l \"\r\n                + \"ON l.STRUCTURE_GROUP_ID = f.STRUCTURE_GROUP_ID AND l.LanguageID = \" + lang.getKey() + \" \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP s \"\r\n                + \"ON s.STRUCTURE_GROUP_ID = f2.STRUCTURE_GROUP_ID \" + \"INNER JOIN \" + articleTableName(ctx) + \" a \"\r\n                + \"ON s.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID AND FOUND_ARTICLE_STATUS IN (\" + flatList(status)\r\n                + \") \" + \"WHERE l.LABEL IS NOT NULL AND f.STRUCTURE_TYPE LIKE '%\" + ASTConst.DB_DELIMITER\r\n                + structureName + \"' \" + \"ORDER BY l.LABEL\";\r\n\r\n        sqlResult.addAll(dbServices.query(sqlFlatTree, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        // Format List as Tree\r\n\r\n        List<Filterbase> buffer = sqlResult;\r\n\r\n        TreeConverter convert = new TreeConverter(buffer);\r\n\r\n        buffer = convert.convertToTree();\r\n\r\n//\t\tconvert.scanLevels(buffer);\r\n//\t\twhile (!convert.isEven()) {\r\n//\t\t\tbuffer = convert.addChildLevel(buffer);\r\n//\t\t\tconvert.scanLevels(buffer);\r\n//\t\t}\r\n        treeResult.addAll(buffer);\r\n\r\n        return treeResult;\r\n    }\r\n\r\n    /**    \r\n     * The getArticleIndividual function is used to retrieve all the individual articles from the database.\r\n     * \r\n     *\r\n     * @param int... status Pass in an array of ints\r\n     *\r\n     * @return A list of filterbase objects\r\n     *\r\n\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIndividual(int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        String sqlParent = \"SELECT ID, ENTITY_IDENTIFIER, IDENTIFIER, l.LABEL FROM AST_FILTERBASE WHERE [DELETE] = 0 AND TYPE = '\"\r\n                + FilterType.INDIVIDUAL + \"' \";\r\n\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.INDIVIDUAL));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleDescription function is used to retrieve the description of an article.\r\n     *\r\n     * @param Context ctx Determine the database to query\r\n     * @param Locale  locale Get the language from the database\r\n     * @param int...  status Pass in a variable number of ints to the function\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleDescription(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        Language lang = getLanguage(ctx, locale);\r\n\r\n        String sqlParent = \"Select a.ARTICLE_REVISION_ID, b.DESCRIPTION AS LABEL from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_DESCRIPTION b ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                + \"WHERE b.LANGUAGE_ID = \" + lang.getKey() + \" \";\r\n\r\n        result.addAll(dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.INDIVIDUAL)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleProductName function returns a list of Filterbase objects, which are used to populate the dropdown menu in the filter section of the PIM.\r\n     * The function takes in a Context object and Locale object as parameters. It also takes an array of integers called status, which is not used by this function.\r\n     * The getArticleProductName function first creates an empty ArrayList called result that will be populated with Filterbase objects later on in the code.\r\n     * Next, it calls another method named getLanguage to retrieve information about what language is currently being displayed on screen (English or French).\r\n     * This information is stored into\r\n     *\r\n     * @param Context ctx Get the name of the table\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass in a variable number of ints\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleProductName(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n\r\n        Language lang = getLanguage(ctx, locale);\r\n\r\n        String sqlParent = \"Select a.ARTICLE_REVISION_ID, b.PRODUCT_NAME AS LABEL from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_ARTICLE_PRODUCT_NAME b ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                + \"WHERE b.LANGUAGE_ID = \" + lang.getKey() + \" \";\r\n\r\n        result.addAll(dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.INDIVIDUAL)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findAllByAssortment function is used to find all Filterbase objects that are associated with a given Assortment object.\r\n     *\r\n     * @param Assortment assortment Get the id of the assortment\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> findAllByAssortment(Assortment assortment) {\r\n        String sqlSelect = \"Select ID, ENTITY_IDENTIFIER,LABEL,IDENTIFIER,DIRECTION from AST_FILTERBASE where [DELETE] = 0 AND ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" AND PARENT_ID IS NULL\";\r\n        return dbServices.query(sqlSelect, new FilterbaseRowMapper());\r\n    }\r\n\r\n\r\n    /**\r\n     * The getArticleIndividual function is used to get the individual articles that are in the assortment.\r\n     *\r\n     * @param Context ctx Get the name of the article table\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIndividual(Context ctx) {\r\n        List<Filterbase> result = new ArrayList<Filterbase>();\r\n        String sqlSelect = \"\";\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        sqlSelect = \"SELECT concat(IDENTIFIER,'¬',LABEL,'¬',ID,'¬',DIRECTION) AS LABEL FROM AST_FILTERBASE WHERE [DELETE] = 0 AND ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" AND TYPE = '\" + FilterType.INDIVIDUAL.name() + \"' AND PARENT_ID IS NULL \";\r\n\r\n        List<String> identifiers = dbServices.queryForList(sqlSelect, String.class);\r\n\r\n        sqlSelect = \"\"; // clear String\r\n\r\n        for (String string : identifiers) {\r\n            List<String> tokens = Arrays.asList(string.split(\"¬\"));\r\n\r\n            String identifier = tokens.get(0);\r\n            String label = tokens.get(1);\r\n            String id = tokens.get(2);\r\n            int direction = Parse.toInt(tokens.get(3));\r\n            if (!identifier.equals(label) && direction == Filterbase.REMOVE_INDIVIDUAL) {\r\n                sqlSelect += (!sqlSelect.isEmpty() ? \" UNION \" : \"\") + \"SELECT '\" + id.replace(\"'\", \"''\") + \"' AS ID, '\"\r\n                        + label + \"' AS LABEL, ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \" \" + \"WHERE \"\r\n                        + identifier + \" AND FOUND_ARTICLE_STATUS IN (\" + FilterStatus.DEFAULT.getId() + \",\"\r\n                        + FilterStatus.REMOVEBYFILTER.getId() + \") \";\r\n            } else {\r\n                sqlSelect += (!sqlSelect.isEmpty() ? \" UNION \" : \"\") + \"SELECT '\" + id.replace(\"'\", \"''\") + \"' AS ID, '\"\r\n                        + label + \"' AS LABEL, ARTICLE_REVISION_ID FROM \" + articleTableName(ctx) + \" a \"\r\n                        + \"INNER JOIN AST_FILTERBASE b ON a.ARTICLE_NR = b.IDENTIFIER AND b.[DELETE] = 0 AND PARENT_ID = '\" + id + \"' \"\r\n                        + \"WHERE TYPE = '\" + identifier + \"' AND FOUND_ARTICLE_STATUS IN (\"\r\n                        + FilterStatus.DEFAULT.getId() + \",\" + FilterStatus.REMOVEBYFILTER.getId() + \") \";\r\n            }\r\n        }\r\n        if (!identifiers.isEmpty()) {\r\n            result.addAll(dbServices.query(sqlSelect, new FilterbaseRowMapper(FilterType.INDIVIDUAL)));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**    \r\n     * The getLanguage function takes a Context and Locale as parameters.\r\n     * It returns the Language object that corresponds to the given locale.\r\n     * If no such language exists, it returns null.\r\n    \r\n     *\r\n     * @param Context ctx Get the enumerationservice\r\n     * @param Locale locale Get the language from the locale\r\n\r\n    ```\r\n\r\n\r\n    ## step 3: add a new field to the user profile page\r\n     *\r\n     * @return The language object of the current locale\r\n     *\r\n\r\n     */\r\n    private Language getLanguage(Context ctx, Locale locale) {\r\n        Language result = null;\r\n        List<Language> languages = ctx.getServices().getEnumerationService().getAllLanguages();\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(locale.toLanguageTag()))\r\n                .findFirst();\r\n        if (optLang.isPresent()) {\r\n            result = optLang.get();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private class FilterbaseRowMapper implements RowMapper<Filterbase> {\r\n\r\n        private String type = \"\";\r\n\r\n        public FilterbaseRowMapper(FilterType type) {\r\n            this.type = type.name();\r\n        }\r\n\r\n        public FilterbaseRowMapper() {\r\n        }\r\n\r\n        /**\r\n         * The mapRow function is called for each row in the ResultSet.\r\n         * The first parameter is the current row in the ResultSet, and\r\n         * the second parameter is a counter that starts at 0 and increases by 1 for each new row.\r\n         *\r\n         * @param ResultSet rs Access the data in the database\r\n         * @param int rowNum Keep track of the current row number\r\n         *\r\n         * @return A filterbase object, which is a subclass of base\r\n         *\r\n\r\n         */\r\n        @Override\r\n        public Filterbase mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            Filterbase base = new Filterbase();\r\n\r\n            try {\r\n                base.setId(rs.getInt(\"ID\"));\r\n            } catch (Exception e) {\r\n            }\r\n\r\n            try {\r\n                base.setEntityIdentifier(rs.getString(\"ENTITY_IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n            }\r\n\r\n            base.setLabel(rs.getString(\"LABEL\"));\r\n            try {\r\n                base.setIdentifier(rs.getString(\"IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                base.setIdentifier(rs.getString(\"LABEL\"));\r\n            }\r\n            base.setType(type);\r\n            try {\r\n                base.setStructureGroupId(rs.getInt(\"STRUCTURE_GROUP_ID\"));\r\n            } catch (Exception e) {\r\n            }\r\n            try {\r\n                base.setChildCount(rs.getInt(\"ARTICLE_REVISION_ID\"));\r\n            } catch (Exception e) {\r\n            }\r\n            try {\r\n                base.setDirection(rs.getInt(\"DIRECTION\"));\r\n            } catch (Exception e) {\r\n            }\r\n\r\n            return base;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseExportRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseGetRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.ipim.service.EnumerationService;\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.jpa.model.Setting;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.KatalogVersion;\r\nimport com.hom.ebmw.utilities.CompUtils;\r\nimport com.hom.ebmw.utilities.FilterUtils;\r\nimport com.hom.ebmw.utilities.TreeConverter;\r\nimport com.hom.ebmw.utilities.constans.Table;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport javax.transaction.Transactional;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\n@Repository\r\npublic class FilterBaseGetRepository {\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    private final EnumerationService enumServices;\r\n\r\n    /**\r\n     * The FilterBaseGetRepository function is a function that takes in the following parameters:\r\n     *\r\n     * @param JdbcTemplate       dbServices Access the database\r\n     * @param EnumerationService enumServices Get the enumeration values for the filter\r\n     * @return The filterbasegetrepository object\r\n     */\r\n    public FilterBaseGetRepository(JdbcTemplate dbServices, EnumerationService enumServices) {\r\n        this.dbServices = dbServices;\r\n        this.enumServices = enumServices;\r\n    }\r\n\r\n    /**\r\n     * The articleTableName function returns the name of the table that is currently active in the user session.\r\n     *\r\n     * @param Context ctx Get the current user session\r\n     * @return The name of the article table\r\n     * @docauthor Trelent\r\n     */\r\n    private String articleTableName(Context ctx) {\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        return tabSession.get(Table.MAIN);\r\n    }\r\n\r\n    /**\r\n     * The getArticleTableAsInnerJoin function is used to create a string that can be used in an SQL query.\r\n     * The function takes in the context of the application, two characters (a and b), and an array of integers (status).\r\n     * The function then creates a string called stats which will hold all of the status values from the status array.\r\n     * It does this by looping through each value in status, adding it to stats with commas separating them if necessary.\r\n     * After creating this string, getArticleTableAsInnerJoin returns another String that contains an INNER JOIN statement for use in SQL queries.\r\n     *\r\n     * @param Context ctx Get the name of the article table\r\n     * @param char    a Create a unique alias for the table name\r\n     * @param char    b Distinguish between the two tables\r\n     * @param int...  status Pass in an array of ints\r\n     * @return The following:\r\n     * @docauthor Trelent\r\n     */\r\n    private String getArticleTableAsInnerJoin(Context ctx, char a, char b, int... status) {\r\n        String stats = \"\";\r\n        for (int i = 0; i < status.length; i++) {\r\n            stats += (stats.isEmpty() ? \"\" : \",\") + status[i];\r\n        }\r\n        return \"INNER JOIN \" + articleTableName(ctx) + \" \" + a + \" ON \" + a + \".ARTICLE_REVISION_ID = \" + b\r\n                + \".ARTICLE_REVISION_ID AND \" + a + \".FOUND_ARTICLE_STATUS IN (\" + stats + \") \";\r\n    }\r\n\r\n    /**\r\n     * The getArticleTableImpexAsInnerJoin function is used to create a string that can be used in an impex file.\r\n     * The function takes three parameters: the context, two characters and an array of integers.\r\n     * The first parameter is the context which contains information about the current environment (e.g., live or test).\r\n     * The second and third parameters are characters that will be used as aliases for tables in the impex file.  These aliases must not conflict with any other table names or aliases in your impex file!  For example, if you have a table named &quot;Product&quot; then you cannot use 'P' as one of your alias characters\r\n     *\r\n     * @param Context ctx Get the katalog version\r\n     * @param final   char a Create a table alias\r\n     * @param final   char b Determine the table name\r\n     * @param int...  status Pass a variable number of arguments to the function\r\n     * @return A string that is used in the impex file\r\n     * @docauthor Trelent\r\n     */\r\n    private String getArticleTableImpexAsInnerJoin(Context ctx, final char a, final char b, int... status) {\r\n        KatalogVersion version = CompUtils.getKatalogVersion(ctx, ObjectType.IMPEX);\r\n\r\n        String stats = \"\";\r\n        for (int i = 0; i < status.length; i++) {\r\n            stats += (stats.isEmpty() ? \"\" : \",\") + status[i];\r\n        }\r\n        return \"INNER JOIN (Select ARTICLE_REVISION_ID, 0 BASICASSORTMENT FROM \" + articleTableName(ctx) +\r\n                \" WHERE FOUND_ARTICLE_STATUS IN (\" + stats + \") UNION SELECT ARTICLE_REVISION_ID, 1 FROM \" +\r\n                \"AST_PIM_FILTER_ARTICLE_ASSORTMENT WHERE ASSORTMENT_NAME = '\" + version.getPimAssortmentName() + \"' )\" +\r\n                a + \" ON \" + a + \".ARTICLE_REVISION_ID = \" + b + \".ARTICLE_REVISION_ID \";\r\n    }\r\n\r\n\r\n    /**\r\n     * The getArticleAssignedMaterialInBasicAssortment function returns a list of Filterbase objects.\r\n     * The function is called by the getFilterData function in the PimService class.\r\n     * The getArticleAssignedMaterialInBasicAssortment function calls the dbServices query method, which executes an SQL statement and returns a List of Filterbase objects.\r\n     *\r\n     * @param Context ctx Get the user's language\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Determine the status of the article\r\n     * @return The number of articles assigned to a material in the basic assortment\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleAssignedMaterialInBasicAssortment(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String stats = \"\";\r\n        for (int i = 0; i < status.length; i++) {\r\n            stats += (stats.isEmpty() ? \"\" : \",\") + status[i];\r\n        }\r\n\r\n        String sqlParent = \"Select 'BASIC_ASSORTMENT' AS LABEL, \" + \"COUNT(DISTINCT ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM \" + articleTableName(ctx)\r\n                + \" WHERE BASICASSORTMENT = 1 AND FOUND_ARTICLE_STATUS IN (\" + stats + \")\";\r\n\r\n        result.addAll(dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.ZUORDNUNG_MATERIAL)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleAssignedMaterialNotInBasicAssortment function is used to get the assigned material for articles that are not in the basic assortment.\r\n     *\r\n     * @param Context ctx Get the start date of the current season\r\n     * @param Locale  locale Get the correct language for the labels\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return The assigned material that is not in the basic assortment\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleAssignedMaterialNotInBasicAssortment(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        ObjectType oType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n\r\n        String startDate = CompUtils.getStartDate(ctx).toString();\r\n        String tableName = \"ASSIGNED_MATERIAL\";\r\n        FilterType type = FilterType.ZUORDNUNG_MATERIAL;\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT ARTICLE_REVISION_ID) AS COUNTER FROM (Select CASE \"\r\n                + \"WHEN a.VALID_FROM >= '\" + startDate + \"' THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \"\r\n                + \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" + \"a.ARTICLE_REVISION_ID from AST_PIM_FILTER_ARTICLE_\"\r\n                + tableName + \" a \" + getArticleTableAsInnerJoin(ctx, 'b', 'a', status)\r\n                + \" AND BASICASSORTMENT = 0 \" + (oType.name().startsWith(ObjectType.IMPEX.name()) ? \"AND b.CUSTOMER_NR = 'FILE' \" : \"\")\r\n                + \") temp GROUP BY LABEL \";\r\n\r\n\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(type));\r\n        FilterUtils.updateAssignedMaterialLabels(ctx, result);\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * The getArticleAssignedMaterial function returns a list of filters that are assigned to the article.\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param Locale  locale Determine the language of the labels\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filters that are assigned to the article\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleAssignedMaterial(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> filters = getArticleFilter(ctx, \"ASSIGNED_MATERIAL\", FilterType.ZUORDNUNG_MATERIAL, locale,\r\n                status);\r\n        FilterUtils.updateAssignedMaterialLabels(ctx, filters);\r\n        return filters;\r\n    }\r\n\r\n    /**\r\n     * The getArticleInfoType function returns a list of Filterbase objects that are associated with the INFO_TYPE filter.\r\n     *\r\n     * @param Context ctx Get the current context of the application\r\n     * @param Locale  locale Get the locale of the user\r\n     * @param int...  status Pass in a variable number of arguments to the function\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleInfoType(Context ctx, Locale locale, int... status) {\r\n        return getArticleFilter(ctx, \"INFO_TYPE\", FilterType.INFOTYPE, locale, status);\r\n    }\r\n\r\n    /**\r\n     * The getArticleClass function returns a list of Filterbase objects that are associated with the article class.\r\n     *\r\n     * @param Context ctx Define the context of the application\r\n     * @param Locale  locale Get the correct language for the filter\r\n     * @param int...  status Pass in a variable number of arguments\r\n     * @return The article class filter\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleClass(Context ctx, Locale locale, int... status) {\r\n        return getArticleFilter(ctx, \"CLASS\", FilterType.ARTIKELKLASSE, locale, status);\r\n    }\r\n\r\n    /**\r\n     * The getArticleFilter function is used to retrieve the article filters for a given table.\r\n     *\r\n     * @param Context    ctx Get the start date of the filter\r\n     * @param String     tableName Determine the table to query\r\n     * @param FilterType type Determine the type of filter\r\n     * @param Locale     locale Get the correct language for the filter\r\n     *                   private list&lt;filterbase&gt; getarticlefilter(context ctx, string tablename, filtertype type, locale locale) {\r\n     *                   list&lt;filterbase&gt; result = new arraylist&lt;&gt;();\r\n     *                   <p>\r\n     *                   string sqlparent = &quot;select label_&quot; + locale\r\n     * @param int...     status Pass in an array of ints\r\n     * @return A list of filters\r\n     * @docauthor Trelent\r\n     */\r\n    private List<Filterbase> getArticleFilter(Context ctx, String tableName, FilterType type, Locale locale,\r\n                                              int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        String startDate = CompUtils.getStartDate(ctx).toString();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT ARTICLE_REVISION_ID) AS COUNTER FROM (Select CASE \"\r\n                + \"WHEN a.VALID_FROM = '\" + startDate + \"' THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \"\r\n                + \"WHEN a.VALID_FROM < '\" + startDate + \"' THEN SUBSTRING(NEXT_\" + tableName + \", 1,3) \"\r\n                + \"ELSE CURRENT_\" + tableName + \" END AS LABEL, \" + \"a.ARTICLE_REVISION_ID from AST_PIM_FILTER_ARTICLE_\"\r\n                + tableName + \" a \" + getArticleTableAsInnerJoin(ctx, 'b', 'a', status)\r\n                + \") temp GROUP BY LABEL \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(type));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleBrand function is used to retrieve the brand names of all articles in the database.\r\n     *\r\n     * @param Context ctx Get the current context\r\n     * @param Locale  locale Determine the language of the article\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filterbase objects, which are the brands\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleBrand(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_BRANDS a \"\r\n                + getArticleTableAsInnerJoin(ctx, 'b', 'a', status) + \" GROUP BY LABEL ORDER BY LABEL\";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.BRANDS));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleS3Catalog function returns a list of Filterbase objects, which are used to populate the S3 Catalogs filter.\r\n     * The function takes in a Context object and Locale object as parameters. It also takes in an array of int values called status,\r\n     * which is used to determine whether or not the article should be included in the results (i.e., if it has been deleted).\r\n     * The function first creates an empty ArrayList called result that will hold all of our Filterbase objects once they have been created.\r\n     * Next, we create a String variable named sqlParent that holds our SQL query for retrieving data from\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass in a variable number of arguments\r\n     * @return A list of filterbase objects\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleS3Catalog(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_BRANDS a \"\r\n                + getArticleTableAsInnerJoin(ctx, 'b', 'a', status) + \"AND b.SPECIAL = 1 GROUP BY LABEL ORDER BY LABEL\";\r\n\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.S3_CATALOGS));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleGHSCode function is used to retrieve the GHS codes for a given article.\r\n     *\r\n     * @param Context ctx Get the user's language and country\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleGHSCode(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_GHS_CODE a \"\r\n                + getArticleTableAsInnerJoin(ctx, 'b', 'a', status) + \" GROUP BY LABEL \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.GHS_CODES));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleConfig function is used to retrieve the article configuration data from the database.\r\n     * The function takes in a Context object, a Locale object, and an array of integers as parameters.\r\n     * The function returns a list of Filterbase objects that contain all of the article configuration data retrieved from the database.\r\n     *\r\n     * @param Context ctx Get the correct database schema\r\n     * @param Locale  locale Determine the language of the labels\r\n     * @param int...  status Pass an array of ints to the function\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleConfig(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_CONFIG a \"\r\n                + getArticleTableAsInnerJoin(ctx, 'b', 'a', status) + \" GROUP BY LABEL \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.CONFIG));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleIntraStat function returns a list of Filterbase objects, which are used to populate the Intrastat filter.\r\n     * The function takes in a Context object and Locale object as parameters, and an array of ints called status.\r\n     * The function first creates an empty ArrayList called result that will be populated with Filterbase objects later on in the code.\r\n     * Next, it creates a String variable named sqlParent that contains the SQL query for retrieving data from AST_PIM_FILTER_ARTICLE_INTRA_STAT table\r\n     * (which is used to populate Intrastat filter) by joining it with AST_\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass an array of ints to the method\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIntraStat(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_INTRA_STAT a \"\r\n                + getArticleTableAsInnerJoin(ctx, 'b', 'a', status)\r\n                + \" AND a.TERRITORY = 'DE' GROUP BY LABEL \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.INTRASTAT));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleNotFree function returns a list of Filterbase objects.\r\n     * The function is called by the getFilterList function in the FilterService class.\r\n     * The getArticleNotFree function uses a SQL query to retrieve data from the AST_PIM_FILTER_ARTICLE_NOTFREE table,\r\n     * and then uses that data to create new Filterbase objects which are added to an ArrayList object named result.\r\n     *\r\n     * @param Context ctx Get the database connection\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Pass an array of ints to the method\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleNotFree(Context ctx, Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT LABEL, COUNT(DISTINCT a.ARTICLE_REVISION_ID) AS COUNTER \"\r\n                + \"FROM AST_PIM_FILTER_ARTICLE_NOT_FREE a \"\r\n                + getArticleTableAsInnerJoin(ctx, 'b', 'a', status)\r\n                + \" AND a.TERRITORY = 'DE' GROUP BY LABEL \";\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.NOTFREE));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureClassification function is used to get the structure classification of an article.\r\n     *\r\n     * @param Context ctx Get the article table name\r\n     * @param String  structureName Get the structure name from the database\r\n     * @param Locale  locale Get the language of the user\r\n     * @param int...  status Get the status of an article\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleStructureClassification(Context ctx, String structureName, Locale locale,\r\n                                                              int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        Language lang = CompUtils.getUserLanguage(ctx);\r\n\r\n        String sqlParent = \" Select CONCAT('(',b.IDENTIFIER,') ',b.LABEL) AS LABEL, a.STRUCTURE_GROUP_ID, COUNT(c.ARTICLE_REVISION_ID) AS COUNTER, a.STRUCTURE_NAME as STRUCTURE_TYPE from AST_PIM_FILTER_STRUCTURE_CLASSIFICATION a \"\r\n                + \" INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG b ON b.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID\"\r\n                + \" INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP c ON c.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID AND c.STRUCTURE_ID = a.STRUCTURE_ID\"\r\n                + \" INNER JOIN \" + articleTableName(ctx) + \" d ON d.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID AND d.FOUND_ARTICLE_STATUS = 0\"\r\n                + \" WHERE STRUCTURE_NAME = '\" + structureName + \"' AND LANGUAGE_ID = \" + lang.getKey() + \" \"\r\n                + \" GROUP BY b.LABEL, b.IDENTIFIER, a.STRUCTURE_GROUP_ID, a.STRUCTURE_NAME\";\r\n\r\n        result.addAll(dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The countArticle function is used to count the number of articles that are associated with a given filterbase.\r\n     *\r\n     * @param Context    ctx Get the correct table name for the article\r\n     * @param Filterbase item Get the identifier of the filterbase item\r\n     * @return The number of articles that are assigned to the assortment\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public int countArticle(Context ctx, Filterbase item) {\r\n        String sqlStatement = \"Select COUNT(DISTINCT c.ARTICLE_REVISION_ID) from AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP c \"\r\n                + \"INNER JOIN \" + articleTableName(ctx) + \" d ON d.ARTICLE_REVISION_ID = c.ARTICLE_REVISION_ID AND d.FOUND_ARTICLE_STATUS = 0 \"\r\n                + \"INNER JOIN AST_FILTERBASE e ON e.STRUCTURE_GROUP_ID = c.STRUCTURE_GROUP_ID AND e.[DELETE] = 0 AND e.ASSORTMENT_ID IS NULL AND e.FILTER_ID IS NULL \"\r\n                + \"WHERE e.IDENTIFIER LIKE '\" + item.getIdentifier() + \"%'\";\r\n\r\n        return dbServices.queryForObject(sqlStatement, Integer.class);\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureDBRoot function is used to retrieve the root nodes of a structure from the database.\r\n     *\r\n     * @param Context ctx Get the current user's id\r\n     * @param String  structureName Determine the structure type in the database\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    private List<Filterbase> getArticleStructureDBRoot(Context ctx, String structureName) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlStmt = \"SELECT ID, ENTITY_IDENTIFIER, IDENTIFIER, LABEL, TYPE, STRUCTURE_GROUP_ID, STRUCTURE_TYPE, PARENT_ID, SORT \"\r\n                + \"FROM AST_FILTERBASE \"\r\n                + \"WHERE [DELETE] = 0 AND STRUCTURE_TYPE = '\" + structureName + \"' AND ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND PARENT_ID IS NULL \";\r\n        result.addAll(dbServices.query(sqlStmt, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureDBRoot function is used to retrieve the root of a structure from the database.\r\n     *\r\n     * @param Context ctx Get the assortment id\r\n     * @param Setting setting Determine the type of structure to be returned\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    private List<Filterbase> getArticleStructureDBRoot(Context ctx, Setting setting) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        SettingType type = SettingType.valueOf(setting.getIdentifier());\r\n        String sqlStmt = \"SELECT ID, ENTITY_IDENTIFIER, IDENTIFIER, LABEL, TYPE, STRUCTURE_GROUP_ID, STRUCTURE_TYPE, PARENT_ID, SORT \"\r\n                + \"FROM AST_FILTERBASE \"\r\n                + \"WHERE [DELETE] = 0 AND STRUCTURE_TYPE = '\" + type.getOptional() + \"' AND ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND PARENT_ID IS NULL \";\r\n        result.addAll(dbServices.query(sqlStmt, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getArticleStructureDBNode function is used to retrieve the article structure from the database.\r\n     *\r\n     * @param Context  ctx Get the language of the user\r\n     * @param Setting  setting Determine the type of filter\r\n     * @param Language language Get the language id\r\n     * @param int      parentID Determine which parentid to look for in the database\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    private List<Filterbase> getArticleStructureDBNode(Context ctx, Setting setting, Language language, int parentID) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        SettingType type = SettingType.valueOf(setting.getIdentifier());\r\n        String sqlStmt = \"SELECT DISTINCT ID, ENTITY_IDENTIFIER, a.IDENTIFIER, b.LABEL, TYPE, a.STRUCTURE_GROUP_ID, STRUCTURE_TYPE, PARENT_ID, SORT \"\r\n                + \"FROM AST_FILTERBASE a INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG b ON a.STRUCTURE_GROUP_ID = b.STRUCTURE_GROUP_ID \"\r\n                + \"WHERE a.[DELETE] = 0 AND STRUCTURE_TYPE = '\" + type.getOptional() + \"' AND ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND PARENT_ID =\" + parentID + \" AND LANGUAGE_ID = \" + language.getKey();\r\n        result.addAll(dbServices.query(sqlStmt, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getStructureTree function is used to retrieve the structure tree for a given setting.\r\n     * The function takes in a context, setting and language as parameters. It then creates an empty list of Filterbase objects called result.\r\n     * It then gets the SettingType from the identifier of the given setting and stores it in type variable.\r\n     * Then it creates a sqlStmt string which contains all SQL code needed to get all data required for creating Filterbase objects from database tables AST_FILTERBASE, AST_PIM_FILTER_ARTICLE_STRUCTUREGROUP and AST_PIM-FILTER-STRUCTURELANG based\r\n     *\r\n     * @param Context  ctx Get the correct table name for the article\r\n     * @param Setting  setting Get the structure id from the setting table\r\n     * @param Language language Get the language of the filter\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    private List<Filterbase> getStructureTree(Context ctx, Setting setting, Language language) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        SettingType type = SettingType.valueOf(setting.getIdentifier());\r\n\r\n        String sqlStmt = \"Select ID, ENTITY_IDENTIFIER,a.IDENTIFIER,c.LABEL,TYPE, DIRECTION,a.STRUCTURE_GROUP_ID,STRUCTURE_TYPE, PARENT_ID, Counts AS COUNTER,SORT, ASSORTMENT_ID, FILTER_ID \"\r\n                + \"from AST_FILTERBASE a INNER JOIN \"\r\n                + \"(Select value as STRUCTURE_GROUP_ID, Count(b.ID) as Counts FROM ( \"\r\n                + \"Select IDENTIFIER, STRUCTURE_GROUP_ID, value from AST_FILTERBASE a \"\r\n                + \"OUTER APPLY string_split(IDENTIFIER,':') b \"\r\n                + \"WHERE ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND STRUCTURE_TYPE = '\" + type.getOptional() + \"' \"\r\n                + \") a INNER JOIN (\"\r\n                + \"Select a.ID,b.STRUCTURE_GROUP_ID from \" + articleTableName(ctx) + \" a \"\r\n                + \"INNER JOIN AST_PIM_FILTER_ARTICLE_STRUCTURE_GROUP b ON a.ARTICLE_REVISION_ID = b.ARTICLE_REVISION_ID \"\r\n                + \"WHERE b.STRUCTURE_ID = \" + setting.getValue() + \" AND a.FOUND_ARTICLE_STATUS = 0\"\r\n                + \") b ON b.STRUCTURE_GROUP_ID = a.STRUCTURE_GROUP_ID \"\r\n                + \"Group BY value) b ON a.STRUCTURE_GROUP_ID = b.STRUCTURE_GROUP_ID \"\r\n                + \"INNER JOIN AST_PIM_FILTER_STRUCTURE_LANG c ON a.STRUCTURE_GROUP_ID = c.STRUCTURE_GROUP_ID \"\r\n                + \"WHERE ASSORTMENT_ID IS NULL AND FILTER_ID IS NULL AND STRUCTURE_TYPE = '\" + type.getOptional() + \"' AND PARENT_ID IS NOT NULL AND a.[DELETE] = 0 AND c.LANGUAGE_ID = \" + language.getKey();\r\n        result.addAll(dbServices.query(sqlStmt, new FilterbaseRowMapper(FilterType.STRUCTURE)));\r\n\r\n        TreeConverter convert = new TreeConverter(result);\r\n\r\n        result = convert.convertToTree();\r\n\r\n        return result;\r\n    }\r\n\r\n\r\n    /**\r\n     * The getArticleStructure function is used to retrieve the structure of a given article.\r\n     * The function takes in a context, setting, locale and status as parameters.\r\n     * It returns an array list of Filterbase objects that represent the structure tree for the article.\r\n     *\r\n     * @param Context ctx Access the services of the application\r\n     * @param Setting setting Get the structure tree from a specific setting\r\n     * @param Locale  locale Determine the language of the article structure\r\n     * @param int...  status Determine which status of articles should be returned\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    public List<Filterbase> getArticleStructure(Context ctx, Setting setting, Locale locale, int... status) {\r\n\r\n        List<Filterbase> buffer = new ArrayList<>();\r\n        List<Language> languages = ctx.getServices().getEnumerationService().getAllLanguages();\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(locale.toLanguageTag()))\r\n                .findFirst();\r\n\r\n        if (optLang.isPresent()) {\r\n            Language lang = optLang.get();\r\n            buffer = getStructureTree(ctx, setting, lang);\r\n            buffer.removeIf(item -> item.getLabel().isEmpty());\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * The getArticleIndividual function is used to retrieve a list of all the individual articles in the database.\r\n     *\r\n     * @param Locale locale Get the language of the user\r\n     * @param int... status Pass in a variable number of arguments\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIndividual(Locale locale, int... status) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n\r\n        String sqlParent = \"SELECT ID, ENTITY_IDENTIFIER, IDENTIFIER, l.LABEL FROM AST_FILTERBASE WHERE [DELETE] = 0 AND TYPE = '\"\r\n                + FilterType.INDIVIDUAL + \"' \";\r\n\r\n        result = dbServices.query(sqlParent, new FilterbaseRowMapper(FilterType.INDIVIDUAL));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findAllByAssortment function is used to find all Filterbase objects that are associated with a given Assortment object.\r\n     *\r\n     * @param Assortment assortment Find the filters for a specific assortment\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> findAllByAssortment(Assortment assortment) {\r\n        String sqlSelect = \"Select ID, ENTITY_IDENTIFIER,LABEL,IDENTIFIER, DIRECTION, TYPE from AST_FILTERBASE where [DELETE] = 0 AND ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" AND PARENT_ID IS NULL\";\r\n        return dbServices.query(sqlSelect, new FilterbaseRowMapper());\r\n    }\r\n\r\n    /*\r\n     * See also FilterbaseUpdateRepository.articleIndividual\r\n     */\r\n\r\n    /**\r\n     * The getArticleIndividual function is used to retrieve the individual filters for a given assortment.\r\n     * The function first creates an empty list of Filterbase objects, and then initializes a String variable called sqlSelect.\r\n     * It then retrieves the active assortment from the user session, and uses it to create an SQL query that selects all\r\n     * filterbases with type INDIVIDUAL (individual filters) that have no parent ID (i.e., they are not subfilters).  This query returns a list of Strings containing information about each filterbase in this format: &quot;IDENTIFIER¬LABEL¬ID¬\r\n     *\r\n     * @param Context ctx Get the user session and to get the locale\r\n     * @return A list of filterbase objects\r\n     * @docauthor Trelent\r\n     */\r\n    @Transactional\r\n    public List<Filterbase> getArticleIndividual(Context ctx) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        String sqlSelect = \"\";\r\n\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        sqlSelect = \"SELECT concat(IDENTIFIER,'¬',LABEL,'¬',ID,'¬',TYPE,'¬',DIRECTION) AS LABEL FROM AST_FILTERBASE WHERE [DELETE] = 0 AND ASSORTMENT_ID = \"\r\n                + assortment.getId() + \" AND TYPE = '\" + FilterType.INDIVIDUAL.name() + \"' AND PARENT_ID IS NULL \";\r\n\r\n        List<String> identifiers = dbServices.queryForList(sqlSelect, String.class);\r\n\r\n        sqlSelect = \"\"; // clear String\r\n\r\n        List<Language> languages = enumServices.getAllLanguages();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(locale.toLanguageTag()))\r\n                .findFirst();\r\n        if (optLang.isPresent()) {\r\n            Language lang = optLang.get();\r\n            for (String string : identifiers) {\r\n                List<String> tokens = Arrays.asList(string.split(\"¬\"));\r\n\r\n                String identifier = tokens.get(0);\r\n                String label = tokens.get(1);\r\n                String id = tokens.get(2);\r\n                String type = tokens.get(3);\r\n                String selectTemp = \"\";\r\n                if (identifier.contains(\"PRODUCT_NAME\")) {\r\n                    selectTemp = \"SELECT \" + id + \" AS ID, '\" + label\r\n                            + \"' AS LABEL, COUNT(a.ARTICLE_REVISION_ID) AS COUNTER FROM \"\r\n                            + articleTableName(ctx) + \" a \"\r\n                            + \"INNER JOIN AST_PIM_ARTICLE_PRODUCT_NAME b ON b.ARTICLE_REVISION_ID = a.ARTICLE_REVISION_ID \"\r\n                            + \"WHERE b.LANGUAGE_ID = \" + lang.getKey() + \" AND \"\r\n                            + identifier.replace(\"PRODUCT_NAME\", \"UPPER(PRODUCT_NAME)\")\r\n                            + \" AND a.FOUND_ARTICLE_STATUS IN (\" + FilterStatus.DEFAULT.getId() + \",\"\r\n                            + FilterStatus.REMOVEBYFILTER.getId() + \") \";\r\n                } else if (!identifier.equals(type)) {\r\n                    selectTemp = \"SELECT \" + id + \" AS ID, '\" + label\r\n                            + \"' AS LABEL, COUNT(ARTICLE_REVISION_ID) AS COUNTER FROM \"\r\n                            + articleTableName(ctx) + \" \" + \"WHERE \" + identifier\r\n                            + \" AND FOUND_ARTICLE_STATUS IN (\" + FilterStatus.DEFAULT.getId() + \",\"\r\n                            + FilterStatus.REMOVEBYFILTER.getId() + \") \";\r\n                } else {\r\n                    selectTemp = \"SELECT \" + id + \" AS ID, '\" + label\r\n                            + \"' AS LABEL, COUNT(ARTICLE_REVISION_ID) AS COUNTER FROM \"\r\n                            + articleTableName(ctx) + \" a \"\r\n                            + \"INNER JOIN AST_FILTERBASE b ON a.ARTICLE_NR = b.IDENTIFIER AND PARENT_ID = \" + id + \" \"\r\n                            + \"WHERE b.[DELETE] = 0 AND FOUND_ARTICLE_STATUS IN (\" + FilterStatus.DEFAULT.getId() + \",\"\r\n                            + FilterStatus.REMOVEBYFILTER.getId() + \") \";\r\n                }\r\n                sqlSelect += (!sqlSelect.isEmpty() ? \" UNION \" : \"\") + selectTemp;\r\n\r\n            }\r\n            if (!identifiers.isEmpty()) {\r\n                result.addAll(dbServices.query(sqlSelect, new FilterbaseRowMapper(FilterType.INDIVIDUAL)));\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private class FilterbaseRowMapper implements RowMapper<Filterbase> {\r\n\r\n        private String type = \"\";\r\n\r\n        public FilterbaseRowMapper(FilterType type) {\r\n            this.type = type.name();\r\n        }\r\n\r\n        public FilterbaseRowMapper() {\r\n        }\r\n\r\n\r\n        public Filterbase mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            Filterbase base = new Filterbase();\r\n\r\n            try {\r\n                base.setId(rs.getInt(\"ID\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            try {\r\n                base.setEntityIdentifier(rs.getString(\"ENTITY_IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            base.setLabel(rs.getString(\"LABEL\"));\r\n            try {\r\n                base.setIdentifier(rs.getString(\"IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                base.setIdentifier(rs.getString(\"LABEL\"));\r\n            }\r\n            base.setType(type);\r\n            try {\r\n                base.setStructureGroupId(rs.getInt(\"STRUCTURE_GROUP_ID\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setChildCount(rs.getInt(\"COUNTER\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setStructureType(rs.getString(\"STRUCTURE_TYPE\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setDirection(rs.getInt(\"DIRECTION\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setSort(rs.getInt(\"SORT\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setType(rs.getString(\"TYPE\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            return base;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseGetRepository.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseProofRepository.java =====\n```\npackage com.hom.ebmw.jpa.dao.impl;\r\n\r\nimport com.hom.ebmw.jpa.model.Assortment;\r\nimport com.hom.ebmw.jpa.model.Filterbase;\r\nimport com.hom.ebmw.utilities.enums.FilterType;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.jdbc.core.RowMapper;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Slf4j\r\n@Repository\r\npublic class FilterBaseProofRepository {\r\n\r\n    private final JdbcTemplate dbServices;\r\n\r\n    /**\r\n     * The FilterBaseProofRepository function is a function that takes in the JdbcTemplate dbServices and returns\r\n     * an ArrayList of Proofs. The function uses the JdbcTemplate to query for all proofs from the database, then\r\n     * iterates through each proof and adds it to an ArrayList if its baseProofId is equal to 0. This means that only\r\n     * proofs with no parent are added, as they are considered &quot;base&quot; proofs. The function then returns this list of\r\n     * baseProofs at the end of its execution.\r\n     *\r\n     * @param JdbcTemplate dbServices Access the database\r\n     * @return The filterbaseproofrepository object\r\n     */\r\n    public FilterBaseProofRepository(JdbcTemplate dbServices) {\r\n        this.dbServices = dbServices;\r\n    }\r\n\r\n    /**\r\n     * The getRootFilterStructureByAssortment function takes in an assortment and returns the root filter structure\r\n     * of that assortment. The function does this by querying the AST_FILTERBASE table for all rows with a type of\r\n     * 'STRUCTURE' and an IDENTIFIER containing a colon (':'). It then selects only those rows where ASSORTMENT_ID is equal to\r\n     * the id of the given assortment. Finally, it returns only one row from this list, which should be unique because we are selecting on both ASSORTMENT_ID and IDENTIFIER. If no such row exists, then Optional.empty() is returned instead.\r\n     *\r\n     * @param Assortment assortment Get the assortment id from the assortment object\r\n     * @return A filterbase object\r\n     */\r\n    public Optional<Filterbase> getRootFilterStructureByAssortment(Assortment assortment) {\r\n        Optional<Filterbase> result = Optional.empty();\r\n        String sb = \"Select Distinct Substring(IDENTIFIER,0,charindex(':',IDENTIFIER)) as IDENTIFIER, 'STRUCTURE' AS TYPE, Substring(IDENTIFIER,0,charindex(':',IDENTIFIER)) as STRUCTURE_GROUP_ID \" +\r\n                \"FROM AST_FILTERBASE WHERE ASSORTMENT_ID = ? AND TYPE = 'STRUCTURE' AND IDENTIFIER LIKE '%:%'\";\r\n\r\n        List<Filterbase> list = dbServices.query(sb, new FilterbaseRowMapper(FilterType.STRUCTURE),\r\n                assortment.getId());\r\n        if (!list.isEmpty()) {\r\n            result = Optional.of(list.get(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getRootFilterStructureByName function is used to retrieve the root filter structure of a given type.\r\n     *\r\n     * @param String structureType Query the database for a root filter structure\r\n     * @return The root filter structure,\r\n     */\r\n    public Optional<Filterbase> getRootFilterStructureByName(String structureType) {\r\n        Optional<Filterbase> result = Optional.empty();\r\n        String sb = \"Select IDENTIFIER, TYPE, STRUCTURE_GROUP_ID \" +\r\n                \"FROM AST_FILTERBASE WHERE LOWER(STRUCTURE_TYPE) = ? and [DELETE] = 0 AND LABEL = ''\";\r\n\r\n        List<Filterbase> list = dbServices.query(sb, new FilterbaseRowMapper(FilterType.STRUCTURE),\r\n                structureType);\r\n        if (!list.isEmpty()) {\r\n            result = Optional.of(list.get(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The findAllNotInFilterStructure function takes an assortment as a parameter and returns a list of all filters that are not in the filter structure.\r\n     * The function first gets the root filter of the given assortment's filter structure, if it exists. If it does exist, then we call appendStructureTreeDifference on this root node to get all filters that are not in this tree.\r\n     *\r\n     * @param Assortment assortment Get the root filter structure\r\n     * @return A list of all filterbase objects that are not in the filter structure\r\n     */\r\n    public List<Filterbase> findAllNotInFilterStructure(Assortment assortment) {\r\n        List<Filterbase> result = new ArrayList<>();\r\n        Optional<Filterbase> optFilterRoot = getRootFilterStructureByAssortment(assortment);\r\n        optFilterRoot.ifPresent(item -> appendStructureTreeDifference(item, assortment, result));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The appendStructureTreeDifference function is used to find the differences between a structure tree and an assortment.\r\n     * It does this by comparing the structure tree's identifier with that of the assortment, and then appending any differences\r\n     * to a list of Filterbase objects. This function is called in getStructureTreeDifference().\r\n     *\r\n     * @param Filterbase             item Get the structure type of the item\r\n     * @param Assortment             assortment Get the assortment id\r\n     * @param List&lt;Filterbase&gt; result Return the result of the query\r\n     */\r\n    private void appendStructureTreeDifference(Filterbase item, Assortment assortment, List<Filterbase> result) {\r\n\r\n        String sb = \"Select DISTINCT a.LABEL, a.TYPE,a.IDENTIFIER, a.STRUCTURE_GROUP_ID FROM AST_FILTERBASE a INNER JOIN \" +\r\n                //Append Assortment ID\r\n                \"(Select IDENTIFIER, TYPE, STRUCTURE_GROUP_ID From AST_FILTERBASE WHERE ASSORTMENT_ID = ? AND TYPE = 'STRUCTURE'\" +\r\n                \" EXCEPT \" +\r\n                //Append Structure ID\r\n                \"SELECT IDENTIFIER, TYPE, STRUCTURE_GROUP_ID FROM AST_FILTERBASE WHERE IDENTIFIER LIKE Concat(?,'%') AND STRUCTURE_TYPE <> '' AND [DELETE] = 0 AND LABEL <> '' AND TYPE = 'STRUCTURE') temp \" +\r\n                \"ON a.IDENTIFIER = temp.IDENTIFIER\";\r\n        result.addAll(dbServices.query(sb, new FilterbaseRowMapper(FilterType.STRUCTURE), assortment.getId(), item.getIdentifier()));\r\n    }\r\n\r\n    private class FilterbaseRowMapper implements RowMapper<Filterbase> {\r\n\r\n        private String type = \"\";\r\n\r\n        public FilterbaseRowMapper(FilterType type) {\r\n            this.type = type.name();\r\n        }\r\n\r\n        public Filterbase mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            Filterbase base = new Filterbase();\r\n\r\n            try {\r\n                base.setId(rs.getInt(\"ID\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            try {\r\n                base.setEntityIdentifier(rs.getString(\"ENTITY_IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            try {\r\n                base.setLabel(rs.getString(\"LABEL\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setIdentifier(rs.getString(\"IDENTIFIER\"));\r\n            } catch (Exception e) {\r\n                base.setIdentifier(rs.getString(\"LABEL\"));\r\n            }\r\n            base.setType(type);\r\n            try {\r\n                base.setStructureGroupId(rs.getInt(\"STRUCTURE_GROUP_ID\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setChildCount(rs.getInt(\"COUNTER\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setStructureType(rs.getString(\"STRUCTURE_TYPE\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setDirection(rs.getInt(\"DIRECTION\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setSort(rs.getInt(\"SORT\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n            try {\r\n                base.setType(rs.getString(\"TYPE\"));\r\n            } catch (Exception e) {\r\n                log.debug(e.getMessage(), e);\r\n            }\r\n\r\n            return base;\r\n        }\r\n\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\jpa\\dao\\impl\\FilterBaseProofRepository.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-SbVduYyXETMLgxjHNWQ0iuLO9ww9KtY6",
    "created" : 1762170768,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"multiple (FilterBaseCustomRepository.java, FilterBaseExportRepository.java, FilterBaseGetRepository.java, FilterBaseProofRepository.java)\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"SQL‑Injection risk through string concatenated queries\",\n      \"justification\": \"Many repository methods build SQL statements by directly appending parameters (e.g., filter identifiers, structure names, user‑provided strings) without using prepared statements or proper escaping, allowing malicious input to break the query or execute arbitrary SQL.\",\n      \"action\": \"Refactor all dbServices.execute / query calls to use parameter placeholders (\\\"?\\\") and pass values via JdbcTemplate arguments; validate/sanitize any free‑form strings before inclusion; add unit tests that verify queries reject malicious payloads.\",\n      \"source\": \"FilterBaseCustomRepository.remove(Filterbase), removeByTypeAndAssortment, removeWhereStructureTypeLike, insertArticleInFilterBase, FilterBaseExportRepository.getArticleStructure, getArticleIndividual (UNION builder), FilterBaseGetRepository.getArticleFilter, etc.\",\n      \"component\": \"data‑access\",\n      \"impact_scope\": \"sicherheitskritisch, produktiv relevant\",\n      \"relations\": null,\n      \"evidence\": \"String sqlExecute = \\\"UPDATE AST_FILTERBASE SET [DELETE] = 1 WHERE TYPE = '\\\" + type.name() + \\\"' AND ASSORTMENT_ID = \\\" + assortment.getId();\"\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential NullPointerExceptions due to unchecked context/session values\",\n      \"justification\": \"Methods assume that ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT) or ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE) are always present; missing entries will cause NPE, crashing the service in production.\",\n      \"action\": \"Add null‑checks and throw a meaningful IllegalArgumentException when required session attributes are absent; write tests covering missing session data scenarios.\",\n      \"source\": \"FilterBaseExportRepository.articleTableName, getLanguage, FilterBaseGetRepository.articleTableName, many methods using ctx.getUserSession()\",\n      \"component\": \"session‑management\",\n      \"impact_scope\": \"prod‑relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Empty catch blocks when reading ResultSet fields\",\n      \"justification\": \"Swallowing SQLException hides data‑access problems, makes debugging hard, and may return partially filled objects, leading to subtle bugs.\",\n      \"action\": \"Log the exception with stack trace at WARN/ERROR level and optionally rethrow a custom DataAccessException; ensure unit tests verify proper handling of malformed rows.\",\n      \"source\": \"FilterbaseRowMapper.mapRow implementations in all repositories\",\n      \"component\": \"data‑mapping\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Inefficient bulk inserts using string concatenation\",\n      \"justification\": \"Methods like insertFilterBaseIn build a single massive INSERT statement via string concatenation; this can exceed max query length, cause out‑of‑memory errors, and prevents JDBC batch optimisation.\",\n      \"action\": \"Replace manual string building with JdbcTemplate.batchUpdate or NamedParameterJdbcTemplate batch inserts; limit batch size (e.g., 500 rows) and test performance under large loads.\",\n      \"source\": \"FilterBaseCustomRepository.insertFilterBaseIn(List<ArticleBase>, Filterbase), insertFilterBaseIn(List<Filterbase>)\",\n      \"component\": \"performance\",\n      \"impact_scope\": \"performance‑kritisch\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"Unescaped single quotes in dynamically built identifiers\",\n      \"justification\": \"Only some values are escaped (replace(\\\"'\\\", \\\"''\\\")); others like article.getArticleNr() or filter.getIdentifier() may contain quotes, leading to SQL syntax errors or injection vectors.\",\n      \"action\": \"Centralise escaping logic or, better, use parameter binding for all variable parts; add tests with identifiers containing quotes.\",\n      \"source\": \"FilterBaseCustomRepository.insertArticleInFilter, insertFilterInFilter, FilterBaseExportRepository.getArticleIndividual UNION builder\",\n      \"component\": \"data‑access\",\n      \"impact_scope\": null,\n      \"relations\": \"Duplicate of issue 1\",\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Hard‑coded table and column names in SQL strings\",\n      \"justification\": \"Embedding table names (e.g., AST_FILTERBASE) directly makes refactoring risky and prevents reuse across schemas.\",\n      \"action\": \"Externalise table/column names into constants or use a query builder; verify with integration tests after schema changes.\",\n      \"source\": \"All repositories\",\n      \"component\": \"architecture\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Missing input validation for enum‑derived strings\",\n      \"justification\": \"Methods use enum.name() directly in SQL; while enums are safe, future changes might allow unchecked values, introducing risk.\",\n      \"action\": \"Validate that enum values belong to expected set before using them in queries; add unit tests covering unknown enum handling.\",\n      \"source\": \"removeByTypeAndAssortment, getArticleFilter, etc.\",\n      \"component\": \"validation\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Potential memory leak in large in‑memory list processing\",\n      \"justification\": \"Methods like getArticleIndividual build huge UNION strings and keep intermediate Lists (identifiers) in memory, which can cause GC pressure for large datasets.\",\n      \"action\": \"Stream results directly from the database using RowCallbackHandler or pagination; add performance tests with large article counts.\",\n      \"source\": \"FilterBaseExportRepository.getArticleIndividual, FilterBaseGetRepository.getArticleIndividual\",\n      \"component\": \"performance\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Inconsistent use of transaction boundaries\",\n      \"justification\": \"Some methods are @Transactional but perform multiple independent execute calls; if one fails, earlier statements are not rolled back due to default propagation, leading to partial updates.\",\n      \"action\": \"Ensure all related statements are executed within a single transaction (use batch or single statement) and verify rollback behavior; add integration tests simulating failure mid‑method.\",\n      \"source\": \"removeAllIn, cloneFromFilter, clone, insertFilterBaseIn (batch)\",\n      \"component\": \"transaction\",\n      \"impact_scope\": \"prod‑relevant\",\n      \"relations\": null,\n      \"evidence\": null\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Method documentation does not match implementation\",\n      \"justification\": \"Javadoc often describes parameters that are not used or mismatched (e.g., removeAllIn comment truncated, getLanguage Javadoc contains stray markdown), which reduces maintainability.\",\n      \"action\": \"Synchronise Javadoc with actual method signatures and behaviour; run a documentation linter; add code review checklist for accurate comments.\",\n      \"source\": \"Various methods across all files\",\n      \"component\": \"documentation\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": null\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"2\",\n    \"top_todos\": [\n      \"Refactor all SQL building to use prepared statements / parameter binding to eliminate injection risk.\",\n      \"Add null checks for required session attributes and improve error handling for missing context.\",\n      \"Replace empty catch blocks with proper logging and exception propagation.\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to produce a JSON with analysis for each file/chunk? The instruction: \"You are a senior code reviewer. You analyze each code chunk.\" So likely need one JSON per file. The schema includes \"file\", \"issues\", \"summary\". We must output a single JSON object? Possibly combine all files? The spec says answer must be a single JSON object. Could include issues across all files, but \"file\" field is a string path of file or chunk ID. Since multiple files, maybe we need separate JSON objects? But constraint: single JSON object. Could we aggregate across files? Might produce separate entries in issues with source referencing each file. But \"file\" is single. Might choose to output for each file individually? But cannot have multiple top-level objects.\n\nMaybe we need to produce separate JSON per file one after another? Not allowed. Could we set \"file\" to something like \"multiple\"? The spec expects per file. Could output separate objects in an array? Not allowed.\n\nProbably need to output for each file individually, but as separate runs. However the prompt includes three files. Possibly we should combine them into one JSON with file field maybe set to \"multiple\" or list? But spec says \"string - Pfad der Datei oder Chunk-ID\". Could be a combined identifier like \"C:\\...FilterBaseCustomRepository.java, FilterBaseExportRepository.java, FilterBaseGetRepository.java, FilterBaseProofRepository.java\". Might be okay.\n\nBut better to output separate JSON objects each? The rule: \"Antwort immer als ein einziges JSON-Objekt\". So we must output one object. We'll set file to \"multiple\" or maybe list of files? We'll pick \"multiple\". Provide issues across all files, up to 10 issues total (max). So need to prioritize top issues across all.\n\nLet's identify issues.\n\nCommon problems:\n\n1. SQL injection risk: Many methods concatenate parameters directly into SQL strings (e.g., remove(Filterbase), removeByTypeAndAssortment, removeWhereStructureTypeLike, removeByAssortment, countByAssortment, countByFilter, etc.) Using string concatenation with potentially untrusted inputs (e.g., Filterbase.getEntityIdentifier(), assortment.getId() (int safe), but values like type.name() are enum, okay. However user-provided identifiers (filter.getIdentifier()) may be from DB but could be manipulated. Also in export repository, many concatenations with values like structureName, locale language id (int), version.getPimAssortmentName() (could be user-controlled). So risk of SQL injection.\n\n2. Use of raw JDBC template execute without parameter binding leads to SQL injection and also quoting issues (e.g., in removeByFilterbase uses base.getId() directly, safe as int). However in insert functions building bulk insert strings via string concatenation with values from article, could be injection if article numbers contain quotes. They escape by replace(\"'\", \"''\") for identifier but not for other fields maybe.\n\n3. Potential NPE: In many places, they call ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT) without null checks; if missing could cause NPE.\n\n4. Transactional methods using JdbcTemplate.execute for updates but not handling errors; could lead to partial updates if exception occurs mid-loop; but each loop executes separate statements, not batch, may cause inconsistent state.\n\n5. Performance: The method removeAllIn splits list but still builds large IN clause strings up to 90 items, okay. However insertFilterBaseIn builds huge single insert string maybe exceeding query length; not using batch updates; could cause memory/performance issues.\n\n6. In getArticleIndividual (in Export repo) they build large UNION query concatenating many strings, could exceed length and be inefficient.\n\n7. Use of string concatenation for SQL with numeric values but no parameterization leads to potential SQL syntax errors if values contain special chars (e.g., structureName not escaped).\n\n8. In getLanguage method of Export repo, returns null if not found; callers may not handle null leading to NPE later.\n\n9. In FilterBaseProofRepository, getRootFilterStructureByName uses LOWER(STRUCTURE_TYPE) = ? but passes raw string structureType without lowercasing; may not match.\n\n10. In many methods they swallow exceptions (empty catch) when reading ResultSet, losing error info.\n\nWe'll select top 10 issues.\n\nNow craft JSON.\n\nSummary overall rating maybe 2 stars due to security and code quality.\n\nTop todos: Replace string concatenated SQL with prepared statements, add input validation, handle nulls, replace empty catches with proper logging, use batch updates, add unit tests.\n\nNow produce JSON."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 2660,
      "prompt_tokens" : 25046,
      "total_tokens" : 27706
    },
    "timings" : {
      "cache_n" : 62,
      "prompt_n" : 24984,
      "prompt_ms" : 18761.355,
      "prompt_per_token_ms" : 0.7509347982708934,
      "prompt_per_second" : 1331.6735385050813,
      "predicted_n" : 2660,
      "predicted_ms" : 32083.446,
      "predicted_per_token_ms" : 12.061445864661653,
      "predicted_per_second" : 82.90879975922786
    }
  }
}