{
  "timestamp" : "2025-11-03T12:55:58.2993809",
  "index" : 7,
  "file" : "review-summary",
  "prompt" : {
    "role" : "user",
    "content" : "===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ArticleBaseQueueUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.exceptions.ArticleBaseQueueException;\r\nimport com.hom.ebmw.exceptions.ConvertException;\r\nimport com.hom.ebmw.exceptions.ParameterException;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.constans.ASTConst;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.FileParam;\r\nimport com.hom.ebmw.utilities.enums.ObjectType;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.hom.ebmw.utilities.enums.SettingType;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.File;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class ArticleBaseQueueUtils {\r\n\r\n\r\n    /**\r\n     * The resetUserQueues function is used to reset the user's queue.\r\n     * It does this by first calling the resetOldSessions function, which removes all of a user's old sessions.\r\n     * Then it gets the current user and finds all ArticleBaseQueues that are associated with that user and their session ID.\r\n     * If there are any ArticleBaseQueues found, then for each one:\r\n     * 1) The User is set to null (removing them from association with this queue).\r\n     * 2) The Session ID is set to an empty string (removing them from association with this queue).\r\n     *\r\n     * @param Context ctx Get the current session and user\r\n     */\r\n    public static void resetUserQueues(Context ctx) {\r\n        resetOldSessions(ctx);\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        List<ArticleBaseQueue> optArticleQueue = ctx.getServices().getArticleBaseQueueService()\r\n                .findAllByUserAndSession(user, ctx.getUserSession().getId());\r\n        if (!optArticleQueue.isEmpty()) {\r\n            for (ArticleBaseQueue queues : optArticleQueue) {\r\n                queues.setUser(null);\r\n                queues.setSession(\"\");\r\n                ctx.getServices().getArticleBaseQueueService().save(queues);\r\n                ctx.getServices().getArticleBaseService().truncateArticleTable(queues.getTableName());\r\n                log.trace(\"Clear Table: \" + queues.getTableName());\r\n            }\r\n        } else {\r\n            log.error(\"Could not Found ArticleQueue\");\r\n        }\r\n        ctx.getUserSession().remove(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n    }\r\n\r\n    /**\r\n     * The resetOldSessions function is used to clear out old sessions from the ArticleBaseQueue table.\r\n     * It does this by first finding all of the rows in the ArticleBaseQueue table, and then iterating through them.\r\n     * For each row, it checks if there is a value for loadOn (the time that a session was created). If there is no value for loadOn,\r\n     * then nothing happens with that row. If there IS a value for loadOn, then we check if it's older than our timeout period (which defaults to 24 hours).\r\n     * If so, we set user and session to null on that row\r\n     *\r\n     * @param Context ctx Get the services from the context\r\n     */\r\n    public static void resetOldSessions(Context ctx) {\r\n        List<ArticleBaseQueue> optArticleQueue = ctx.getServices().getArticleBaseQueueService().findAll();\r\n        int timeOut = getArticleBaseTimeout(ctx);\r\n        LocalDateTime currentMinusTimeOut = LocalDateTime.now().minusHours(timeOut);\r\n\r\n        if (!optArticleQueue.isEmpty()) {\r\n            for (ArticleBaseQueue queues : optArticleQueue) {\r\n                if (Objects.nonNull(queues.getLoadOn())) {\r\n                    if (queues.getLoadOn().isBefore(currentMinusTimeOut)) {\r\n                        queues.setUser(null);\r\n                        queues.setSession(\"\");\r\n                        ctx.getServices().getArticleBaseQueueService().save(queues);\r\n                        ctx.getServices().getArticleBaseService().truncateArticleTable(queues.getTableName());\r\n                        log.trace(\"Clear Table: \" + queues.getTableName());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            log.error(\"Could not Found ArticleQueue Older than [\" + currentMinusTimeOut + \"]\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The getArticleBaseTimeout function returns the value of the setting with type ARTICLE_BASE_TIME_OUT.\r\n     * If no such setting exists, it returns 1.\r\n     *\r\n     * @param Context ctx Get the setting value\r\n     * @return The value of the setting article_base_time_out\r\n     * @docauthor Trelent\r\n     */\r\n    private static int getArticleBaseTimeout(Context ctx) {\r\n        int timeOut = 1/* DEFAULT = 1 */; // it use default if setting not set or contains more than an number\r\n        Optional<Setting> optSetting = ctx.getServices().getSettingCustomServices().findBySettingType(ctx,\r\n                SettingType.ARTICLE_BASE_TIME_OUT);\r\n        if (optSetting.isPresent()) {\r\n            int buff = Parse.toInt(optSetting.get().getValue());\r\n            if (buff != 0)\r\n                timeOut = buff;\r\n        }\r\n        return timeOut;\r\n    }\r\n\r\n    /**\r\n     * The addQueueTable function is used to add a queue table to the user session.\r\n     *\r\n     * @param Context ctx Access the user session and to get the services\r\n     * @param User    user Set the user of the articlebasequeue\r\n     * @param String  table Identify the table that is being added to the queue\r\n     */\r\n    public static void addQueueTable(Context ctx, User user, String table) throws ArticleBaseQueueException {\r\n        ArticleBaseQueue queue = null;\r\n\r\n        Map<String, String> tabSession = ctx.getUserSession().get(Params.ACTIVE_ARTICLE_BASE_TABLE);\r\n        if (Objects.isNull(tabSession)) {\r\n            tabSession = new HashMap<String, String>();\r\n        }\r\n\r\n        if (Objects.isNull(tabSession.get(table))) {\r\n            List<ArticleBaseQueue> freeQueues = ctx.getServices().getArticleBaseQueueService().findAllByUserIsNull();\r\n            if (Objects.nonNull(freeQueues) && !freeQueues.isEmpty()) {\r\n                queue = freeQueues.get(0);\r\n                queue.setUser(user);\r\n                queue.setLoadOn(LocalDateTime.now());\r\n                queue.setSession(ctx.getUserSession().getId());\r\n                ctx.getServices().getArticleBaseQueueService().save(queue);\r\n            } else {\r\n                throw new ArticleBaseQueueException();\r\n            }\r\n            tabSession.put(table, queue.getTableName());\r\n            ctx.getUserSession().put(Params.ACTIVE_ARTICLE_BASE_TABLE, tabSession);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The createArticleList function is used to create a list of articles from the assortment data file.\r\n     *\r\n     * @param Context                 ctx Get the services and user session\r\n     * @param AssortmentDatafile      astDataFile Get the assortment and astfile objects\r\n     * @param List&lt;ArticleBase&gt; articles Store the articles that are created from the file\r\n     */\r\n    public static void createArticleList(Context ctx, AssortmentDatafile astDataFile, List<ArticleBase> articles) throws ParameterException {\r\n        Assortment assortment = astDataFile.getAssortment();\r\n        AstFile astFile = astDataFile.getAstFile();\r\n\r\n        if (Objects.isNull(articles)) {\r\n            articles = new ArrayList<ArticleBase>();\r\n        } else {\r\n            articles.clear();\r\n        }\r\n\r\n        File file = new File(SettingUtils.getTempFolder(ctx) + astFile.getName());\r\n        Storage storage = CompUtils.getStorage(ctx, astFile);\r\n        ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, astFile);\r\n        switch (type) {\r\n            case PROMOTION_INPUT:\r\n                cloneParameter(ctx, FileParam.AW_NUMBER, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.TITLE_MAP, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.NEWSPIC, astFile, assortment);\r\n                break;\r\n            case IMPEX_INPUT:\r\n                cloneParameter(ctx, FileParam.KATALOG_VERSION, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.PARTNER_SHORT, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.CUSTOMER_TYPE, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.BASE_ASSORTMENT, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.S3_CATALOG, astFile, assortment);\r\n                cloneParameter(ctx, FileParam.HAS_PRICE, astFile, assortment);\r\n                break;\r\n            default:\r\n            case ECAT_INPUT:\r\n                cloneParameter(ctx, FileParam.KATALOG_VERSION, astFile, assortment);\r\n                break;\r\n        }\r\n        //default\r\n        cloneParameter(ctx, FileParam.LANGUAGE, astFile, assortment);\r\n        cloneParameter(ctx, FileParam.VALID_FROM, astFile, assortment);\r\n        cloneParameter(ctx, FileParam.VALID_TO, astFile, assortment);\r\n        cloneParameter(ctx, FileParam.TERRITORY, astFile, assortment);\r\n        cloneParameter(ctx, FileParam.CURRENCY, astFile, assortment);\r\n\r\n        if (Objects.nonNull(storage.getFileblob())) {\r\n            Blob.loadFromCompressedFile(storage.getFileblob(), file);\r\n            try {\r\n                articles.addAll(ConvertUtils.convertTxt2Prices(file, assortment));\r\n                ctx.getServices().getAssortmentService().save(assortment);\r\n                ctx.getUserSession().put(Params.ACTIVE_ASSORTMENT, assortment);\r\n            } catch (ConvertException e) {\r\n                log.error(e.getLocalizedMessage(), e);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The cloneParameter function is used to copy a parameter from one file to another.\r\n     *\r\n     * @param Context   ctx Get the current user session, which is used to get the active locale\r\n     * @param FileParam param Get the parameter from the source file\r\n     * @param AstFile   from Get the parameter from\r\n     * @param AstFile   to Set the parameter on\r\n     */\r\n    public static void cloneParameter(Context ctx, FileParam param, AstFile from, AstFile to) throws ParameterException {\r\n        Object parameter = CompUtils.getParameter(ctx, param, from);\r\n        if (Objects.nonNull(parameter)) {\r\n            CompUtils.setParameter(ctx, param, parameter, to);\r\n        } else {\r\n            Locale locale = ctx.getUserSession().get(Params.ACTIVE_LOCALE);\r\n            throw new ParameterException(ctx.getServices().getTranslationService().getTranslation(\r\n                    TMS.ERROR_MSG_BASE_FILE_PARAMETER_IS_EMPTY, locale, ctx) + \" [\" + param.getName() + \"]\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The createPositivList function takes in a context, an assortment datafile, and a list of articles.\r\n     * It then creates a file from the storage's fileblob (which is the compressed version of the original text file).\r\n     * Then it converts that text file into prices using ConvertUtils.convertTxt2Prices().\r\n     *\r\n     * @param Context                 ctx Get the user session\r\n     * @param AssortmentDatafile      astDataFile Get the assortment and astfile from it\r\n     * @param List&lt;ArticleBase&gt; positivs Store the converted data\r\n     */\r\n    public static void createPositivList(Context ctx, AssortmentDatafile astDataFile, List<ArticleBase> positivs) {\r\n        Assortment assortment = astDataFile.getAssortment();\r\n        AstFile astFile = astDataFile.getAstFile();\r\n\r\n        if (Objects.isNull(positivs)) {\r\n            positivs = new ArrayList<ArticleBase>();\r\n        } else {\r\n            positivs.clear();\r\n        }\r\n\r\n        File file = new File(SettingUtils.getTempFolder(ctx) + UUID.randomUUID());\r\n        Storage storage = CompUtils.getStorage(ctx, astFile);\r\n\r\n        if (Objects.nonNull(storage.getFileblob())) {\r\n            Blob.loadFromCompressedFile(storage.getFileblob(), file);\r\n            try {\r\n                positivs.addAll(ConvertUtils.convertTxt2Prices(file, assortment));\r\n                ctx.getUserSession().put(Params.ACTIVE_ASSORTMENT, assortment);\r\n            } catch (ConvertException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The getAdmFilter function is used to get the filters for the ADM file.\r\n     *\r\n     * @param Context    ctx Get the filter service\r\n     * @param Assortment assortmentFile Get the file type\r\n     * @return A list of filters that are active and not deleted\r\n     */\r\n    public static List<Filter> getAdmFilter(Context ctx, Assortment assortmentFile) {\r\n        ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortmentFile);\r\n\r\n        List<Filter> filters = ctx.getServices().getFilterService().findAll();\r\n        filters.removeIf(item -> !item.isActive());\r\n        filters.removeIf(item -> Objects.nonNull(item.getDeleteBy()));\r\n        filters.removeIf(item -> !item.getPrefix().equals(ASTConst.FILTER_ADM));\r\n        switch (type) {\r\n            default:\r\n            case ECAT:\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.IMPEX));\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.PROMOTION));\r\n                break;\r\n            case IMPEX:\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.ECAT));\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.PROMOTION));\r\n                break;\r\n            case PROMOTION:\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.ECAT));\r\n                filters.removeIf(item -> item.getSortType().equals(ObjectType.IMPEX));\r\n                break;\r\n        }\r\n\r\n        return filters;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\ArticleBaseQueueUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\AssortmentUtil.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.exceptions.AssortmentLockException;\r\nimport com.hom.ebmw.exceptions.ConvertException;\r\nimport com.hom.ebmw.exceptions.FileCouldNotFoundException;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.constans.ASTConst;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.time.LocalDateTime;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class AssortmentUtil {\r\n\r\n    /**\r\n     * The unLock function removes the active assortment from the user session,\r\n     * reloads it, and sets its lock parameter to false.\r\n     *\r\n     * @param Context    ctx Get the user session\r\n     * @param Assortment assortment Set the lock parameter to false\r\n     */\r\n    public static void unLock(Context ctx, Assortment assortment) {\r\n        ctx.getUserSession().remove(Params.ACTIVE_ASSORTMENT);\r\n        assortment = reload(ctx, assortment);\r\n        CompUtils.setParameter(ctx, FileParam.LOCK, Boolean.FALSE, assortment);\r\n    }\r\n\r\n    /**\r\n     * The reload function is used to reload the active assortment from the database.\r\n     * This is necessary because when a user adds or removes an item from their cart,\r\n     * we need to update the quantity of that item in our active assortment.  We do this by\r\n     * calling findById on our AssortmentService and then updating our UserSession with this new information.\r\n     *\r\n     * @param Context    ctx Get the services and the user session\r\n     * @param Assortment assortment Reload the assortment in the user session\r\n     * @return An assortment, which is then returned by the save function\r\n     */\r\n    private static Assortment reload(Context ctx, Assortment assortment) {\r\n        Optional<Assortment> optAssortment = ctx.getServices().getAssortmentService().findById(assortment.getId());\r\n        if (optAssortment.isPresent()) {\r\n            ctx.getUserSession().put(Params.ACTIVE_ASSORTMENT, optAssortment.get());\r\n            assortment = optAssortment.get();\r\n        }\r\n        return assortment;\r\n    }\r\n\r\n    /**\r\n     * The isLocked function checks if the assortment is locked.\r\n     *\r\n     * @param Context    ctx Get the parameter from the assortment\r\n     * @param Assortment assortment Determine if the assortment is locked\r\n     * @return The assortment object if it is not locked\r\n     */\r\n    public static Assortment isLocked(Context ctx, Assortment assortment) throws AssortmentLockException {\r\n        reload(ctx, assortment);\r\n        Boolean isLock = CompUtils.getParameter(ctx, FileParam.LOCK, assortment);\r\n        if (Objects.nonNull(isLock) && isLock.equals(Boolean.TRUE)) {\r\n            throw new AssortmentLockException();\r\n        }\r\n        return assortment;\r\n    }\r\n\r\n    /**\r\n     * The proofArticleBase function is used to determine whether or not a given article should be displayed in the PIM.\r\n     * It takes two arguments: a Context object and an ArrayList of ArticleBase objects. The function returns true if the\r\n     * article should be displayed, and false otherwise. The proofArticleBase function iterates through each ArticleBase\r\n     * object in the ArrayList, checking for certain conditions that would cause it to return false (i.e., not display). If\r\n     * none of these conditions are met, then it returns true (i.e., display). These conditions include: 1) Whether or not\r\n     *\r\n     * @param Context                 ctx Determine if the user is a dis user\r\n     * @param List&lt;ArticleBase&gt; articles Pass in a list of articlebase objects\r\n     * @return A boolean value\r\n     */\r\n    public static boolean proofArticleBase(Context ctx, List<ArticleBase> articles) {\r\n        boolean isValidDIS = FilterUtils.removeDIS(ctx);\r\n\r\n        for (ArticleBase item : articles) {\r\n            if (Objects.nonNull(item)) {\r\n                if (item.getComment().contains(FilterType.NOTINPIM.name())) {\r\n                    return false;\r\n                } else if (item.getComment().contains(FilterType.NOTAPPROVAL.name())) {\r\n                    return false;\r\n                } else if (item.getComment().contains(FilterType.VTL_STATUS.name())) {\r\n                    return false;\r\n                } else if (item.getComment().contains(FilterType.COUNTRY_LOCK.name())) {\r\n                    return false;\r\n                } else if (item.getComment().contains(FilterType.NOPRICE.name())) {\r\n                    return false;\r\n                } else if (item.getComment().contains(FilterType.INDIVIDUAL_ADM.name())) {\r\n                    return false;\r\n                } else if (isValidDIS && item.getComment().contains(\"DIS\")) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The removeUnwantedFromList function removes unwanted articles from a list of articles.\r\n     *\r\n     * @param Context                       ctx Get the sharedpreferences\r\n     * @param Collection&lt;ArticleBase&gt; articles Pass the list of articles to be filtered\r\n     * @return A list of articlebase objects\r\n     */\r\n    public static List<ArticleBase> removeUnwantedFromList(Context ctx, Collection<ArticleBase> articles) {\r\n        List<ArticleBase> filtered = new ArrayList<>();\r\n        filtered.addAll(articles);\r\n\r\n        filtered.removeIf(item -> item.getComment().contains(FilterType.NOTINPIM.name()));\r\n        filtered.removeIf(item -> item.getComment().contains(FilterType.NOTAPPROVAL.name()));\r\n        filtered.removeIf(item -> item.getComment().contains(FilterType.VTL_STATUS.name()));\r\n        filtered.removeIf(item -> item.getComment().contains(FilterType.COUNTRY_LOCK.name()));\r\n        filtered.removeIf(item -> item.getComment().contains(FilterType.NOPRICE.name()));\r\n        filtered.removeIf(item -> item.getComment().contains(FilterType.INDIVIDUAL_ADM.name()));\r\n        if (FilterUtils.removeDIS(ctx)) {\r\n            filtered.removeIf(item -> item.getComment().contains(\"DIS\"));\r\n        }\r\n\r\n        return filtered;\r\n    }\r\n\r\n    /**\r\n     * The isValid function checks to see if the article is valid.\r\n     *\r\n     * @param Context                       ctx Get the application context\r\n     * @param Collection&lt;ArticleBase&gt; articles Pass a collection of articlebase objects to the isvalid function\r\n     * @return A boolean value\r\n     */\r\n    public static boolean isValid(Context ctx, Collection<ArticleBase> articles) {\r\n        List<ArticleBase> toList = new ArrayList<>();\r\n        toList.addAll(articles);\r\n        return proofArticleBase(ctx, toList);\r\n    }\r\n\r\n    /**\r\n     * The delete function is used to delete the active assortment.\r\n     * If the assortment has no name, it will be removed from the database.\r\n     * Otherwise, it will be saved with a lock of false and removed from session.\r\n     *\r\n     * @param Context ctx Get the active assortment from the user session\r\n     * @return A boolean value\r\n     */\r\n    public static void delete(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        if (Objects.nonNull(assortment)) {\r\n            if (assortment.getName().isEmpty()) {\r\n                ctx.getServices().getAssortmentCustomService().remove(ctx, assortment);\r\n            } else {\r\n                ProjectRole projectRole = ctx.getHttpAttribute(SessionParams.ACTIVE_PROJECT_ROLE);\r\n                assortment.setProjectRole(projectRole);\r\n                CompUtils.setParameter(ctx, FileParam.LOCK, Boolean.FALSE, assortment);\r\n                ctx.getServices().getAssortmentService().save(assortment);\r\n            }\r\n            ctx.getUserSession().remove(Params.ACTIVE_ASSORTMENT);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The getEcatFiles function is used to create a list of files that are needed for the export.\r\n     * The function first creates a file from the assortment and adds it to the result list.\r\n     * If parameter export is enabled, it then creates another file with parameters and adds it to the result list.\r\n     * Finally, if there are any ZinfoFiles associated with this assortment, they will be added as well.\r\n     *\r\n     * @param Context    ctx Get the temp folder\r\n     * @param Assortment assortment Get the name of the assortment\r\n     * @return A list of files\r\n     */\r\n    public static List<File> getEcatFiles(Context ctx, Assortment assortment) {\r\n        List<File> result = new ArrayList<>();\r\n\r\n        // PriceAssortment\r\n        log.info(\"Write PriceAssortment File\");\r\n        File fiAssortment = new File(SettingUtils.getTempFolder(ctx) + File.separator + assortment.getName());\r\n        Storage storage = CompUtils.getStorage(ctx, assortment);\r\n        Blob.loadFromCompressedFile(storage.getFileblob(), fiAssortment);\r\n        result.add(fiAssortment);\r\n\r\n        // Parameterfile\r\n        if (ctx.getServices().getProperty().isExportParam()) {\r\n            String fileName = ExportFileUtils.buildECATParameterFileName(ctx, assortment);\r\n            File fiParameter = null;\r\n            try {\r\n                log.info(\"Write eCat-Parameter File\");\r\n                fiParameter = ExportFileUtils.reCreateFileTillLine(ctx, fiAssortment, fileName, 3);\r\n                result.add(fiParameter);\r\n            } catch (FileCouldNotFoundException | ConvertException e) {\r\n                log.error(e.getMessage());\r\n            }\r\n        }\r\n\r\n        // Zinfos\r\n        List<File> zInfos = new ArrayList<>();\r\n        if (Objects.nonNull(assortment)) {\r\n            List<AssortmentDatafile> xFiles = ctx.getServices().getAssortmentDataFileService()\r\n                    .findAllByAssortment(assortment);\r\n            xFiles.forEach(item -> {\r\n                if (item.getAstFile() instanceof ZinfoFile) {\r\n                    log.info(\"Write Zinfo File (\" + item.getAstFile().getName() + \")\");\r\n                    if (Objects.isNull(item.getAstFile().getDeleteBy())) {\r\n                        File fiZinfo = new File(\r\n                                SettingUtils.getTempFolder(ctx) + File.separator + item.getAstFile().getName());\r\n                        Storage zInfoStorage = CompUtils.getStorage(ctx, item.getAstFile());\r\n                        Blob.loadFromCompressedFile(zInfoStorage.getFileblob(), fiZinfo);\r\n                        zInfos.add(fiZinfo);\r\n                    }\r\n                }\r\n            });\r\n            result.addAll(zInfos);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getImpexFiles function is used to create a list of files that are needed for the ImpexExport.\r\n     * The function creates three different files:\r\n     * - An assortment file containing all articles and their attributes. This file is created by using the Blob class, which loads a compressed file from storage into an uncompressed File object.\r\n     * - A price file containing all prices for each article in the assortment. This is only done if there are prices available in Hybris (i.e., hasPrice = true). If this condition holds, then we use stream() to filter out any AssortmentDatafile objects that do not\r\n     *\r\n     * @param Context    ctx Get the current context\r\n     * @param Assortment assortment Get the name of the file\r\n     * @return A list of files\r\n     */\r\n    public static List<File> getImpexFiles(Context ctx, Assortment assortment) {\r\n        List<File> result = new ArrayList<File>();\r\n\r\n        Storage storage = null;\r\n        // ImpexAssortment\r\n        log.info(\"Write ArticleAssortment File\");\r\n        File fiAssortment = new File(SettingUtils.getTempFolder(ctx) + File.separator + assortment.getName());\r\n        storage = CompUtils.getStorage(ctx, assortment);\r\n        Blob.loadFromCompressedFile(storage.getFileblob(), fiAssortment);\r\n        result.add(fiAssortment);\r\n\r\n        // ImpexPriceAssortment\r\n        Boolean hasPrice = CompUtils.getParameter(ctx, FileParam.HAS_PRICE, assortment);\r\n\r\n        if (Objects.nonNull(hasPrice) && hasPrice) {\r\n            List<AssortmentDatafile> xCrosses = ctx.getServices().getAssortmentDataFileService()\r\n                    .findAllByAssortment(assortment);\r\n            Optional<AssortmentDatafile> optXCross = xCrosses.stream()\r\n                    .filter(item -> item.getAstFile() instanceof ImpexExport).findFirst();\r\n            optXCross.ifPresent(item -> {\r\n                ImpexExport imExp = (ImpexExport) item.getAstFile();\r\n\r\n                log.info(\"Write ImpexPrice File\");\r\n                File fiPrice = new File(SettingUtils.getTempFolder(ctx) + File.separator + imExp.getName());\r\n                Storage store = CompUtils.getStorage(ctx, imExp);\r\n                Blob.loadFromCompressedFile(store.getFileblob(), fiPrice);\r\n                result.add(fiPrice);\r\n            });\r\n        }\r\n\r\n        // Parameterfile\r\n        if (ctx.getServices().getProperty().isExportParam()) {\r\n            String fileName = ExportFileUtils.buildIMPEXParameterFileName(ctx, assortment);\r\n            File fiParameter = null;\r\n            try {\r\n                log.info(\"Write Promotion-Parameter File\");\r\n                fiParameter = ExportFileUtils.reCreateFileTillLine(ctx, fiAssortment, fileName, 3);\r\n                result.add(fiParameter);\r\n            } catch (FileCouldNotFoundException | ConvertException e) {\r\n                log.error(e.getMessage());\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getPromotionFiles function is used to create a list of files that are needed for the promotion export.\r\n     * The function creates three files:\r\n     * - An assortment file containing all articles in the assortment.\r\n     * - A price file containing all prices for the articles in the assortment.\r\n     * - A parameter file containing information about how to export and where to save it on Hybris' server.\r\n     *\r\n     * @param Context    ctx Get the services from the context\r\n     * @param Assortment assortment Get the name of the assortment\r\n     * @return A list of files that are used for the promotion\r\n     */\r\n    public static List<File> getPromotionFiles(Context ctx, Assortment assortment) {\r\n        List<File> result = new ArrayList<File>();\r\n\r\n        Storage storage = null;\r\n        // ImpexAssortment\r\n        log.info(\"Write ArticleAssortment File\");\r\n        File fiAssortment = new File(SettingUtils.getTempFolder(ctx) + File.separator + assortment.getName());\r\n        storage = CompUtils.getStorage(ctx, assortment);\r\n        Blob.loadFromCompressedFile(storage.getFileblob(), fiAssortment);\r\n        result.add(fiAssortment);\r\n\r\n        // ImpexPriceAssortment\r\n        List<AssortmentDatafile> xCrosses = ctx.getServices().getAssortmentDataFileService()\r\n                .findAllByAssortment(assortment);\r\n        Optional<AssortmentDatafile> optXCross = xCrosses.stream()\r\n                .filter(item -> item.getAstFile() instanceof ImpexExport).findFirst();\r\n        optXCross.ifPresent(item -> {\r\n            ImpexExport imExp = (ImpexExport) item.getAstFile();\r\n\r\n            log.info(\"Write ImpexPrice File\");\r\n            File fiPrice = new File(SettingUtils.getTempFolder(ctx) + File.separator + imExp.getName());\r\n            Storage store = CompUtils.getStorage(ctx, imExp);\r\n            Blob.loadFromCompressedFile(store.getFileblob(), fiPrice);\r\n            result.add(fiPrice);\r\n        });\r\n\r\n        // Parameterfile\r\n        String fileName = ExportFileUtils.buildPromotionTitleFileName(ctx, assortment);\r\n        File fiParameter = null;\r\n\r\n        log.info(\"Write Impex-Parameter File\");\r\n        fiParameter = ExportFileUtils.buildPromotionTitleFile(ctx, fileName, assortment);\r\n        result.add(fiParameter);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The getFiles function returns a list of files that are associated with the assortment.\r\n     * The type of file is determined by the FileParam parameter, which can be set to ECAT, IMPEX or PROMOTION.\r\n     *\r\n     * @param Context    ctx Get the parameters from the context\r\n     * @param Assortment assortment Get the file type\r\n     * @return A list of files\r\n     */\r\n    private static List<File> getFiles(Context ctx, Assortment assortment) {\r\n        ObjectType fileType = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n        List<File> files = null;\r\n        switch (fileType) {\r\n            default:\r\n            case ECAT:\r\n                files = AssortmentUtil.getEcatFiles(ctx, assortment);\r\n                break;\r\n            case IMPEX:\r\n                files = AssortmentUtil.getImpexFiles(ctx, assortment);\r\n                break;\r\n            case PROMOTION:\r\n                files = AssortmentUtil.getPromotionFiles(ctx, assortment);\r\n                break;\r\n\r\n        }\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * The getFile function is used to create a file based on the type of file that is being created.\r\n     * The function takes in a context, list of articles, and an AstFile object.\r\n     * It then uses the FileParam enum to determine what type of file it should be creating.\r\n     * Depending on which ObjectType is returned from CompUtils, one of several functions will be called: buildPositivFile(), buildPriceFile(), or buildImpexFile().\r\n     * These functions are all located in ExportFileUtils class and they each return a File object that contains the data for each article within its respective\r\n     *\r\n     * @param Context                 ctx Get the parameters from the context\r\n     * @param List&lt;ArticleBase&gt; articles Get the articles that are going to be exported\r\n     * @param String                  filePath Get the file path of the export file\r\n     * @param AstFile                 file Set the name of the file\r\n     * @return A file object\r\n     */\r\n    public static File getFile(Context ctx, List<ArticleBase> articles, String filePath, AstFile file) {\r\n        ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, file);\r\n        File export = null;\r\n\r\n        switch (type) {\r\n            case ECAT_INPUT_POSITIV:\r\n                export = ExportFileUtils.buildPositivFile(ctx, articles, ASTConst.DEFAULT);\r\n                file.setName(ExportFileUtils.buildPositivFileName(ctx, file));\r\n                break;\r\n            default:\r\n            case ECAT_INPUT:\r\n            case ECAT_IMPORT:\r\n            case ECAT:\r\n                export = ExportFileUtils.buildPriceFile(ctx, articles, ASTConst.DEFAULT, file);\r\n                file.setName(ExportFileUtils.buildPriceFileName(ctx, file));\r\n                break;\r\n            case IMPEX_INPUT:\r\n            case IMPEX_IMPORT:\r\n            case IMPEX:\r\n                if (type == ObjectType.IMPEX_INPUT) {\r\n                    boolean valid = CompUtils.getParameter(ctx, FileParam.HAS_PRICE, file);\r\n                    if (valid) {\r\n                        export = ExportFileUtils.buildPriceFile(ctx, articles, ASTConst.DEFAULT, file);\r\n                    } else {\r\n                        export = ExportFileUtils.buildImpexFile(ctx, articles, ASTConst.DEFAULT, file);\r\n                    }\r\n                } else {\r\n                    export = ExportFileUtils.buildImpexFile(ctx, articles, ASTConst.DEFAULT, file);\r\n                }\r\n                file.setName(ExportFileUtils.buildImpexFileName(ctx, file));\r\n                break;\r\n            case PROMOTION_INPUT:\r\n            case PROMOTION_IMPORT:\r\n            case PROMOTION:\r\n                export = ExportFileUtils.buildPromotionFile(ctx, articles, ASTConst.DEFAULT, file);\r\n                file.setName(ExportFileUtils.buildPromotionFileName(ctx, file));\r\n                break;\r\n        }\r\n        return export;\r\n    }\r\n\r\n\r\n    /**\r\n     * The upload function takes a context and an assortment as parameters.\r\n     * It then creates a list of files from the getFiles function, which is passed the context and assortment.\r\n     * The upload function then sets up a folder to store the files in, using SettingUtils to find out where that folder should be located.\r\n     * Then it copies each file into that folder using FileUtils' copyFileTo method.\r\n     * Finally, it uses CompUtils' setParameter method to set two parameters: UPLOAD_BY (the user who uploaded) and UPLOAD_ON (the date/time when they uploaded\r\n     *\r\n     * @param Context    ctx Get the current user and to set the upload date\r\n     * @param Assortment assortment Get the files from the assortment\r\n     */\r\n    public static void upload(Context ctx, Assortment assortment) {\r\n        List<File> files = getFiles(ctx, assortment);\r\n\r\n        String folder = SettingUtils.getAssortmentFolder(ctx);\r\n        files.forEach(file -> {\r\n            File srcFi = file;\r\n            File dstFi = new File(folder + File.separator + file.getName());\r\n            FileUtils.copyFileTo(srcFi, dstFi);\r\n        });\r\n\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        if (Objects.isNull(user)) {\r\n            Optional<User> optUser = ctx.getServices().getUserServices().findByUserId(\"FAKE\");\r\n            if (optUser.isPresent()) {\r\n                user = optUser.get();\r\n            }\r\n        }\r\n\r\n        CompUtils.setParameter(ctx, FileParam.UPLOAD_BY, user, assortment);\r\n        CompUtils.setParameter(ctx, FileParam.UPLOAD_ON, LocalDateTime.now(), assortment);\r\n    }\r\n\r\n    /**\r\n     * The zip function takes a context and an assortment as parameters.\r\n     * It then creates a list of files to be zipped, which is returned by the getFiles function.\r\n     * The zipFile variable is set to the path of the temp folder in SettingUtils, plus a random UUID string.\r\n     * If this file exists (which it should), we try to compress all files in our list into one zip file using ZipUtility's compress method.\r\n     * We then delete each individual file from our list using forEach and lambda expressions, logging whether or not they were successfully deleted from system memory.\r\n     *\r\n     * @param Context    ctx Get the application context\r\n     * @param Assortment assortment Get the name of the assortment\r\n     * @return A file, which is then downloaded by the user\r\n     */\r\n    public static File zip(Context ctx, Assortment assortment) {\r\n        List<File> toZip = getFiles(ctx, assortment);\r\n\r\n        File zipFile = new File(SettingUtils.getTempFolder(ctx) + UUID.randomUUID());\r\n\r\n        if (Objects.nonNull(zipFile)) {\r\n            try {\r\n                ZipUtility.compress(toZip, zipFile);\r\n\r\n                toZip.forEach(file -> {\r\n                    if (file.delete()) {\r\n                        log.debug(\"File\" + file.getName() + \"removed from System\");\r\n                    }\r\n                });\r\n            } catch (FileNotFoundException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            } catch (IOException e) {\r\n                log.error(e.getLocalizedMessage());\r\n            }\r\n        }\r\n        return zipFile;\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\AssortmentUtil.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\AstNotification.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.utilities.enums.Params;\r\nimport com.vaadin.flow.component.Component;\r\nimport com.vaadin.flow.component.UI;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.icon.VaadinIcon;\r\nimport com.vaadin.flow.component.notification.Notification;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\n\r\nimport java.util.Locale;\r\nimport java.util.Objects;\r\n\r\n@SuppressWarnings(\"serial\")\r\npublic class AstNotification extends Notification {\r\n\r\n    private UI ui;\r\n    private TranslationProvider translator;\r\n    private Locale curLocale;\r\n\r\n    /**\r\n     * The AstNotification function is a constructor for the AstNotification class.\r\n     * It initializes the context and duration of the notification, as well as\r\n     * calls on other functions to set up and display it.\r\n     *\r\n     * @param Context ctx Create the layoutinflater object\r\n     * @return The initial function\r\n     */\r\n    public AstNotification(Context ctx) {\r\n        this.setDuration(6000);\r\n        initial(ctx);\r\n    }\r\n\r\n    /**\r\n     * The AstNotification function is a constructor for the AstNotification class.\r\n     * It takes in two parameters, an integer duration and a Context ctx. The duration parameter\r\n     * sets the length of time that the notification will be displayed on screen, while ctx is used to\r\n     * set up some of the other components needed for displaying notifications. The function also calls\r\n     * another function called initial(), which does most of this setup work. This constructor allows us to create new instances of AstNotification objects with ease by simply calling: &quot;AstNotification ast = new AstNotification(duration,ctx);&quot; where duration and ctx\r\n     *\r\n     * @param int     duration Set the duration of the notification\r\n     * @param Context ctx Get the application context\r\n     * @return A new astnotification object\r\n     */\r\n    public AstNotification(int duration, Context ctx) {\r\n        this.setDuration(duration);\r\n        initial(ctx);\r\n    }\r\n\r\n    /**\r\n     * The initial function is called by the framework when a new instance of this class is created.\r\n     * It initializes the translator and current locale variables, which are used to translate strings\r\n     * in other functions. The ui variable stores information about the user interface that will be used\r\n     * to display messages and prompts.\r\n     *\r\n     * @param Context ctx Get the usersession and translationservice\r\n     */\r\n    private void initial(Context ctx) {\r\n        this.ui = ctx.getUserSession().get(Params.ACTIVE_UI);\r\n        this.translator = ctx.getServices().getTranslationService();\r\n        this.curLocale = ctx.getSession().getCurrentLocale(ctx);\r\n    }\r\n\r\n    /**\r\n     * The errorMessage function is used to display an error message in the GUI.\r\n     *\r\n     * @param Exception exec Get the message from the exception\r\n     */\r\n    public void errorMessage(Exception exec) {\r\n        errorMessage(exec.getMessage());\r\n    }\r\n\r\n    /**\r\n     * The errorMessage function is used to display an error message in the middle of the screen.\r\n     *\r\n     * @param final String message Display the message in the errormessage function\r\n     */\r\n    public void errorMessage(final String message) {\r\n        HorizontalLayout body = new HorizontalLayout();\r\n\r\n        Paragraph text = new Paragraph(translator.getTranslation(message, curLocale));\r\n        body.add(VaadinIcon.WARNING.create(), text);\r\n        add(body);\r\n        setPosition(Position.MIDDLE);\r\n        open();\r\n    }\r\n\r\n    /**\r\n     * The errorPrintMessage function is used to print an error message in the middle of the screen.\r\n     *\r\n     * @param final String content Display the error message\r\n     */\r\n    public void errorPrintMessage(final String content) {\r\n        HorizontalLayout body = new HorizontalLayout();\r\n\r\n        Paragraph text = new Paragraph(content);\r\n        body.add(VaadinIcon.WARNING.create(), text);\r\n        add(body);\r\n        setPosition(Position.MIDDLE);\r\n        open();\r\n    }\r\n\r\n    /**\r\n     * The hintMessage function displays a message to the user.\r\n     *\r\n     * @param String content Set the content of the hint message\r\n     * @param int    duration Set the duration of the hint message\r\n     */\r\n    public void hintMessage(String content, int duration) {\r\n        setDuration(duration);\r\n        hintMessage(content);\r\n    }\r\n\r\n    /**\r\n     * The hintMessage function is used to display a message in the middle of the screen.\r\n     *\r\n     * @param String content Pass the message to be displayed in the hintmessage function\r\n     */\r\n    public void hintMessage(String content) {\r\n        HorizontalLayout body = new HorizontalLayout();\r\n        Paragraph text = new Paragraph(content);\r\n        body.add(VaadinIcon.BOOKMARK.create(), text);\r\n        add(body);\r\n        setPosition(Position.MIDDLE);\r\n        open();\r\n    }\r\n\r\n    /**\r\n     * The open function is used to open the window.\r\n     */\r\n    @Override\r\n    public void open() {\r\n        if (Objects.isNull(UI.getCurrent())) {\r\n            ui.access(() -> super.open());\r\n        } else {\r\n            super.open();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The add function is used to add components to the UI.\r\n     *\r\n     * @param Component... components Pass in a variable number of components to the add method\r\n     */\r\n    @Override\r\n    public void add(Component... components) {\r\n        if (Objects.isNull(UI.getCurrent())) {\r\n            ui.access(() -> super.add(components));\r\n        } else {\r\n            super.add(components);\r\n        }\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\AstNotification.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\Base.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport org.apache.tomcat.util.codec.binary.Base64;\r\n\r\npublic class Base {\r\n    /**\r\n     * The encode64 function takes a string as an argument and returns the Base64 encoding of that string.\r\n     *\r\n     * @param String path Get the bytes of the path\r\n     * @return A string of the path encoded in base64\r\n     */\r\n    public static String encode64(String path) {\r\n        Base64 coder = new Base64();\r\n        return coder.encodeAsString(path.getBytes());\r\n    }\r\n\r\n    /**\r\n     * The decode64 function takes a string and decodes it using the Base64 class.\r\n     *\r\n     * @param String path Get the path of the file\r\n     * @return The decoded string\r\n     */\r\n    public static String decode64(String path) {\r\n        Base64 coder = new Base64();\r\n        byte[] demo = coder.decode(path.getBytes());\r\n        return new String(demo);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\Base.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\Blob.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport java.io.*;\r\nimport java.nio.file.Files;\r\nimport java.util.Objects;\r\nimport java.util.zip.DataFormatException;\r\nimport java.util.zip.Deflater;\r\nimport java.util.zip.Inflater;\r\n\r\npublic class Blob {\r\n\r\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Blob.class);\r\n\r\n\t/**\r\n\t * The save function takes a file and compresses it using the compress function.\r\n\t *\r\n\t * @param File file Specify the file that is being compressed\r\n\t * @return A byte array of the compressed file\r\n\t */\r\n\tpublic static byte[] save(File file) throws IOException {\r\n\t\tbyte[] compressed = compress(Files.readAllBytes(file.toPath()));\r\n\t\treturn compressed;\r\n\t}\r\n\r\n\t/**\r\n\t * The loadFromFile function takes a byte array and a file as parameters.\r\n\t * It then writes the contents of the byte array to the file.\r\n\t *\r\n\t * @param byte[] blob Store the file data\r\n\t * @param File   file Specify the file to be written to\r\n\t */\r\n\tpublic static void loadFromFile(byte[] blob, File file) throws IOException {\r\n\t\tFileOutputStream fos = new FileOutputStream(file);\r\n\t\tfos.write(blob);\r\n\t\tfos.close();\r\n\t}\r\n\r\n\t/**\r\n\t * The loadFromCompressedFile function takes a byte array and a file as parameters.\r\n\t * It then decompresses the byte array, writes it to the file, and closes the FileOutputStream.\r\n\t *\r\n\t * @param byte[] blob Pass the compressed data to be decompressed\r\n\t * @param File   file Specify the file to write the decompressed data to\r\n\t */\r\n\tpublic static void loadFromCompressedFile(byte[] blob, File file) {\r\n\t\ttry (final FileOutputStream fos = new FileOutputStream(file)) {\r\n\t\t\tbyte[] decompressed = decompress(blob);\r\n\t\t\tfos.write(decompressed);\r\n\t\t} catch (IOException | DataFormatException e) {\r\n\t\t\tLOG.error(e.getLocalizedMessage());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * The compress function takes in a byte array and returns a compressed version of the input.\r\n\t *\r\n\t * @param byte[] data Specify the data to be compressed\r\n\t * @return The compressed byte array\r\n\t */\r\n\tpublic static byte[] compress(byte[] data) throws IOException {\r\n\t\tDeflater deflater = new Deflater();\r\n\t\tdeflater.setInput(data);\r\n\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream(data.length);\r\n\t\tdeflater.setLevel(Deflater.BEST_COMPRESSION);\r\n\t\tdeflater.finish();\r\n\t\tbyte[] buffer = new byte[1024];\r\n\t\twhile (!deflater.finished()) {\r\n\t\t\tint count = deflater.deflate(buffer); // returns the generated code... index\r\n\t\t\toutputStream.write(buffer, 0, count);\r\n\t\t}\r\n\t\toutputStream.close();\r\n\t\tbyte[] output = outputStream.toByteArray();\r\n\t\tLOG.info(\"Original: \" + data.length / 1024 + \" Kb\");\r\n\t\tLOG.info(\"Compressed: \" + output.length / 1024 + \" Kb\");\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * The decompress function takes a byte array and decompresses it using the Inflater class.\r\n\t * It then returns the decompressed data as a byte array.\r\n\t *\r\n\t * @param byte[] data Pass the compressed data to the decompress function\r\n\t * @return A byte array\r\n\t */\r\n\tpublic static byte[] decompress(byte[] data) throws IOException, DataFormatException {\r\n\t\tInflater inflater = new Inflater();\r\n\t\tinflater.setInput(data);\r\n\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream(data.length);\r\n\t\tbyte[] buffer = new byte[1024];\r\n\t\twhile (!inflater.finished()) {\r\n\t\t\tint count = inflater.inflate(buffer);\r\n\t\t\toutputStream.write(buffer, 0, count);\r\n\t\t}\r\n\t\toutputStream.close();\r\n\t\tbyte[] output = outputStream.toByteArray();\r\n\t\tLOG.info(\"Compressed: \" + data.length / 1024 + \" Kb\");\r\n\t\tLOG.info(\"DeComppressed: \" + output.length / 1024 + \" Kb\");\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * The convertObject2Byte function converts an object to a byte array.\r\n\t *\r\n\t * @param Object object Convert the object to a byte array\r\n\t * @return A byte array\r\n\t */\r\n\tpublic static byte[] convertObject2Byte(Object object) {\r\n\t\tbyte[] result = new byte[0];\r\n\t\ttry (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\r\n\t\t\ttry (ObjectOutputStream oos = new ObjectOutputStream(bos)) {\r\n\t\t\t\toos.writeObject(object);\r\n\t\t\t\tresult = bos.toByteArray();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tLOG.error(e.getLocalizedMessage());\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * The convertByte2Object function converts a byte array into an object.\r\n\t *\r\n\t * @param byte[] input Convert the byte array into an object\r\n\t * @return The object that was serialized in the convertobject2byte function\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic static <E> E convertByte2Object(byte[] input) {\r\n\t\tObject result = null;\r\n\t\ttry (ByteArrayInputStream bis = new ByteArrayInputStream(input)) {\r\n\t\t\ttry (ObjectInputStream ois = new ObjectInputStream(bis)) {\r\n\t\t\t\tresult = ois.readObject();\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tLOG.error(e.getLocalizedMessage());\r\n\t\t}\r\n\r\n\t\tif (Objects.nonNull(result))\r\n\t\t\treturn (E) result;\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n}\r\n\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\Blob.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\CompUtils.java =====\n```\npackage com.hom.ebmw.utilities;\r\n\r\nimport com.hom.ebmw.configuration.security.Services;\r\nimport com.hom.ebmw.configuration.security.SessionUtils;\r\nimport com.hom.ebmw.ipim.model.Language;\r\nimport com.hom.ebmw.jpa.dao.ParameterDAO;\r\nimport com.hom.ebmw.jpa.model.*;\r\nimport com.hom.ebmw.pojo.BoundingBox;\r\nimport com.hom.ebmw.pojo.Context;\r\nimport com.hom.ebmw.pojo.KatalogVersion;\r\nimport com.hom.ebmw.pojo.Position;\r\nimport com.hom.ebmw.utilities.constans.TMS;\r\nimport com.hom.ebmw.utilities.enums.*;\r\nimport com.vaadin.flow.component.Component;\r\nimport com.vaadin.flow.component.HasStyle;\r\nimport com.vaadin.flow.component.grid.Grid;\r\nimport com.vaadin.flow.component.html.Image;\r\nimport com.vaadin.flow.component.html.Paragraph;\r\nimport com.vaadin.flow.component.html.Span;\r\nimport com.vaadin.flow.component.icon.Icon;\r\nimport com.vaadin.flow.component.icon.VaadinIcon;\r\nimport com.vaadin.flow.component.orderedlayout.HorizontalLayout;\r\nimport com.vaadin.flow.component.orderedlayout.ThemableLayout;\r\nimport com.vaadin.flow.component.textfield.TextField;\r\nimport com.vaadin.flow.data.provider.ListDataProvider;\r\nimport com.vaadin.flow.data.provider.Query;\r\nimport com.vaadin.flow.data.renderer.TemplateRenderer;\r\nimport com.vaadin.flow.function.SerializableConsumer;\r\nimport com.vaadin.flow.function.ValueProvider;\r\nimport dev.mett.vaadin.tooltip.Tooltips;\r\nimport dev.mett.vaadin.tooltip.config.TC_FOLLOW_CURSOR;\r\nimport dev.mett.vaadin.tooltip.config.TC_HIDE_ON_CLICK;\r\nimport dev.mett.vaadin.tooltip.config.TooltipConfiguration;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.commons.lang3.StringUtils;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.text.DecimalFormat;\r\nimport java.text.NumberFormat;\r\nimport java.time.LocalDate;\r\nimport java.util.*;\r\n\r\n@Slf4j\r\npublic class CompUtils {\r\n\r\n    private CompUtils() {\r\n\r\n    }\r\n\r\n    /**\r\n     * The getDirection function returns an icon that represents the direction of a filter.\r\n     *\r\n     * @param Filterbase filter Get the direction of the filter\r\n     * @return An icon\r\n     */\r\n    public static Component getDirection(Filterbase filter) {\r\n        Icon result = null;\r\n        if (filter.getDirection() == Filterbase.ADD || filter.getDirection() == Filterbase.ADD_INDIVIDUAL) {\r\n            result = VaadinIcon.PLUS.create();\r\n        } else {\r\n            result = VaadinIcon.MINUS.create();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The isLocked function returns a Vaadin Icon component that indicates whether the file is locked or not.\r\n     *\r\n     * @param Context    ctx Access the parameters of the file\r\n     * @param Assortment file Get the parameter value from the file\r\n     * @return The lock icon\r\n     */\r\n    public static Component isLocked(Context ctx, Assortment file) {\r\n        Icon result = null;\r\n        Boolean lock = CompUtils.getParameter(ctx, FileParam.LOCK, file);\r\n\r\n        if (Objects.nonNull(lock) && lock.equals(Boolean.TRUE)) {\r\n            result = VaadinIcon.LOCK.create();\r\n        } else {\r\n            result = VaadinIcon.UNLOCK.create();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The priceCompare function compares two prices and returns an integer value.\r\n     *\r\n     * @param String price1 Convert the price to a double and then compare it to the second parameter\r\n     * @param String price2 Compare the price of two items\r\n     * @return A negative number if the first price is less than the second,\r\n     */\r\n    public static int priceCompare(String price1, String price2) {\r\n        Double p1 = Parse.toDouble(price1);\r\n        Double p2 = Parse.toDouble(price2);\r\n        return p1.compareTo(p2);\r\n    }\r\n\r\n    /**\r\n     * Function remove Margin / Spacing / Padding from giving Layout\r\n     *\r\n     * @param layout   <br>\r\n     *                 Horizontal / Vertical Layout\r\n     * @param toRemove <br>\r\n     *                 -M = Margin:\"false\"<br>\r\n     *                 -P = Padding:\"false\"<br>\r\n     *                 -S = Spacing:\"false\"\r\n     */\r\n    public static void removeMSP(ThemableLayout layout, String toRemove) {\r\n        if (toRemove.contains(\"M\")) {\r\n            layout.setMargin(false);\r\n        }\r\n        if (toRemove.contains(\"S\")) {\r\n            layout.setSpacing(false);\r\n        }\r\n        if (toRemove.contains(\"P\")) {\r\n            layout.setPadding(false);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * The sortFilterBase function sorts the list of Filterbase objects by direction, type, and label.\r\n     *\r\n     * @param List&lt;Filterbase&gt; sortable Pass in a list of filterbase objects that are to be sorted\r\n     * @return A list of filterbase objects sorted by direction, type and label\r\n     * @docauthor Trelent\r\n     */\r\n    public static void sortFilterBase(List<Filterbase> sortable) {\r\n        sortable.sort((o1, o2) -> {\r\n            Integer d1 = o1.getDirection();\r\n            Integer d2 = o2.getDirection();\r\n\r\n            Integer result = d2.compareTo(d1);\r\n            if (result != 0)\r\n                return result;\r\n\r\n            result = o1.getType().compareTo(o2.getType());\r\n            if (result != 0)\r\n                return result;\r\n\r\n            return o1.getLabel().compareTo(o2.getLabel());\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Addline for infoBox with 1 Value\r\n     *\r\n     * <span>Translated:header</span><span>Space</span><span>Value</span>\r\n     */\r\n    public static HorizontalLayout addLine(Context ctx, String header, Object value, int width, String type) {\r\n        TranslationProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n        HorizontalLayout form = new HorizontalLayout();\r\n        Span text = new Span(String.valueOf(value));\r\n        Span buffer = new Span(\" \");\r\n        buffer.setWidth(\"1px\");\r\n        Span label = new Span(i18n.getTranslation(header, locale, ctx) + \": \");\r\n        label.getStyle().set(\"width\", width + type);\r\n        form.add(label, buffer, text);\r\n        form.setId(header);\r\n        removeMSP(form, \"MP\");\r\n        return form;\r\n    }\r\n\r\n    /**\r\n     * Addline for infoBox with 1 String-Value length(90px)\r\n     *\r\n     * <span>Translated:header</span><span>Space</span><span>Value</span>\r\n     */\r\n    public static HorizontalLayout addLine(Context ctx, String header, Integer value) {\r\n        return addLine(ctx, header, value, 90, \"px\");\r\n    }\r\n\r\n    /**\r\n     * Addline for infoBox with 1 Integer-Value length(90px)\r\n     *\r\n     * <span>Translated:header</span><span>Space</span><span>Value</span>\r\n     */\r\n    public static HorizontalLayout addLine(Context ctx, String header, String value) {\r\n        return addLine(ctx, header, value, 90, \"px\");\r\n    }\r\n\r\n    /**\r\n     * Addline for infoBox with 2 Header 1 String-Value length(90px)\r\n     *\r\n     * <span>Translated:header</span><span>Space</span><span>Value</span>\r\n     */\r\n    public static HorizontalLayout addLine(Context ctx, String header1, String header2, String value) {\r\n        TranslationProvider i18n = ctx.getServices().getTranslationService();\r\n        Locale locale = ctx.getSession().getLocale(ctx);\r\n        HorizontalLayout form = new HorizontalLayout();\r\n        Span text = new Span(value);\r\n        Span buffer = new Span(\" \");\r\n        buffer.setWidth(\"1px\");\r\n        Span label = new Span(\r\n                i18n.getTranslation(header1, locale, ctx) + \" / \" + i18n.getTranslation(header1, locale, ctx) + \": \");\r\n        label.getStyle().set(\"width\", \"90px\");\r\n        form.add(label, buffer, text);\r\n        form.setId(header1 + \"-and-\" + header2);\r\n        removeMSP(form, \"MP\");\r\n        return form;\r\n    }\r\n\r\n    /**\r\n     * Get primary Role of Current User. The Role define the Primary Rights of the\r\n     * Current User\r\n     */\r\n    public static Role getCurrentUserPrimaryRole(Context ctx) {\r\n        Services services = ctx.getServices();\r\n        Role primary = null;\r\n        Optional<User> optUser = services.getUserServices()\r\n                .findByUserId(new SessionUtils(ctx.getServices().getUserServices()).getCurrentUserID(ctx));\r\n        if (optUser.isPresent()) {\r\n            User user = optUser.get();\r\n            if (Objects.isNull(user.getRole())) {\r\n                List<Role> roles = services.getRoleService().findAllInUser(user);\r\n                primary = roles.get(0);\r\n            } else {\r\n                primary = user.getRole();\r\n            }\r\n        }\r\n        return primary;\r\n    }\r\n\r\n    /**\r\n     * The setSessionProjectByCustomerParameter function is used to set the session project by customer parameter.\r\n     *\r\n     * @param final Context ctx Get the user session\r\n     * @return A localcustomer object\r\n     */\r\n    public static LocalCustomer setSessionProjectByCustomerParameter(final Context ctx) {\r\n        LocalCustomer result = null;\r\n        Map<String, List<String>> queryParameters = ctx.getUserSession().get(Params.ACTIVE_PAGE_PARAMETERS);\r\n        if (Objects.nonNull(queryParameters)) {\r\n            List<String> value = queryParameters.get(\"customer\");\r\n            if (Objects.nonNull(value) && !value.isEmpty()) {\r\n                String customerId = value.get(0);\r\n                Optional<LocalCustomer> optCustomer = ctx.getServices().getLocalCustomerCustomService()\r\n                        .findByCustomerNr(customerId);\r\n                if (optCustomer.isPresent())\r\n                    result = optCustomer.get();\r\n                setSessionProjectByCustomer(ctx, result);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Set Active Project by Selected Customer\r\n     */\r\n    public static void setSessionProjectByCustomer(final Context ctx, LocalCustomer localCustomer) {\r\n        Project project = null;\r\n\r\n        if (Objects.nonNull(localCustomer)) {\r\n            project = getProjectByCustomerNr(ctx, localCustomer);\r\n        }\r\n\r\n        Role role = ctx.getHttpAttribute(SessionParams.ACTIVE_ROLE);\r\n        if (Objects.isNull(role))\r\n            role = getCurrentUserPrimaryRole(ctx);\r\n\r\n        // Since AST 2 ProjectRole Each project has a nm relation to Role\r\n        List<ProjectRole> projectRoles = ctx.getServices().getProjectRoleServices().findAllByProjectAndRole(project,\r\n                role);\r\n        projectRoles.removeIf(item -> ctx.getServices().getAstFileService().findAllByProjectRole(item).isEmpty());\r\n        projectRoles.forEach(item ->\r\n                log.debug(item.getId() + \"|\" + item.getProject().getCustomerNr() + \"|\" + item.getRole().getName())\r\n        );\r\n        ProjectRole projectRole = null;\r\n        if (!projectRoles.isEmpty()) {\r\n            projectRole = projectRoles.get(0);\r\n        } else {\r\n            projectRole = new ProjectRole();\r\n            projectRole.setProject(project);\r\n            projectRole.setRole(role);\r\n            projectRole = ctx.getServices().getProjectRoleServices().save(projectRole);\r\n        }\r\n\r\n        ctx.putHttpAttribute(SessionParams.ACTIVE_PROJECT_ROLE, projectRole);\r\n        ctx.putHttpAttribute(SessionParams.ACTIVE_PROJECT, project);\r\n        ctx.putHttpAttribute(SessionParams.ACTIVE_ROLE, role);\r\n        if (Objects.nonNull(ctx.getUserSession())) {\r\n            ctx.getUserSession().put(Params.ACTIVE_CUSTOMER, localCustomer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The getProjectByCustomerNr function takes a Context and LocalCustomer as parameters.\r\n     * It returns a Project object.\r\n     * The function first checks if the project exists in the database by searching for it using its customer number, which is unique to each project.\r\n     * If it does not exist, then it creates a new Project object with that customer number and saves it to the database before returning that newly created Project object.\r\n     *\r\n     * @param Context       ctx Get the services\r\n     * @param LocalCustomer localCustomer Get the customerid from the localcustomer object\r\n     * @return A project object\r\n     */\r\n    private static Project getProjectByCustomerNr(Context ctx, LocalCustomer localCustomer) {\r\n        Project project = null;\r\n        // Get Project\r\n        Optional<Project> optProj = ctx.getServices().getProjectServices()\r\n                .findByCustomerNr(localCustomer.getCustomerId());\r\n        if (!optProj.isPresent()) {\r\n            // if not Exists create new Project\r\n            project = new Project();\r\n            project.setCustomerNr(localCustomer.getCustomerId());\r\n            project = ctx.getServices().getProjectServices().save(project);\r\n        } else {\r\n            project = optProj.get();\r\n        }\r\n        return project;\r\n    }\r\n\r\n    /**\r\n     * INTERNAL GetUser By userID\r\n     */\r\n    private static User getUser(Context ctx, Integer userId) {\r\n        Optional<User> optUser = ctx.getServices().getUserServices().findById(userId);\r\n        if (optUser.isPresent()) {\r\n            return optUser.get();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    /**\r\n     * Get File-parameter of Selected AstFile\r\n     *\r\n     */\r\n    public static <E> E getParameter(Context ctx, FileParam param, AstFile file) {\r\n        Optional<Parameter> optParam = ctx.getServices().getParameterService().findByParamAndFile(param.getName(),\r\n                file);\r\n        E value = null;\r\n\r\n        if (optParam.isPresent()) {\r\n            if (param.getName().endsWith(\"BY\")) {\r\n                if (optParam.get().getValue() instanceof Integer) {\r\n                    value = (E) getUser(ctx, optParam.get().getValue());\r\n                } else {\r\n                    value = optParam.get().getValue();\r\n                }\r\n            } else {\r\n                value = optParam.get().getValue();\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Remove File-parameter of Selected AstFile\r\n     */\r\n    public static void removeParameter(Context ctx, FileParam param, AstFile file) {\r\n        Optional<Parameter> optParam = ctx.getServices().getParameterService().findByParamAndFile(param.getName(),\r\n                file);\r\n        if (optParam.isPresent()) {\r\n            ctx.getServices().getParameterService().delete(optParam.get());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get Current User Language\r\n     * <p>\r\n     * Select LOCALE from AST_USER WHERE USER_ID = ?\r\n     */\r\n    public static Language getUserLanguage(Context ctx) {\r\n        User user = ctx.getSession().getCurrentUser(ctx);\r\n        List<Language> languages = ctx.getServices().getEnumerationService().getAllLanguages();\r\n        Optional<Language> optLang = languages.stream().filter(lang -> lang.getLabel().equals(user.getLocale()))\r\n                .findFirst();\r\n        if (optLang.isPresent()) {\r\n            return optLang.get();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Clone one FileParameter From AstFile to another AstFile\r\n     */\r\n    public static void cloneParameter(Context ctx, FileParam param, AstFile fromFile, AstFile toFile) {\r\n        Object object = getParameter(ctx, param, fromFile);\r\n        if (Objects.nonNull(object))\r\n            setParameter(ctx, param, object, toFile);\r\n    }\r\n\r\n    /**\r\n     * Clone all FileParameter From AstFile to another AstFile\r\n     */\r\n    public static void cloneAllParameter(Context ctx, AstFile fromFile, AstFile toFile) {\r\n        ParameterDAO service = ctx.getServices().getParameterService();\r\n        List<Parameter> parameters = service.findAllByFile(fromFile);\r\n        parameters.forEach(item -> {\r\n            item.setId(0);\r\n            item.setFile(toFile);\r\n        });\r\n        service.saveAll(parameters);\r\n    }\r\n\r\n    /**\r\n     * Set FileParameter of Select AstFile\r\n     */\r\n    public static <E> void setParameter(Context ctx, FileParam param, E value, AstFile file) {\r\n        ParameterDAO service = ctx.getServices().getParameterService();\r\n        Parameter parameter = new Parameter();\r\n        parameter.setParam(param.getName());\r\n        parameter.setFile(file);\r\n        Optional<Parameter> optParam = service.findByParamAndFile(param.getName(), file);\r\n        if (optParam.isPresent()) {\r\n            parameter = optParam.get();\r\n        }\r\n\r\n        if (value instanceof User) {\r\n            try {\r\n                parameter.setValue(((User) value).getId());\r\n            } catch (Exception e) {\r\n                log.error(e.getLocalizedMessage());\r\n                log.debug(e.getLocalizedMessage(), e);\r\n            }\r\n        } else {\r\n            try {\r\n                parameter.setValue(value);\r\n            } catch (Exception e) {\r\n                log.error(e.getLocalizedMessage());\r\n                log.debug(e.getLocalizedMessage(), e);\r\n            }\r\n        }\r\n\r\n        service.save(parameter);\r\n    }\r\n\r\n    /**\r\n     * Get Storage of Selected AstFile\r\n     */\r\n    public static Storage getStorage(Context ctx, AstFile astFile) {\r\n        Optional<Storage> optStorage = ctx.getServices().getStorageService().findByAstFile(astFile);\r\n        Storage storage = null;\r\n        if (optStorage.isPresent()) {\r\n            storage = optStorage.get();\r\n        } else {\r\n            storage = new Storage();\r\n            storage.setAstFile(astFile);\r\n            storage = ctx.getServices().getStorageService().save(storage);\r\n        }\r\n        return storage;\r\n    }\r\n\r\n    /**\r\n     * Save File as Blob for AstFile\r\n     */\r\n    public static void saveStorage(Context ctx, AstFile astFile, File srcFile) {\r\n        Storage storage = CompUtils.getStorage(ctx, astFile);\r\n        try {\r\n            storage.setFileblob(Blob.save(srcFile));\r\n            ctx.getServices().getStorageService().save(storage);\r\n        } catch (IOException e) {\r\n            log.error(\"Could not Save File\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get CatalogVersion from AstFile (optional from Setting)\r\n     */\r\n    public static KatalogVersion getKatalogVersion(Context ctx, AstFile assortment) {\r\n        KatalogVersion katalog = CompUtils.getParameter(ctx, FileParam.KATALOG_VERSION, assortment);\r\n        ObjectType type = CompUtils.getParameter(ctx, FileParam.FILE_TYPE, assortment);\r\n        if (Objects.isNull(katalog)) {\r\n            katalog = getKatalogVersion(ctx, type);\r\n        }\r\n        return katalog;\r\n    }\r\n\r\n    /**\r\n     * The getStartDate function returns the start date of the assortment.\r\n     *\r\n     * @param Context ctx Get the active assortment from the user session\r\n     * @return The value of the valid_from parameter for a given assortment\r\n     */\r\n    public static LocalDate getStartDate(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        return CompUtils.getParameter(ctx, FileParam.VALID_FROM, assortment);\r\n    }\r\n\r\n    /**\r\n     * The getEndDate function returns the end date of the assortment.\r\n     *\r\n     * @param Context ctx Access the user session and to get the active assortment\r\n     * @return The value of the fileparam\r\n     */\r\n    public static LocalDate getEndDate(Context ctx) {\r\n        Assortment assortment = ctx.getUserSession().get(Params.ACTIVE_ASSORTMENT);\r\n        return CompUtils.getParameter(ctx, FileParam.VALID_TO, assortment);\r\n    }\r\n\r\n    /**\r\n     * The checkIfProfilNameExists function checks if the name of a filter already exists in the database.\r\n     *\r\n     * @param Context ctx Get the services\r\n     * @param Filter  bean Check if the id of the bean is 0\r\n     * @param String  name Check if the name of the filter is already present in the database\r\n     * @return A boolean\r\n     */\r\n    public static boolean checkIfProfilNameExists(Context ctx, Filter bean, String name) {\r\n        List<Filter> filters = ctx.getServices().getFilterService().findAll();\r\n        int id = bean.getId();\r\n        boolean isPresent = filters.stream()\r\n                .noneMatch(item -> item.getName().equals(name) && Objects.isNull(item.getDeleteBy()));\r\n        if (id != 0)\r\n            isPresent = true;\r\n        return isPresent;\r\n    }\r\n\r\n    /**\r\n     * The getToolTip function is used to create a tooltip for the given context and tmsName.\r\n     *\r\n     * @param Context ctx Get the current session's locale\r\n     * @param String  tmsName Get the translation of the tooltip\r\n     * @return A tooltipconfiguration object\r\n     */\r\n    public static TooltipConfiguration getToolTip(Context ctx, String tmsName) {\r\n        String name = ctx.getServices().getTranslationService().getTranslation(tmsName, ctx.getSession().getLocale(ctx),\r\n                ctx);\r\n\r\n        TooltipConfiguration ttconfig = new TooltipConfiguration();\r\n        ttconfig.setDuration(null, 20);\r\n        ttconfig.setContent(name);\r\n        ttconfig.setFollowCursor(TC_FOLLOW_CURSOR.HORIZONTAL);\r\n        ttconfig.setHideOnClick(TC_HIDE_ON_CLICK.FALSE);\r\n        ttconfig.setShowOnCreate(false);\r\n\r\n        return ttconfig;\r\n    }\r\n\r\n    /**\r\n     * The reloadToolTips function is used to reload the tooltips for all components that have a tooltip.\r\n     * This function is called when the user changes their language preference, and it will update all of\r\n     * the tooltips on every page to reflect this change. It does so by iterating through each component in\r\n     * a map of components with tooltips, and then calling setTooltip() on each one. The setTooltip() method\r\n     * uses an enum value (which corresponds to a key in our properties file) as its parameter, which allows us\r\n     * to easily change what text appears in our tooltip based on what language we are\r\n     *\r\n     * @param Context ctx Get the map of tooltips from the context\r\n     */\r\n    public static <T extends Component & HasStyle> void reloadToolTips(Context ctx) {\r\n        Map<Tooltips, Map<T, String>> tooltips = ctx.getHttpAttribute(CTXAttribute.TOOLTIP_CONTROL);\r\n        if (Objects.nonNull(tooltips)) {\r\n            tooltips.forEach((item, comps) ->\r\n                    comps.forEach(item::setTooltip)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The addToolTip function adds a tooltip to the component passed in as an argument.\r\n     * The tooltip is retrieved from the translation service using the tmsName parameter.\r\n     * If no translation exists for that name, then nothing happens and no error is thrown.\r\n     *\r\n     * @param Context ctx Get the translation service and session\r\n     * @param T       comp Identify the component to which the tooltip will be added\r\n     * @param String  tmsName Retrieve the translation from the tms\r\n     */\r\n    public static <T extends Component & HasStyle> void addToolTip(Context ctx, T comp, String tmsName) {\r\n        try {\r\n            log.debug(\"[\" + comp.getClass().getSimpleName() + \"] \" + tmsName);\r\n            String name = ctx.getServices().getTranslationService().getTranslation(tmsName,\r\n                    ctx.getSession().getLocale(ctx), ctx);\r\n            if (!name.equals(\"EMPTY\") && !name.isEmpty()) {\r\n                TooltipConfiguration ttconfig = new TooltipConfiguration();\r\n                ttconfig.setDuration(0, 20);\r\n                ttconfig.setContent(name);\r\n                ttconfig.setShowOnCreate(true);\r\n                ttconfig.setFollowCursor(TC_FOLLOW_CURSOR.HORIZONTAL);\r\n                ttconfig.setHideOnClick(TC_HIDE_ON_CLICK.FALSE);\r\n                ttconfig.setShowOnCreate(false);\r\n\r\n                Tooltips current = ctx.getUserSession().get(Params.ACTIVE_TOOL_TIP);\r\n                if (Objects.isNull(current)) {\r\n                    current = Tooltips.getCurrent();\r\n                    ctx.getUserSession().put(Params.ACTIVE_TOOL_TIP, current);\r\n                }\r\n\r\n                current.setTooltip(comp, ttconfig);\r\n                Map<Tooltips, Map<T, String>> tooltips = ctx.getHttpAttribute(CTXAttribute.TOOLTIP_CONTROL);\r\n                if (Objects.isNull(tooltips)) {\r\n                    tooltips = new HashMap<>();\r\n                }\r\n                Map<T, String> comps = new HashMap<>();\r\n                comps.put(comp, name);\r\n                tooltips.put(current, comps);\r\n            }\r\n        } catch (NullPointerException e) {\r\n            log.error(\"[\" + e.getClass().getSimpleName() + \"] \" + e.getLocalizedMessage());\r\n        } catch (Exception e) {\r\n            log.error(\"[\" + e.getClass().getSimpleName() + \"] \" + e.getLocalizedMessage(), e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The addColumnToolTip function is used to add a tooltip to the column header of a table.\r\n     * The function takes in two parameters:\r\n     *\r\n     * @param Context ctx Get the current session locale\r\n     * @param String  value Set the value of the column\r\n     * @param String  tmsName Get the translation from a tms\r\n     *                &lt;/code&gt;\r\n     * @return A span\r\n     */\r\n    public static Component addColumnToolTip(Context ctx, String value, String tmsName) {\r\n        String name = value;\r\n        if (!tmsName.isEmpty())\r\n            name = ctx.getServices().getTranslationService().getTranslation(tmsName, ctx.getSession().getLocale(ctx),\r\n                    ctx);\r\n        TooltipConfiguration ttconfig = new TooltipConfiguration();\r\n        ttconfig.setDuration(null, 20);\r\n        if (name.isEmpty())\r\n            name = \"(WIP) EMPTY\";\r\n        ttconfig.setContent(name);\r\n        ttconfig.setFollowCursor(TC_FOLLOW_CURSOR.HORIZONTAL);\r\n        ttconfig.setHideOnClick(TC_HIDE_ON_CLICK.FALSE);\r\n        ttconfig.setShowOnCreate(false);\r\n        Span column = new Span(value);\r\n\r\n        Tooltips.getCurrent().setTooltip(column, ttconfig);\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * The getPanelHeader function returns a Paragraph object with the text of the name parameter,\r\n     * translated into the locale specified by the locale parameter. The paragraph is styled to be\r\n     * used as a header for panels in this application. The Context ctx parameter is required so that\r\n     * we can use it to get access to services such as translation service and configuration service.\r\n     *\r\n     * @param String  name Get the translation of the header text\r\n     * @param Locale  locale Get the translation of the name parameter\r\n     * @param Context ctx Get the translation service\r\n     * @return A paragraph object\r\n     */\r\n    public static Paragraph getPanelHeader(String name, Locale locale, Context ctx) {\r\n        Paragraph p = new Paragraph();\r\n        p.setText(ctx.getServices().getTranslationService().getTranslation(name, locale, ctx));\r\n        p.setId(\"panel-header\");\r\n        p.getStyle().set(\"margin-top\", \"0.75em\");\r\n        p.getStyle().set(\"margin-bottom\", \"-1.0em\");\r\n        p.getStyle().set(\"text-align\", \"center\");\r\n        p.getStyle().set(\"font-size\", \"1.1em\");\r\n        p.getStyle().set(\"font-weight\", \"500\");\r\n        p.setWidth(\"100%\");\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * The createDialogHeader function creates a Paragraph element with the following properties:\r\n     * - id = &quot;panel-header&quot;\r\n     * - margin-top = &quot;-0.3em&quot;\r\n     * - margin-bottom = &quot;-0.2em&quot;\r\n     * - text align center (horizontally)\r\n     * - font size 1.5 ems (relative to default browser font size) and weight 500 (bold).\r\n     *\r\n     * @return A paragraph object\r\n     */\r\n    public static Paragraph createDialogHeader() {\r\n        Paragraph p = new Paragraph();\r\n        p.setId(\"panel-header\");\r\n        p.getStyle().set(\"margin-top\", \"-1.3em\");\r\n        p.getStyle().set(\"margin-bottom\", \"-0.2em\");\r\n        p.getStyle().set(\"text-align\", \"center\");\r\n        p.getStyle().set(\"font-size\", \"1.1em\");\r\n        p.getStyle().set(\"font-weight\", \"500\");\r\n        p.setWidth(\"100%\");\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * The getBannerImage function returns an Image object that is used to display the banner image on the home page.\r\n     * The function first checks if a custom banner image has been uploaded by checking for a setting with type MAINTENANCE_BANNER_IMAGE.\r\n     * If such a setting exists, then it will check if the file path specified in this setting actually points to an existing file.\r\n     * If so, then it will return an Image object with its path set to HOM_CUSTOM_BANNER and its name set to &quot;Custom Banner&quot;.  Otherwise, it will return an Image object with its path set to\r\n     *\r\n     * @param Context ctx Get the setting from the database\r\n     * @return An image object\r\n     */\r\n    public static Image getBannerImage(Context ctx) {\r\n        Setting setting = SettingUtils.getSettingByType(ctx, SettingType.MAINTENANCE_BANNER_IMAGE);\r\n        String path = \"\";\r\n\r\n        if (Objects.nonNull(setting) && !setting.getValue().isEmpty()) {\r\n            path = IconImage.HOM_CUSTOM_BANNER.getPath();\r\n            String fPath = setting.getValue();\r\n            File iExists = new File(fPath);\r\n            if (!iExists.exists()) {\r\n                path = IconImage.HOM_BANNER.getPath();\r\n            }\r\n        } else {\r\n            path = IconImage.HOM_BANNER.getPath();\r\n        }\r\n        return new Image(path, IconImage.HOM_BANNER.getName());\r\n    }\r\n\r\n    /**\r\n     * The getSaveFloppy function returns an Image object that represents the floppy disk icon.\r\n     * The image is either the default or a custom one, depending on whether a custom image has been set in settings.\r\n     *\r\n     * @param Context ctx Get the setting object from the database\r\n     * @return The image object\r\n     */\r\n    public static Image getSaveFloppy(Context ctx) {\r\n        Setting setting = SettingUtils.getSettingByType(ctx, SettingType.MAINTENANCE_SAVE_IMAGE);\r\n        String path = IconImage.HOM_CUSTOM_FLOPPY.getPath();\r\n        if (Objects.nonNull(setting) && !setting.getValue().isEmpty()) {\r\n            String fPath = setting.getValue();\r\n            File iExists = new File(fPath);\r\n            if (!iExists.exists()) {\r\n                path = IconImage.FLOPPY.getPath();\r\n            }\r\n        }\r\n        return new Image(path, IconImage.FLOPPY.getName());\r\n    }\r\n\r\n    /**\r\n     * The getDisableSaveFloppy function returns the image for the disabled save floppy icon.\r\n     *\r\n     * @param Context ctx Get the setting from the database\r\n     * @return The path of the image\r\n     */\r\n    public static Image getDisableSaveFloppy(Context ctx) {\r\n        String path = IconImage.HOM_CUSTOM_FLOPPY_DISABLE.getPath();\r\n        Image img = new Image(path, IconImage.FLOPPY_DISABLE.getName());\r\n        try {\r\n            Setting setting = SettingUtils.getSettingByType(ctx, SettingType.MAINTENANCE_SAVE_DISABLED_IMAGE);\r\n            if (!setting.getValue().isEmpty()) {\r\n                String fPath = setting.getValue();\r\n                File iExists = new File(fPath);\r\n                if (!iExists.exists()) {\r\n                    path = IconImage.FLOPPY_DISABLE.getPath();\r\n                }\r\n            }\r\n            img = new Image(path, IconImage.FLOPPY_DISABLE.getName());\r\n        } catch (NullPointerException e) {\r\n            log.error(\"Could load DisableFloppy Image\");\r\n        }\r\n        return img;\r\n    }\r\n\r\n    /**\r\n     * The getInterDim function returns an Image object that is used to display the\r\n     * image of a maintenance worker in the Maintenance Progress screen. The function\r\n     * first checks if there is a custom image set for this purpose, and if so it uses that. If not,\r\n     * it uses the default icon instead. This function also handles cases where the user has deleted or moved\r\n     * their custom image file after setting it as such in Settings (in which case we use our default icon).\r\n     *\r\n     * @param Context ctx Get the setting from the database\r\n     * @return a Image Object\r\n     */\r\n    public static Image getInterDim(Context ctx) {\r\n        Setting setting = SettingUtils.getSettingByType(ctx, SettingType.MAINTENANCE_PROGRESS_IMAGE);\r\n        String path = \"\";\r\n\r\n        if (Objects.nonNull(setting) && !setting.getValue().isEmpty()) {\r\n            path = IconImage.HOM_CUSTOM.getPath();\r\n            String fPath = setting.getValue();\r\n            File iExists = new File(fPath);\r\n            if (!iExists.exists()) {\r\n                path = IconImage.HOM_MAN.getPath();\r\n            }\r\n        } else {\r\n            path = IconImage.HOM_MAN.getPath();\r\n        }\r\n        return new Image(path, IconImage.HOM_MAN.getName());\r\n    }\r\n\r\n    /**\r\n     * The filterGridObjects function is used to filter the objects in a grid.\r\n     *\r\n     * @param Context       ctx Access the translationprovider\r\n     * @param Grid&lt;T&gt; grid Get the data provider\r\n     * @return String List of FilterObjects\r\n     */\r\n    public static <T> String filterGridObjects(Context ctx, Grid<T> grid) {\r\n        String returnValue = \"\";\r\n        Locale curLocale = null;\r\n        try {\r\n            TranslationProvider translate = ctx.getServices().getTranslationService();\r\n            @SuppressWarnings({\"unchecked\"})\r\n            ListDataProvider<T> listProvider = (ListDataProvider<T>) grid.getDataProvider();\r\n            int filteredSize = listProvider.size(new Query<>(listProvider.getFilter()));\r\n            int fullSize = listProvider.getItems().size();\r\n            if (filteredSize != fullSize) {\r\n                curLocale = ctx.getUserSession().get(Params.ACTIVE_LOCALE);\r\n\r\n                String tmsString = translate.getTranslation(TMS.FOUND_RESULTS_X, curLocale, ctx);\r\n\r\n                if (!tmsString.contains(\"0\") && !tmsString.contains(\"1\")) {\r\n                    returnValue = String.format(tmsString);\r\n                } else if (!tmsString.contains(\"1\")) {\r\n                    returnValue = String.format(tmsString.replace(\"{0}\", \"%s\"), filteredSize);\r\n                } else {\r\n                    returnValue = String.format(tmsString.replace(\"{0}\", \"%s\").replace(\"{1}\", \"%s\"), filteredSize,\r\n                            fullSize);\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            returnValue = \"\";\r\n        }\r\n        return returnValue;\r\n    }\r\n\r\n    /**\r\n     * The searchWithParameters function is used to search for a string in another string.\r\n     * The function takes two parameters: the value and the fieldTxt.\r\n     * The value parameter is an object that contains a String, which will be searched through.\r\n     * The fieldTxt parameter is a TextField object that contains the text to be searched for within the value String.\r\n     *\r\n     * @param Object    value Determine the type of object that is being searched\r\n     * @param TextField fieldTxt Get the value of the textfield\r\n     * @return True if the search value is found in the name\r\n     */\r\n    public static boolean searchWithParameters(Object value, TextField fieldTxt) {\r\n        boolean result = false;\r\n        String searchPattern = \"'~'\";\r\n        if (value instanceof String) {\r\n            String name = (String) value;\r\n            String nameLower = name == null ? \"\" : name.toLowerCase(Locale.ENGLISH);\r\n            String search = fieldTxt.getValue();\r\n            log.debug(\"SearchValue:\" + search + \"SearchIn:\" + nameLower);\r\n            search = search.replace(\"*\", searchPattern).toLowerCase(Locale.ENGLISH);\r\n            if (search.contains(searchPattern) && !search.replace(searchPattern, \"\").isEmpty()) {\r\n                String[] searchs = search.split(searchPattern);\r\n                int length = searchs.length;\r\n                boolean isStartNameLower = nameLower.startsWith(searchs[0]);\r\n                boolean isEndNameLower = nameLower.endsWith(searchs[length - 1]);\r\n                boolean isSearchContainsArray = searchContainsArray(searchs, nameLower);\r\n                // SearchText*SearchText\r\n                if (!search.endsWith(searchPattern) && !search.startsWith(searchPattern)) {\r\n                    result = isSearchContainsArray && isEndNameLower && isStartNameLower;\r\n                    // *SearchText*\r\n                } else if (search.startsWith(searchPattern) && search.endsWith(searchPattern)) {\r\n                    result = isSearchContainsArray;\r\n                    // SearchText*\r\n                } else if (search.endsWith(searchPattern)) {\r\n                    result = isSearchContainsArray && isStartNameLower;\r\n                    // *SearchText\r\n                } else if (search.startsWith(searchPattern)) {\r\n                    result = isSearchContainsArray && isEndNameLower;\r\n                }\r\n            } else {// SearchText\r\n                result = nameLower.contains(search);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * The searchContainsArray function takes in a String array and a String as parameters.\r\n     * It then searches the string for each element of the array, returning true if all elements are found.\r\n     *\r\n     * @param String[] searchs Store the search terms that are to be searched for in the string input parameter\r\n     * @param String   inPut Store the input from the user\r\n     * @return A boolean value\r\n     */\r\n    private static boolean searchContainsArray(String[] searchs, String inPut) {\r\n        int i = 0;\r\n        int isValid = 0;\r\n        String buffer = inPut;\r\n        for (i = 0; i < searchs.length; i++) {\r\n            if (buffer.indexOf(searchs[i]) != -1) {\r\n                buffer = buffer.substring(buffer.indexOf(searchs[i]));\r\n                if (!buffer.isEmpty()) {\r\n                    isValid++;\r\n                }\r\n            }\r\n        }\r\n        return i == isValid;\r\n    }\r\n\r\n    /**\r\n     * The getSearchField function is a helper function that returns a TextField object.\r\n     * The TextField object has the following properties:\r\n     * - It has an empty placeholder text, which will be replaced by the translation of TMS.PREVIEW_SEARCH_PLACEHOLDER in the current locale of ctx's session;\r\n     * - It adds a ValueChangeListener to itself, which filters grid's data provider with CompUtils.searchWithParameters(value, fieldTxt) and then sets it as grid's data provider;\r\n     *\r\n     * @param Context            ctx Get the current locale of the user\r\n     * @param Grid&lt;E&gt;      grid Get the data provider of the grid and set it again after filtering\r\n     * @param ValueProvider&lt;E Get the value of a specific column in the grid\r\n     * @param V&gt;              provider Specify the type of data that will be searched for\r\n     * @return A textfield with a placeholder and an event listener\r\n     */\r\n    public static <E, V> TextField getSearchField(Context ctx, Grid<E> grid, ValueProvider<E, V> provider) {\r\n        TextField fieldTxt = new TextField();\r\n        Locale locale = ctx.getSession().getCurrentLocale(ctx);\r\n        fieldTxt.setPlaceholder(\r\n                ctx.getServices().getTranslationService().getTranslation(TMS.PREVIEW_SEARCH_PLACEHOLDER, locale, ctx));\r\n        fieldTxt.addValueChangeListener(event -> {\r\n            @SuppressWarnings(\"unchecked\")\r\n            ListDataProvider<E> listProvider = (ListDataProvider<E>) grid.getDataProvider();\r\n            listProvider.setFilter(provider, value -> CompUtils.searchWithParameters(value, fieldTxt));\r\n            listProvider.getItems().size();\r\n            grid.setDataProvider(listProvider);\r\n        });\r\n\r\n        return fieldTxt;\r\n    }\r\n\r\n    public static void getComponentPosition(Component comp, SerializableConsumer<Position> consumer) {\r\n        comp.getElement()\r\n                .executeJs(\r\n                        \"return [\" + \"this.getBoundingClientRect()['top'] , this.getBoundingClientRect()['left']\" + \"]\")\r\n                .then(String.class, s -> {\r\n                    String[] split = StringUtils.split(s, ',');\r\n                    if (split.length == 2 && Objects.nonNull(split[0]) && Objects.nonNull(split[1])) {\r\n                        Position position = new Position(split[0], split[1]);\r\n                        consumer.accept(position);\r\n                    }\r\n                });\r\n    }\r\n\r\n    public static void getComponentBoundingBox(Component comp, SerializableConsumer<BoundingBox> consumer) {\r\n        comp.getElement().executeJs(\"return [\"\r\n                + \"this.getBoundingClientRect()['right']+window.scrollX,this.getBoundingClientRect()['left']+window.scrollX,\"\r\n                + \"this.getBoundingClientRect()['top']+window.scrollY,this.getBoundingClientRect()['bottom']+window.scrollY,\"\r\n                + \"this.getBoundingClientRect()['width'],this.getBoundingClientRect()['height'],\"\r\n                + \"this.getBoundingClientRect()['x'],this.getBoundingClientRect()['y']\" + \"]\").then(String.class, s -> {\r\n            String[] split = StringUtils.split(s, ',');\r\n            if (split.length == 8) {\r\n                boolean valid = true;\r\n                for (String obj : split) {\r\n                    valid = Objects.nonNull(obj);\r\n                    if (!valid)\r\n                        break;\r\n                }\r\n                if (valid) {\r\n                    BoundingBox box = new BoundingBox(split[0], split[1], split[2], split[3], split[4],\r\n                            split[5], split[6], split[7]);\r\n                    consumer.accept(box);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public static KatalogVersion getKatalogVersion(Context ctx, ObjectType type) {\r\n        Setting sKatalogVersion = SettingUtils.getSettingByType(ctx, SettingType.DEFAULT_CATALOGVERSION);\r\n        String value = sKatalogVersion.getValue();\r\n        if (value.contains(\"#\")) {\r\n            switch (type) {\r\n                case IMPEX:\r\n                case IMPEX_IMPORT:\r\n                case IMPEX_INPUT:\r\n                    value = value.split(\"#\")[1];\r\n                    break;\r\n                default:\r\n                case ECAT:\r\n                case ECAT_IMPORT:\r\n                case ECAT_INPUT:\r\n                    value = value.split(\"#\")[0];\r\n                    break;\r\n            }\r\n        }\r\n        Optional<SettingParameter<KatalogVersion>> optParam;\r\n        if (value.contains(\"[\")) {\r\n            value = value.replace(\"[\", \"#\");\r\n            value = value.replace(\"]\", \"\");\r\n            value = value.split(\"#\")[1];\r\n            int id = Parse.toInt(value);\r\n            optParam = ctx.getServices().getSettingCustomServices().findById(id);\r\n        } else {\r\n            optParam = ctx.getServices().getSettingParameterService().findByParamAndSetting(value, sKatalogVersion);\r\n        }\r\n\r\n        return optParam.get().getValue();\r\n    }\r\n\r\n    public static String formatToPrice(String price) {\r\n        return formatToPrice(price, Locale.GERMAN);\r\n    }\r\n\r\n    public static String formatToPrice(String price, String localeIso) {\r\n        Locale locale = Locale.forLanguageTag(localeIso);\r\n        return formatToPrice(price, locale);\r\n    }\r\n\r\n    public static String formatToPrice(String price, Locale locale) {\r\n        double dValue = Parse.toDouble(price);\r\n        String pattern = \"#,##0.00\";\r\n        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(locale);\r\n        df.applyPattern(pattern);\r\n        return df.format(dValue);\r\n    }\r\n\r\n    public static <E, T> TemplateRenderer<E> priceFormatTemplate(ValueProvider<E, ?> value) {\r\n        return TemplateRenderer.<E>of(\"<span> [[item.value]] </span>\").withProperty(\"value\", value);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\CompUtils.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\constans\\ASTConst.java =====\n```\npackage com.hom.ebmw.utilities.constans;\r\n\r\npublic class ASTConst {\r\n\r\n\r\n    public static final String FILTER_GLB = \"GLB_\";\r\n    public static final String FILTER_PRV = \"PRV_\";\r\n    public static final String FILTER_ADM = \"ADM_\";\r\n    public static final String FILTER_TEAM = \"TM__\";\r\n\r\n    public static final String CUSTOMERFILEHEADER = \"Name\\tKennung\\tPostleitzahl\\tLand\\tNiederlassung\\tStrae\\teBusiness\\tOrt\\tSprache\\tPreisliste\\tWhrung\\tKundengruppe\";\r\n    public static final String TAB = \"\\t\";\r\n    public static final String NL = \"\\n\";\r\n    public static final String CLF = \"\\r\";\r\n\r\n    public static final String EMPTY = \"\";\r\n    public static final String DEFAULT = \"\";\r\n\r\n\r\n    public static final String DB_DELIMITER = \"#\";\r\n    public static final String IPIM_DELIMITER = \"#\";\r\n\r\n    public static final String PROMOTION_CUSTOMER = \"AST_PROM_CUSTOMER\";\r\n    public static final String FAKE = \"FAKE\";\r\n\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\constans\\ASTConst.java =====\n\n===== BEGIN FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\constans\\Table.java =====\n```\npackage com.hom.ebmw.utilities.constans;\r\n\r\nimport java.text.DecimalFormat;\r\n\r\npublic class Table {\r\n    public static final String MAIN = \"main\";\r\n    public static final String TEMP = \"temp\";\r\n\r\n    public static final String getTemp(int id) {\r\n        DecimalFormat df = new DecimalFormat(\"00\");\r\n        return TEMP + \"-\" + df.format(id);\r\n    }\r\n}\r\n\n```\n===== END FILE: C:\\Users\\mtheele\\IdeaProjects\\TIP - Assortmenttool_2\\src\\main\\java\\com\\hom\\ebmw\\utilities\\constans\\Table.java =====\n\n"
  },
  "response" : {
    "id" : "chatcmpl-KHi7xHw7zso4Y9pTo5JIE6TwzV7ikzX8",
    "created" : 1762170958,
    "model" : "gpt-oss:120b",
    "object" : "chat.completion",
    "system_fingerprint" : "b1-b0d5299",
    "choices" : [ {
      "finish_reason" : "stop",
      "index" : 0,
      "message" : {
        "content" : "{\n  \"file\": \"multiple (ArticleBaseQueueUtils.java, AssortmentUtil.java, AstNotification.java, Base.java, Blob.java, CompUtils.java, ASTConst.java, Table.java)\",\n  \"issues\": [\n    {\n      \"severity\": \"High\",\n      \"problem\": \"Potential NullPointerException in proofArticleBase() when ArticleBase.getComment() returns null.\",\n      \"justification\": \"Calling contains() on a null comment throws NPE, causing request failures and destabilizing the PIM view.\",\n      \"action\": \"Add null-check for item.getComment() before calling contains(); ensure method returns false for null comments. Add unit test covering null comment case.\",\n      \"source\": \"AssortmentUtil.proofArticleBase, line ~120\",\n      \"component\": \"article-validation\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"item.getComment().contains(...) may NPE\"\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"removeUnwantedFromList() does not validate the incoming collection, leading to NPE if null is passed.\",\n      \"justification\": \"Method can be called with a null collection, causing a runtime exception and breaking downstream processing.\",\n      \"action\": \"Check if articles is null; if so return empty list. Add defensive copy and nullsafe handling. Include test for null input.\",\n      \"source\": \"AssortmentUtil.removeUnwantedFromList, line ~85\",\n      \"component\": \"article-filter\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"filtered.addAll(articles) will NPE when articles is null\"\n    },\n    {\n      \"severity\": \"High\",\n      \"problem\": \"CompUtils.getKatalogVersion(Context, ObjectType) assumes a Setting exists and calls getValue() without nullcheck.\",\n      \"justification\": \"If the setting is missing, a NullPointerException propagates, breaking catalogue version resolution.\",\n      \"action\": \"Validate that SettingUtils.getSettingByType returns nonnull; fallback to a default KatalogVersion or throw a controlled exception. Add tests for missing setting scenario.\",\n      \"source\": \"CompUtils.getKatalogVersion (overloaded), line ~780\",\n      \"component\": \"catalog-version\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"Setting sKatalogVersion may be null, then sKatalogVersion.getValue() NPE\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"CompUtils.getDirection() may throw NPE if filter or filter.getDirection() is null.\",\n      \"justification\": \"Utility is used for UI rendering; a null filter leads to server error and UI breakage.\",\n      \"action\": \"Add null checks for filter and its direction; return a default icon or null. Add unit test for null filter.\",\n      \"source\": \"CompUtils.getDirection, line ~40\",\n      \"component\": \"ui-icons\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"Icon result = null; if filter is null, filter.getDirection() throws NPE\"\n    },\n    {\n      \"severity\": \"Med\",\n      \"problem\": \"CompUtils.searchWithParameters() does not verify that TextField argument is nonnull.\",\n      \"justification\": \"When called with a null TextField (e.g., during programmatic search), getValue() raises NPE, halting search functionality.\",\n      \"action\": \"Guard against null fieldTxt; treat null as empty search string. Document expected behavior and add tests for null TextField.\",\n      \"source\": \"CompUtils.searchWithParameters, line ~530\",\n      \"component\": \"grid-search\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"fieldTxt.getValue() without null check\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Zip method checks zipFile for nonnull (always true) but does not verify creation or existence before compressing.\",\n      \"justification\": \"If temp folder is not writable, compress may fail and the method silently returns a nonexistent file.\",\n      \"action\": \"Validate that zipFile can be created (e.g., Files.createFile) and handle IOException appropriately. Add test for unwritable directory.\",\n      \"source\": \"AssortmentUtil.zip, line ~430\",\n      \"component\": \"file-zip\",\n      \"impact_scope\": \"performancecritical\",\n      \"relations\": null,\n      \"evidence\": \"if (Objects.nonNull(zipFile)) { ... } always true\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Static utility classes are not threadsafe; they manipulate Context which may be shared across threads.\",\n      \"justification\": \"Concurrent requests could lead to race conditions on session maps, causing data leakage or inconsistent state.\",\n      \"action\": \"Document that methods must be called with threadconfined Context or synchronize critical sections. Consider redesigning to instancebased services. Add concurrency tests.\",\n      \"source\": \"All utility classes, e.g., ArticleBaseQueueUtils.resetUserQueues\",\n      \"component\": \"thread-safety\",\n      \"impact_scope\": \"prod-relevant\",\n      \"relations\": null,\n      \"evidence\": \"static methods modify ctx.getUserSession() maps without synchronization\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"File paths are built by concatenating userprovided names without validation, risking pathtraversal attacks.\",\n      \"justification\": \"An attacker could inject '../' sequences in assortment or file names, leading to arbitrary file access on the server.\",\n      \"action\": \"Sanitize file and folder names (e.g., reject '..' or use java.nio.file.Path.normalize). Add security tests for malicious filenames.\",\n      \"source\": \"AssortmentUtil.getEcatFiles / getImpexFiles, lines ~210230\",\n      \"component\": \"file-io\",\n      \"impact_scope\": \"securitycritical\",\n      \"relations\": null,\n      \"evidence\": \"new File(SettingUtils.getTempFolder(ctx) + File.separator + assortment.getName())\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Base.encode64/decode64 instantiate a new Base64 object on each call; also use of deprecated Apache Commons codec class.\",\n      \"justification\": \"Unnecessary object creation and reliance on deprecated API may affect performance and future compatibility.\",\n      \"action\": \"Replace with java.util.Base64 (standard library) which is threadsafe and avoids object allocation. Add regression tests.\",\n      \"source\": \"Base.encode64 / decode64, lines ~1022\",\n      \"component\": \"encoding\",\n      \"impact_scope\": \"performancecritical\",\n      \"relations\": null,\n      \"evidence\": \"new Base64() each call\"\n    },\n    {\n      \"severity\": \"Low\",\n      \"problem\": \"Blob.compress() and decompress() log sizes in kilobytes using integer division, losing precision and potentially misleading logs.\",\n      \"justification\": \"Logs are used for monitoring; inaccurate size information hampers troubleshooting.\",\n      \"action\": \"Log actual byte counts or use double division to retain decimal part. Update logging statements and add tests verifying log output format.\",\n      \"source\": \"Blob.compress / decompress, lines ~7085\",\n      \"component\": \"logging\",\n      \"impact_scope\": null,\n      \"relations\": null,\n      \"evidence\": \"LOG.info(\\\"Original: \\\" + data.length / 1024 + \\\" Kb\\\")\"\n    }\n  ],\n  \"summary\": {\n    \"overall_rating\": \"2\",\n    \"top_todos\": [\n      \"Add nullchecks for comments in proofArticleBase and collections in removeUnwantedFromList.\",\n      \"Validate existence of Setting before accessing its value in CompUtils.getKatalogVersion.\",\n      \"Sanitize file names used for temporary and export files to prevent pathtraversal.\"\n    ]\n  }\n}",
        "role" : "assistant",
        "reasoning_content" : "We need to produce JSON review for each file? The schema expects a single file field. Possibly combine multiple? Could create separate objects? Probably need separate JSON per file, but instructions: \"analyze each code-chunk\". Might produce multiple JSON objects? But must be single JSON. Could set file as path and issues from all files? Probably produce one JSON per file. However only one JSON allowed. Might combine all issues across files into one object with file maybe \"multiple\". Might list issues referencing each file. We'll do file: \"Multiple\". Provide issues up to 10 total across all files. Prioritize. Let's identify major issues.\n\nArticleBaseQueueUtils:\n- resetUserQueues: If optArticleQueue empty logs error but still removes session param. Might be okay. Potential NPE: ctx.getUserSession().remove may be null if session missing. Not major.\n- resetOldSessions: similar.\n- getArticleBaseTimeout: uses Parse.toInt on setting value; if parsing fails returns 0 then timeOut stays default 1. Might be okay.\n- addQueueTable: tabSession map may be null then new HashMap fine. But after queue assignment, if freeQueues empty throws ArticleBaseQueueException but then later tabSession.put(table, queue.getTableName()); queue could be null leading NPE. Indeed if freeQueues empty, exception thrown, caught by caller? Not caught, method throws ArticleBaseQueueException. But after exception, code after else not executed. However they still call tabSession.put after else block, but it's inside else? Actually code:\n\nif (Objects.isNull(tabSession.get(table))) {\n    List<ArticleBaseQueue> freeQueues = ...;\n    if (Objects.nonNull(freeQueues) && !freeQueues.isEmpty()) {\n        queue = freeQueues.get(0);\n        ... save\n    } else {\n        throw new ArticleBaseQueueException();\n    }\n    tabSession.put(table, queue.getTableName());\n    ctx.getUserSession().put(...);\n}\n\nSo if exception thrown, the subsequent lines not executed, fine.\n\nPotential issue: queue could be null when freeQueues empty but exception thrown, fine.\n\nPotential concurrency: static methods not thread-safe; using shared ctx maybe fine.\n\nArticleUtil: many.\n\n- unLock: calls reload which may return new object but not used? It sets assortment lock param but not saved? uses CompUtils.setParameter which saves param.\n\n- isLocked: CompUtils.getParameter may return null, fine.\n\n- proofArticleBase: uses item.getComment().contains; if comment null NPE. Should check null before contains. They check item non-null but comment may be null. So NPE risk.\n\n- removeUnwantedFromList: filtered.addAll(articles); if articles null NPE. Not checked.\n\n- getEcatFiles: uses SettingUtils.getTempFolder(ctx) + File.separator + assortment.getName() may produce path without separator? they add File.separator then name. Fine. Blob.loadFromCompressedFile may throw NPE if storage.getFileblob() null; they don't check.\n\n- getImpexFiles: same.\n\n- zip: checks if zipFile non-null (always true) but not check existence. Also after compress, they delete each file but ignore deletion failures.\n\n- getFiles: returns List<File> maybe null if type unknown; but default covers.\n\n- getFile: switch includes default; but for ECAT_INPUT_POSITIV they set file name after building file; fine.\n\nPotential security: no input validation for file paths; path concatenation can lead to path traversal if malicious name.\n\nCompUtils: many.\n\n- getDirection: uses filter.getDirection may be null causing NPE.\n\n- getParameter: returns value cast; if param is BY and stored value is Integer, they call getUser which may return null; fine.\n\n- setParameter: if value is User, they store user id. No validation.\n\n- getBannerImage: returns new Image(path, IconImage.HOM_BANNER.getName()); but if path null? fine.\n\n- getSaveFloppy: path set to custom path but if setting null they still use custom path? Might be okay.\n\n- addToolTip: catches NullPointerException but may hide errors.\n\n- searchWithParameters: uses fieldTxt.getValue() without null check; searchPattern etc; logic may be flawed but not security.\n\n- searchContainsArray: uses i variable later; returns i == isValid; but i will be length after loop; isValid counts found elements; if some not found returns false.\n\n- formatToPrice: uses Parse.toDouble which may throw? but returns 0 maybe.\n\n- getKatalogVersion (overloaded): uses Setting sKatalogVersion = SettingUtils.getSettingByType; then sKatalogVersion.getValue() without null check; NPE if setting missing.\n\n- getComponentPosition: uses UI.executeJs returning string; splitting.\n\nPotential memory leak: Blob.convertObject2Byte uses ByteArrayOutputStream correctly.\n\nBase64 encode/decode uses new Base64 each call; fine.\n\nNow produce up to 10 issues across all files, prioritized.\n\nLet's list:\n\n1 High: NPE risk in proofArticleBase when comment null.\n2 High: NPE in removeUnwantedFromList when articles null.\n3 High: getParameter may return null and getUser may return null leading to unexpected behavior; also no validation for parameter existence.\n4 High: getKatalogVersion (CompUtils) assumes Setting exists, may NPE.\n5 Med: getDirection may NPE if filter null or direction null.\n6 Med: searchWithParameters may NPE if fieldTxt null, also logic complexity.\n7 Med: getBannerImage and getSaveFloppy use custom path without checking file existence properly.\n8 Low: zip method checks zipFile non-null but should check existence; also swallow IOException.\n9 Low: static utility methods not thread-safe; shared mutable state via Context may cause race conditions.\n10 Low: No input sanitization for file paths concatenated from user-provided names leading to path traversal.\n\nNow create JSON.\n\nProvide summary rating maybe 2 stars.\n\nTop todos: fix NPE in proofArticleBase, add null checks in removeUnwantedFromList, add null checks and validation in getKatalogVersion, improve searchWithParameters null safety, add input validation for file names.\n\nNow craft JSON."
      },
      "provider_specific_fields" : { }
    } ],
    "usage" : {
      "completion_tokens" : 3003,
      "prompt_tokens" : 21177,
      "total_tokens" : 24180
    },
    "timings" : {
      "cache_n" : 62,
      "prompt_n" : 21115,
      "prompt_ms" : 15852.158,
      "prompt_per_token_ms" : 0.7507533980582524,
      "prompt_per_second" : 1331.9953031000573,
      "predicted_n" : 3003,
      "predicted_ms" : 35650.321,
      "predicted_per_token_ms" : 11.871568764568766,
      "predicted_per_second" : 84.23486565520686
    }
  }
}